<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Multiplayer (Items)</title>

  <!-- React + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind utility (optional) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    /* --------------------------
       BASIC THEME + LAYOUT
       -------------------------- */
    :root{
      --rtl-orange:#FF6600;
      --rtl-red:#E31F23;
      --rtl-purple:#7B2CBF;
      --rtl-green:#22C55E;
      --bg:#0b0b0b;
      --panel:#0f0f0f;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
      --active-color: #ffd580;
      --shield-color: #8ec5ff;
    }
    html,body,#root{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{ background:linear-gradient(180deg,var(--bg), #090909); color:var(--tile); }

    * { box-sizing:border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; border-radius:0 !important; }
    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 10px; }
    input::placeholder { color: rgba(0,0,0,0.5) !important; }

    .host-screen{ display:flex; gap:20px; padding:24px; height:100vh; align-items:stretch; }
    .host-main{ flex:2; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:28px; display:flex; flex-direction:column; gap:18px; position:relative; min-height:0; }
    .host-main.fullwidth { flex:1; }
    .host-side{ flex:1; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:18px; overflow:auto; }
    .host-side.hidden { display:none; }

    .rtl-header{ display:flex; gap:12px; align-items:center; }
    .rtl-logo-text{ font-weight:800; letter-spacing:1px; color:var(--tile); }

    .card{ background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:16px; }

    .question-top-bar{ display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .countdown-badge{ width:110px; height:110px; display:flex; align-items:center; justify-content:center; font-size:2.6rem; font-weight:800; color:var(--tile); border:3px solid rgba(255,255,255,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); position:relative; flex-shrink:0; }
    .countdown-badge.warning{ border-color:var(--rtl-orange); color:var(--rtl-orange); }
    .countdown-badge.danger{ border-color:var(--rtl-red); color:var(--rtl-red); box-shadow:0 6px 30px rgba(227,31,35,0.09); transform-origin:center; animation:pulse 1s infinite; }
    @keyframes pulse { 0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)} }

    .question-text{ font-size:2.4rem; font-weight:800; color:var(--tile); line-height:1.08; margin-top:6px; }

    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:18px; margin-top:18px; }
    .answer-btn{ background: #ffffff; color:#0b0b0b; border:1px solid rgba(0,0,0,0.08); padding:20px; font-size:1.05rem; font-weight:700; min-height:110px; display:flex; align-items:center; justify-content:flex-start; gap:12px; cursor:default; }

    .result-title{ font-size:1.8rem; font-weight:900; color:var(--rtl-orange); margin-bottom:10px; }
    .correct-answer{ background: rgba(255,255,255,0.05); border-left:4px solid rgba(255,255,255,0.2); padding:12px; font-weight:700; margin-bottom:12px; color:var(--tile); }

    .result-answer-grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:12px;}
    .result-answer{ padding:12px; border:2px solid rgba(0,0,0,0.06); background:rgba(255,255,255,0.02); font-weight:700; color:var(--tile); }
    .result-answer.correct { background:#ffffff; color:#0b0b0b; border:2px solid rgba(255,255,255,0.3); }
    .result-answer.incorrect { background:#0b0b0b; color:#ffffff; border:2px solid rgba(255,255,255,0.1); }

    .leaderboard-title{ font-weight:900; letter-spacing:1px; color:var(--rtl-orange); margin-bottom:8px; border-bottom:2px solid rgba(255,255,255,0.03); padding-bottom:8px; display:inline-block; }
    .player-item{ display:flex; justify-content:space-between; gap:10px; padding:10px; background:rgba(255,255,255,0.01); border-left:4px solid rgba(255,255,255,0.02); }

    .start-card{ max-width:760px; margin:auto; padding:28px; border:1px solid rgba(255,255,255,0.03); background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); }

    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight:800; padding:10px 14px; cursor:pointer; border:none; }
    .btn-host{ background:var(--rtl-orange); color:white; }
    .btn-join{ background:var(--rtl-purple); color:white; }
    .btn-show-results{ background:var(--rtl-green); color:white; }
    .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--tile); }

    .player-card{ max-width:720px; margin:20px auto; padding:20px; border:1px solid rgba(255,255,255,0.03); background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); }

    /* Item bar */
    .item-bar{ display:flex; gap:8px; align-items:center; }
    .item-btn{ padding:8px 12px; font-weight:800; border:1px solid rgba(255,255,255,0.04); background:rgba(255,255,255,0.02); cursor:pointer; color:var(--tile); display:flex; gap:8px; align-items:center; }
    .item-btn.item-disabled{ opacity:0.35; cursor:not-allowed; }
    .item-btn.active { background: linear-gradient(90deg, #fff3cc, #ffd580); color: #000; border-color: rgba(0,0,0,0.06); box-shadow: 0 4px 14px rgba(255,213,128,0.12); }
    .item-btn.shield-active { background: linear-gradient(90deg, #dbeeff, #8ec5ff); color: #000; border-color: rgba(0,0,0,0.06); box-shadow: 0 4px 14px rgba(142,197,255,0.12); }

    .item-label{ font-weight:900; min-width:30px; text-align:center; }

    /* small screens */
    @media (max-width:900px){
      .host-screen{ flex-direction:column; padding:12px; }
      .answers-grid{ grid-template-columns:1fr; }
      .countdown-badge{ width:86px;height:86px;font-size:1.8rem; }
      .question-text{ font-size:1.6rem; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  /**************************************
   * QUIZ MIT ITEMS - Vollst√§ndiger Code
   * - Boost: 5x, wirkt nur f√ºr eine Frage, aktivieren VOR Antwort
   * - Poison: 5x, w√§hlbares Ziel, -20 pro Treffer, Angreifer erf√§hrt nicht ob geblockt
   * - Shield: 3x, wird bei Aktivierung sofort verbraucht, sch√ºtzt die laufende Frage
   **************************************/

  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 10;
  const QUESTION_TIME = 40;
  const BASE_POINTS = 100;

  // Firebase Config - behalte deine Keys / Projekt
  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ Frage-Pool (Beispiel) ************/
  const QUESTION_POOL = [
    { question: "Was ist die Hauptstadt von √ñsterreich?", answers: ["Wien","Graz","Salzburg","Innsbruck"], correct: 0 },
    { question: "Welcher Planet ist der gr√∂√üte?", answers: ["Mars","Saturn","Jupiter","Neptun"], correct: 2 },
    { question: "Wer malte die Mona Lisa?", answers: ["Picasso","Van Gogh","Da Vinci","Monet"], correct: 2 },
    { question: "In welchem Jahr fiel die Berliner Mauer?", answers: ["1987","1989","1991","1993"], correct: 1 },
    { question: "Was ist die chemische Formel f√ºr Wasser?", answers: ["CO2","H2O","O2","NaCl"], correct: 1 },
    { question: "Wie viele Kontinente gibt es?", answers: ["5","6","7","8"], correct: 2 },
    { question: "Welches ist das gr√∂√üte S√§ugetier?", answers: ["Elefant","Blauwal","Giraffe","Nashorn"], correct: 1 },
    { question: "Wer schrieb 'Romeo und Julia'?", answers: ["Goethe","Shakespeare","Schiller","Moli√®re"], correct: 1 },
    { question: "Welches Land hat die meisten Einwohner?", answers: ["Indien","China","USA","Indonesien"], correct: 1 },
    { question: "Was ist die Hauptstadt von Frankreich?", answers: ["Lyon","Marseille","Paris","Nizza"], correct: 2 },
  ];

  /************ Helferfunktionen ************/
  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }
  function generateQuestions(){
    const needed = TOTAL_ROUNDS * QUESTIONS_PER_ROUND;
    let pool = [...QUESTION_POOL];
    while(pool.length < needed) pool = pool.concat(QUESTION_POOL);
    pool = shuffle(pool).slice(0, needed).map((q, idx) => ({ id: idx, ...q }));
    return pool;
  }
  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=300`;
  }

  /************ Default Items ************/
  const DEFAULT_ITEMS = { boost: 5, poison: 5, shield: 3 };

  /************ RTL Logo - einfache SVG ************/
  function RTLLogo({size='md'}){
    const sizeMap={sm:40,md:60,lg:100};
    const h = sizeMap[size]||60;
    const w = (h/300)*1520;
    return (
      <svg viewBox="0 0 1520 300" height={h} width={w} xmlns="http://www.w3.org/2000/svg">
        <rect x="0" y="0" width="490" height="300" fill="#FF6600"/>
        <text x="245" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">R</text>
        <rect x="515" y="0" width="490" height="300" fill="#E31F23"/>
        <text x="760" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">T</text>
        <rect x="1030" y="0" width="490" height="300" fill="#7B2CBF"/>
        <text x="1275" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">L</text>
      </svg>
    );
  }

  /****************************************
   * START SCREEN (Host erstellen / Join)
   ****************************************/
  function StartScreen({ onCreate, onJoin }){
    const [name,setName] = useState('');
    const [code,setCode] = useState('');
    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div className="start-card">
          <div className="rtl-header">
            <RTLLogo size="md" />
            <div className="rtl-logo-text">AdAlliance Quiz</div>
          </div>

          <h1 className="text-3xl font-bold mt-4" style={{color:'var(--rtl-orange)'}}>üéØ Quiz Master</h1>
          <p style={{color:'var(--muted)'}}>Host erstellt Spiel oder Spieler treten per Code/QR bei</p>

          <div style={{marginTop:12}}>
            <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} />
            <div className="flex gap-3">
              <button className="btn btn-host flex-1" onClick={()=>onCreate(name)} disabled={!name}>üé¨ Host werden</button>
              <input className="p-2" placeholder="Code" value={code} onChange={e=>setCode(e.target.value.toUpperCase())} style={{width:'120px'}} />
              <button className="btn btn-join" onClick={()=>onJoin(name,code)} disabled={!name || !code}>Beitreten</button>
            </div>
            <p className="text-sm mt-3" style={{color:'var(--muted)'}}>‚ÑπÔ∏è Host ist Quizmaster und wird nicht als Spieler gez√§hlt</p>
          </div>
        </div>
      </div>
    );
  }

  /****************************************
   * HOST CONTROLLER (Sidebar Logik)
   ****************************************/
  function HostController({ gameId, meta, startNextRound, showResultsNow, startGame }){
    const [players,setPlayers] = useState({});
    useEffect(()=>{
      const ref = db.ref(`games/${gameId}/players`);
      ref.on('value', snap => setPlayers(snap.val() || {}));
      return ()=> ref.off();
    },[gameId]);

    if(!meta) return <div className="card">Lade...</div>;
    return (
      <div className="card space-y-3">
        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
          <div>
            <div style={{color:'var(--muted)'}}>Phase: <strong style={{color:'var(--rtl-orange)'}}>{meta.phase}</strong></div>
            <div style={{color:'var(--muted)'}}>Runde: <strong style={{color:'var(--rtl-orange)'}}>{meta.round || 1}/{TOTAL_ROUNDS}</strong></div>
            <div style={{color:'var(--muted)'}}>Frage: <strong style={{color:'var(--rtl-orange)'}}>{(meta.questionIndex || 0) + 1}/{TOTAL_ROUNDS * QUESTIONS_PER_ROUND}</strong></div>
          </div>
          <div style={{textAlign:'right', color:'var(--muted)'}}>üë• Spieler: {Object.keys(players).length}</div>
        </div>

        <div className="flex gap-2 flex-wrap">
          {(meta.phase === 'lobby' || !meta.phase) && <button className="btn btn-host" onClick={startGame}>Spiel starten</button>}
          {meta.phase === 'question' && <button className="btn btn-show-results" onClick={showResultsNow}>üìä Ergebnisse</button>}
          {meta.phase === 'results' && <button className="btn btn-host" onClick={startNextRound}>Weiter ‚Üí</button>}
          {meta.phase === 'roundSummary' && <button className="btn btn-host" onClick={startNextRound}>N√§chste Runde ‚Üí</button>}
          {meta.phase === 'finished' && (
            <div style={{display:'flex', gap:8}}>
              <button className="btn btn-host" onClick={()=>window.location.reload()}>üîÑ Zur√ºck zur Lobby</button>
            </div>
          )}
        </div>
      </div>
    );
  }

  /****************************************
   * HOST SCREEN (Frage, Results, RoundSummary, Finished)
   ****************************************/
  function HostScreen({ gameId, hostName }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      return ()=> { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    // Timer for questions ‚Üí automatically show results when time's up
    useEffect(()=>{
      if(!meta || meta.phase !== 'question' || !meta.questionStartTime){ setTimeLeft(0); return; }
      const tick = async ()=>{
        const elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000);
        const rem = Math.max(0, QUESTION_TIME - elapsed);
        setTimeLeft(rem);
        if(rem === 0) {
          await showResultsNow();
        }
      };
      tick();
      clearInterval(timerRef.current);
      timerRef.current = setInterval(tick, 500);
      return ()=> clearInterval(timerRef.current);
    },[meta?.phase, meta?.questionStartTime, gameId]);

    // Compute and write results into DB
    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g) return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if(!q) return;

        const playerObj = g.players || {};
        const updates = {};
        const actionLogRef = db.ref(`games/${gameId}/meta/actions/${qIndex}`);
        const actionsSnap = await actionLogRef.get();
        const actions = actionsSnap.exists() ? actionsSnap.val() : [];

        // For each player calculate points
        Object.entries(playerObj).forEach(([pid,p])=>{
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          let points = correct ? BASE_POINTS : 0;

          // Boost effect (activeEffects.boost true)
          const boostActive = p.activeEffects && p.activeEffects.boost;
          if(correct && boostActive){
            points = Math.round(points * 1.5);
          }

          // Poisons applied (array of attacker IDs)
          const poisonArr = (p.activeEffects && p.activeEffects.poisonedBy) ? p.activeEffects.poisonedBy : [];
          const poisonCount = Array.isArray(poisonArr) ? poisonArr.length : 0;
          points -= (poisonCount * 20);

          if(points < 0) points = 0;

          const newScore = (p.score || 0) + points;
          updates[`games/${gameId}/players/${pid}/score`] = newScore;
          updates[`games/${gameId}/players/${pid}/lastPoints`] = points;
        });

        // Once scores are updated, set phase to 'results'
        await db.ref().update(updates);
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });

      }catch(e){ console.error(e); }
    };

    // Advance to next question / round summary / finished
    const startNextRound = async ()=>{
      if(!meta) return;

      // If in roundSummary, go to next question index
      if(meta.phase === 'roundSummary'){
        const currentIndex = meta.questionIndex ?? 0;
        const nextIndex = currentIndex + 1;
        const totalQuestions = TOTAL_ROUNDS * QUESTIONS_PER_ROUND;

        // End if done
        if(nextIndex >= totalQuestions){
          await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
          return;
        }

        // Reset per-player currentAnswer and activeEffects for next question
        const pSnap = await db.ref(`games/${gameId}/players`).get();
        const pObj = pSnap.val() || {};
        const updates = {};
        Object.keys(pObj).forEach(pid => {
          updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
          updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        });
        await db.ref().update(updates);

        const nextRound = Math.floor(nextIndex / QUESTIONS_PER_ROUND) + 1;
        await db.ref(`games/${gameId}/meta`).update({
          questionIndex: nextIndex,
          phase: 'question',
          questionStartTime: Date.now(),
          round: nextRound
        });
        return;
      }

      // Normal flow from results -> next question OR round summary
      const currentIndex = meta.questionIndex ?? 0;
      const nextIndex = currentIndex + 1;
      const totalQuestions = TOTAL_ROUNDS * QUESTIONS_PER_ROUND;

      if(nextIndex >= totalQuestions){
        await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
        return;
      }
      const currentRound = Math.floor(currentIndex / QUESTIONS_PER_ROUND) + 1;
      const nextRound = Math.floor(nextIndex / QUESTIONS_PER_ROUND) + 1;

      // If next question starts a new round -> show roundSummary
      if(nextRound > currentRound){
        await db.ref(`games/${gameId}/meta`).update({ phase: 'roundSummary', round: nextRound });
        return;
      }

      // else continue
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
      });
      await db.ref().update(updates);

      await db.ref(`games/${gameId}/meta`).update({
        questionIndex: nextIndex,
        phase: 'question',
        questionStartTime: Date.now(),
        round: nextRound
      });
    };

    // Start the game => write questions; reset players (items kept as default on first start)
    const startGame = async ()=>{
      const questions = generateQuestions();
      const metaObj = {
        phase: 'question',
        questionIndex: 0,
        round: 1,
        questionStartTime: Date.now()
      };
      await db.ref(`games/${gameId}/questions`).set(questions);

      // Initialize players: score 0, items default if missing, activeEffects reset
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        // if items already exist, keep them (e.g., restart); otherwise set defaults
        if(!(pObj[pid] && pObj[pid].items)){
          updates[`games/${gameId}/players/${pid}/items`] = DEFAULT_ITEMS;
        }
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).set(metaObj);

      // clear actions log
      await db.ref(`games/${gameId}/meta/actions`).remove();
    };

    const backToLobby = async ()=>{
      // Reset meta, remove questions and reset players' states and items
      await db.ref(`games/${gameId}/meta`).set({ phase: 'lobby' });
      await db.ref(`games/${gameId}/questions`).remove();
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/items`] = DEFAULT_ITEMS;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
      });
      await db.ref().update(updates);
    };

    if(!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const countdownClass = timeLeft <= 10 ? 'danger' : timeLeft <= 20 ? 'warning' : '';

    const showSidebar = meta.phase === 'lobby';

    return (
      <div className="min-h-screen host-screen">
        <div className={`host-main ${!showSidebar ? 'fullwidth' : ''}`}>
          {/* LOBBY */}
          {meta.phase === 'lobby' && (
            <div style={{display:'flex', flexDirection:'column', alignItems:'center', gap:12}}>
              <div style={{display:'flex', alignItems:'center', gap:12}}>
                <RTLLogo size="lg" />
                <div className="rtl-logo-text text-2xl">AdAlliance Quiz</div>
              </div>
              <h2 style={{fontSize:36, fontWeight:900}}>‚è≥ Warte auf Spieler</h2>
              <p style={{color:'var(--muted)'}}>Spielcode:</p>
              <div style={{fontFamily:'monospace', background:'#fff', color:'#000', padding:'8px 12px', fontSize:24, fontWeight:900}}>{gameId}</div>

              {playersArr.length > 0 && (
                <div style={{marginTop:20, width:'100%', maxWidth:600}}>
                  <h3 style={{fontSize:18, fontWeight:800, marginBottom:12, color:'var(--rtl-orange)'}}>Angemeldete Spieler ({playersArr.length})</h3>
                  <div style={{display:'grid', gap:8}}>
                    {playersArr.map((p,i)=>(p && (
                      <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:12, background:'rgba(255,255,255,0.02)', borderLeft:'3px solid var(--rtl-purple)'}}>
                        <div style={{fontWeight:700}}>{p.name}</div>
                        <div style={{color:'var(--muted)'}}>Bereit ‚úì</div>
                      </div>
                    )))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* QUESTION VIEW */}
          {meta.phase === 'question' && question && (
            <div style={{display:'flex', flexDirection:'column', gap:12, minHeight:0}}>
              <div className="question-top-bar">
                <div style={{display:'flex', alignItems:'center', gap:12}}>
                  <div className={`countdown-badge ${countdownClass}`}>{timeLeft}</div>
                  <div>
                    <div style={{fontSize:14, color:'var(--muted)'}}>Runde {meta.round}/{TOTAL_ROUNDS}</div>
                    <div style={{fontSize:14, color:'var(--muted)'}}>Frage {qIndex + 1}/{TOTAL_ROUNDS * QUESTIONS_PER_ROUND}</div>
                  </div>
                </div>
                <div style={{display:'flex', gap:8}}>
                  <button className="btn btn-show-results" onClick={showResultsNow}>üìä Ergebnisse</button>
                </div>
              </div>

              <div>
                <div className="question-text">{question.question}</div>
                <div className="answers-grid" style={{marginTop:18}}>
                  {question.answers.map((a,i)=>((
                    <div key={i} className="answer-btn">
                      <div style={{fontWeight:900, marginRight:8}}>{String.fromCharCode(65+i)}.</div>
                      <div>{a}</div>
                    </div>
                  )))}
                </div>
              </div>
            </div>
          )}

          {/* RESULTS VIEW (Host sees actions + per-player lastPoints) */}
          {meta.phase === 'results' && question && (
            <div className="results-section">
              <h2 className="result-title">üìä Ergebnisse</h2>
              <div className="correct-answer">‚úì Richtige Antwort: <strong>{question.answers[question.correct]}</strong></div>

              <div className="result-answer-grid">
                {question.answers.map((a,i)=>{
                  const voters = playersArr.filter(p => p.currentAnswer === i);
                  const isCorrect = i === question.correct;
                  return (
                    <div key={i} className={`result-answer ${isCorrect ? 'correct' : 'incorrect'}`}>
                      <div style={{fontWeight:900}}>{String.fromCharCode(65+i)}. {a}</div>
                      <div style={{opacity:0.7, marginTop:8}}>{voters.length > 0 ? voters.map(p => {
                        const boostActive = p.activeEffects && p.activeEffects.boost;
                        return p.name + (boostActive ? ' üî•' : '');
                      }).join(', ') : '(Niemand)'}</div>
                    </div>
                  );
                })}
              </div>

              {/* Action log + per-player effects */}
              <div style={{marginTop:18}}>
                <h3 style={{fontWeight:900, color:'var(--rtl-orange)'}}>Aktionen & Effekte (diese Frage)</h3>
                <div style={{marginTop:8, display:'grid', gap:8}}>
                  {playersArr.map((p)=>((
                    <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:10, background:'rgba(255,255,255,0.01)', borderLeft:'4px solid rgba(255,255,255,0.03)'}}>
                      <div style={{display:'flex', gap:12, alignItems:'center'}}>
                        <div style={{fontWeight:900}}>{p.name}</div>
                        <div style={{color:'var(--muted)', fontSize:13}}>
                          {/* Show poisoners and shield state in results (full transparency) */}
                          { (p.activeEffects && p.activeEffects.poisonedBy && p.activeEffects.poisonedBy.length > 0) ? `Vergiftet von: ${p.activeEffects.poisonedBy.map(id=>{
                              const pl = playersArr.find(x => x.pid === id);
                              return pl ? pl.name : id;
                            }).join(', ')}` : (p.activeEffects && p.activeEffects.shield ? 'Gesch√ºtzt (Schild)' : 'Keine Effekte') }
                        </div>
                      </div>
                      <div style={{display:'flex', gap:10, alignItems:'center'}}>
                        <div style={{fontSize:14}}>üî•{(p.items && p.items.boost) ? p.items.boost : 0}</div>
                        <div style={{fontSize:14}}>‚ò†Ô∏è{(p.items && p.items.poison) ? p.items.poison : 0}</div>
                        <div style={{fontSize:14}}>üõ°{(p.items && p.items.shield) ? p.items.shield : 0}</div>
                        <div style={{fontWeight:900, minWidth:80, textAlign:'right'}}>{p.lastPoints || 0} pts</div>
                      </div>
                    </div>
                  )))}
                </div>
              </div>

              <div style={{marginTop:20}}>
                <button className="btn btn-host" onClick={startNextRound}>N√§chste Frage ‚Üí</button>
              </div>
            </div>
          )}

          {/* ROUND SUMMARY: Zwischenergebnis mit ITEM-Vorr√§ten (wie gew√ºnscht) */}
          {meta.phase === 'roundSummary' && (
            <div className="round-summary">
              <h2 className="result-title">üèÜ Zwischenstand nach Runde {meta.round - 1}</h2>
              <p style={{color:'var(--muted)', marginBottom:20}}>Hier ist der aktuelle Stand aller Spieler (inkl. Item-Vorrat)</p>

              <div style={{display:'grid', gap:12, maxWidth:900, margin:'0 auto'}}>
                {playersArr.map((p,i)=>{
                  const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'';
                  return (
                    <div key={p.pid} style={{
                      display:'flex',
                      justifyContent:'space-between',
                      alignItems:'center',
                      padding:16,
                      background: i < 3 ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.01)',
                      borderLeft:`4px solid ${i===0?'#FFD700':i===1?'#C0C0C0':i===2?'#CD7F32':'rgba(255,255,255,0.1)'}`
                    }}>
                      <div style={{display:'flex', gap:12, alignItems:'center', flex:1}}>
                        <div style={{fontSize:20, width:40}}>{medal || `#${i+1}`}</div>
                        <div style={{fontWeight:800, fontSize:18}}>{p.name}</div>
                      </div>
                      <div style={{display:'flex', gap:20, alignItems:'center'}}>
                        {/* Show item counts here (Zwischenergebnis) */}
                        <div style={{fontSize:14, fontWeight:700}}>üî• { (p.items && p.items.boost) ? p.items.boost : 0 }</div>
                        <div style={{fontSize:14, fontWeight:700}}>‚ò†Ô∏è { (p.items && p.items.poison) ? p.items.poison : 0 }</div>
                        <div style={{fontSize:14, fontWeight:700}}>üõ° { (p.items && p.items.shield) ? p.items.shield : 0 }</div>
                        <div style={{fontSize:22, fontWeight:900, color:'var(--tile)', minWidth:80, textAlign:'right'}}>{p.score || 0} pts</div>
                      </div>
                    </div>
                  );
                })}
              </div>

              <div style={{marginTop:30, textAlign:'center'}}>
                <button className="btn btn-host" style={{fontSize:18, padding:'14px 28px'}} onClick={startNextRound}>Weiter zur n√§chsten Runde ‚Üí</button>
              </div>
            </div>
          )}

          {/* FINISHED: Endergebnis (wird keine Item-Vorr√§te anzeigen - wie gew√ºnscht) */}
          {meta.phase === 'finished' && (
            <div style={{textAlign:'center', maxWidth:900, margin:'0 auto'}}>
              <h2 className="result-title" style={{fontSize:'2.5rem', marginBottom:8}}>üéâ Spiel beendet!</h2>
              <p style={{color:'var(--muted)', fontSize:18, marginBottom:30}}>Das Quiz ist vorbei - hier sind die finalen Ergebnisse</p>

              <div style={{display:'flex', gap:20, justifyContent:'center', alignItems:'flex-end', marginBottom:40}}>
                {playersArr.slice(0,3).map((p,i)=>{
                  const heights = {0: 180, 1: 140, 2: 110};
                  const colors = {0: '#FFD700', 1: '#C0C0C0', 2: '#CD7F32'};
                  const order = i===0 ? 1 : i===1 ? 0 : 2;
                  const medals = ['ü•á','ü•à','ü•â'];
                  return (
                    <div key={p.pid} style={{order, flex:1, maxWidth:200}}>
                      <div style={{fontSize:48, marginBottom:8}}>{medals[i]}</div>
                      <div style={{fontWeight:900, fontSize:20, marginBottom:8}}>{p.name}</div>
                      <div style={{fontSize:28, fontWeight:900, color:colors[i], marginBottom:12}}>{p.score || 0} pts</div>
                      <div style={{
                        height:heights[i],
                        background:`linear-gradient(180deg, ${colors[i]}, ${colors[i]}CC)`,
                        display:'flex',
                        alignItems:'center',
                        justifyContent:'center',
                        fontSize:32,
                        fontWeight:900,
                        color:'#0b0b0b'
                      }}>
                        #{i+1}
                      </div>
                    </div>
                  );
                })}
              </div>

              {playersArr.length > 3 && (
                <div style={{marginTop:40}}>
                  <h3 style={{fontSize:20, fontWeight:800, marginBottom:16, color:'var(--rtl-orange)'}}>Weitere Platzierungen</h3>
                  <div style={{display:'grid', gap:8}}>
                    {playersArr.slice(3).map((p,i)=>((
                      <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:12, background:'rgba(255,255,255,0.01)', borderLeft:'4px solid rgba(255,255,255,0.1)'}}>
                        <div style={{fontWeight:700}}>#{i+4} {p.name}</div>
                        <div style={{fontWeight:900, color:'var(--tile)'}}>{p.score || 0} pts</div>
                      </div>
                    )))}
                  </div>
                </div>
              )}

              <div style={{marginTop:40}}>
                <button className="btn btn-host" style={{fontSize:18, padding:'14px 28px'}} onClick={backToLobby}>üîÑ Zur√ºck zur Lobby</button>
              </div>
            </div>
          )}

        </div>

        {/* Sidebar in Lobby */}
        {showSidebar && (
          <div className="host-side">
            <HostController gameId={gameId} meta={meta} startNextRound={startNextRound} showResultsNow={showResultsNow} startGame={startGame} />

            <div style={{marginTop:16}}>
              <h3 className="leaderboard-title">üèÖ Spieler & Punkte</h3>
              <div style={{maxHeight:220, overflow:'auto', marginTop:8}}>
                {playersArr.map((p,idx)=>((
                  <div key={p.pid} className="player-item">
                    <div style={{display:'flex', gap:8, alignItems:'center'}}>
                      <div style={{fontWeight:900, color:'var(--rtl-purple)'}}>#{idx+1}</div>
                      <div style={{fontWeight:700}}>{p.name}</div>
                    </div>
                    <div style={{display:'flex', gap:12, alignItems:'center'}}>
                      <div style={{fontWeight:900, color:'var(--rtl-green)'}}>{p.score || 0}</div>
                      <div style={{fontSize:13, color:'var(--muted)'}}>üî•{(p.items && p.items.boost) ? p.items.boost : 0} ‚ò†Ô∏è{(p.items && p.items.poison) ? p.items.poison : 0} üõ°{(p.items && p.items.shield) ? p.items.shield : 0}</div>
                    </div>
                  </div>
                )))}
              </div>
            </div>

            <div style={{marginTop:18}}>
              <h3 className="leaderboard-title">‚ÑπÔ∏è Code & QR</h3>
              <div style={{marginTop:8}}>
                <div style={{marginBottom:8}}><span style={{fontFamily:'monospace', background:'#fff', color:'#000', padding:'4px 8px'}}>{gameId}</span></div>
                <img src={qrUrlForGame(gameId)} alt="QR Code" style={{width:'100%'}} />
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * PLAYER VIEW (Player UI & Item Actions)
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [localSelectingTargetFor, setLocalSelectingTargetFor] = useState(null); // 'poison' when selecting target
    const [justActivatedItem, setJustActivatedItem] = useState(null); // visual feedback: last activated item

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); mRef.off(); pRef.off(); };
    },[gameId, playerId]);

    useEffect(()=>{
      if(!meta || meta.phase !== 'question' || !meta.questionStartTime){ setTimeLeft(0); return; }
      const tick = ()=>{
        const elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000);
        setTimeLeft(Math.max(0, QUESTION_TIME - elapsed));
      };
      tick();
      const t = setInterval(tick, 500);
      return ()=> clearInterval(t);
    },[meta?.questionStartTime, meta?.phase]);

    if(!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];

    // LOBBY VIEW
    if(meta.phase === 'lobby'){
      return (
        <div className="min-h-screen" style={{padding:20, background:'var(--bg)'}}>
          <div className="player-card">
            <div style={{display:'flex', alignItems:'center', gap:12}}>
              <RTLLogo size="sm" />
              <div style={{fontWeight:900}}>AdAlliance</div>
            </div>
            <h2 style={{fontSize:20, fontWeight:900, marginTop:8, color:'var(--rtl-orange)'}}>Warte auf Start</h2>
            <p style={{color:'var(--muted)'}}>Spielcode: <span style={{fontFamily:'monospace', background:'#fff', color:'#000', padding:'2px 6px'}}>{gameId}</span></p>
            <p style={{marginTop:6}}>Dein Name: <strong>{player.name}</strong></p>
            <div style={{marginTop:12, color:'var(--muted)'}}>Items: üî•{(player.items && player.items.boost) ? player.items.boost : 0}  ‚ò†Ô∏è{(player.items && player.items.poison) ? player.items.poison : 0}  üõ°{(player.items && player.items.shield) ? player.items.shield : 0}</div>
          </div>
        </div>
      );
    }

    // QUESTION VIEW
    if(meta.phase === 'question' && question){
      const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
      const boostAvailable = (player.items && player.items.boost > 0);
      const poisonAvailable = (player.items && player.items.poison > 0);
      const shieldAvailable = (player.items && player.items.shield > 0);
      const boostActive = player.activeEffects && player.activeEffects.boost;
      const shieldActive = player.activeEffects && player.activeEffects.shield;

      // Answer click
      const answerClick = async (i)=>{
        if(hasAnswered || timeLeft <= 0) return;
        await db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i);
      };

      // Activate Boost: must be BEFORE answer (Option A)
      const activateBoost = async ()=>{
        if(!boostAvailable) return;
        if(player.currentAnswer !== null && player.currentAnswer !== undefined){
          alert('Boost muss vor der Antwort aktiviert werden.');
          return;
        }
        // decrement item and set activeEffects.boost true immediately
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/items/boost`] = (player.items.boost - 1);
        updates[`games/${gameId}/players/${playerId}/activeEffects/boost`] = true;
        await db.ref().update(updates);
        setJustActivatedItem('boost');
        // visual active state remains until question end
      };

      // Activate Shield: consumes immediately, remains active for this question
      const activateShield = async ()=>{
        if(!shieldAvailable) return;
        // consume shield immediately (per your request - risk)
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/items/shield`] = (player.items.shield - 1);
        updates[`games/${gameId}/players/${playerId}/activeEffects/shield`] = true;
        await db.ref().update(updates);
        setJustActivatedItem('shield');
      };

      // Activate Poison: choose a target. IMPORTANT: attacker must NOT be told if the target was protected
      const activatePoison = async ()=>{
        if(!poisonAvailable) return;
        // present a selection of other players
        const playerEntries = Object.entries(game.players || {}).filter(([pid]) => pid !== playerId);
        if(playerEntries.length === 0){ alert('Keine anderen Spieler verf√ºgbar'); return; }

        // render a simple prompt with numbered list
        let promptText = 'Wen willst du vergiften? (Nummer eingeben)\\n';
        playerEntries.forEach(([pid,p], idx) => {
          promptText += `${idx+1}: ${p.name}\\n`;
        });
        const choice = prompt(promptText + '\\nGib die Nummer ein, z.B. 1');
        if(!choice) return;
        const idx = parseInt(choice,10) - 1;
        if(isNaN(idx) || idx < 0 || idx >= playerEntries.length){ alert('Ung√ºltige Auswahl'); return; }
        const [targetPid, targetPlayer] = playerEntries[idx];

        // decrement attacker's poison count immediately (attacker uses the resource)
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/items/poison`] = (player.items.poison - 1);

        // write action to meta/actions/<qIndex> log (so host can later inspect)
        const qIndexLocal = meta.questionIndex || 0;
        const actionRef = db.ref(`games/${gameId}/meta/actions/${qIndexLocal}`);

        // fetch target to check shield (we will apply effect if no shield, or log blocked if shield)
        const targetSnap = await db.ref(`games/${gameId}/players/${targetPid}`).get();
        if(!targetSnap.exists()){
          // still consume attacker's poison
          await db.ref().update(updates);
          alert('Ziel nicht gefunden.');
          return;
        }
        const targetData = targetSnap.val();
        const targetShield = targetData.activeEffects && targetData.activeEffects.shield;

        const actionsSnap = await actionRef.get();
        const existingActions = actionsSnap.exists() ? actionsSnap.val() : [];

        if(targetShield){
          // Blocked: record action as blocked ‚Äî but do NOT inform attacker of block (surprise)
          existingActions.push({ type:'poison', from: playerId, to: targetPid, blocked: true, ts: Date.now() });
          await actionRef.set(existingActions);

          // attacker already lost the poison resource (updates contains decremented poison)
          await db.ref().update(updates);
          // Inform attacker only that the action was sent ‚Äî not whether it was blocked
          alert('Gift eingesetzt (Ergebnis wird nach Ende der Frage angezeigt).');
          setJustActivatedItem('poison');
          return;
        } else {
          // Not shielded: append attacker to target.activeEffects.poisonedBy
          const prevPoisoned = (targetData.activeEffects && Array.isArray(targetData.activeEffects.poisonedBy)) ? targetData.activeEffects.poisonedBy : [];
          const newPoisoned = [...prevPoisoned, playerId];
          updates[`games/${gameId}/players/${targetPid}/activeEffects/poisonedBy`] = newPoisoned;

          existingActions.push({ type:'poison', from: playerId, to: targetPid, blocked: false, ts: Date.now() });
          await actionRef.set(existingActions);

          await db.ref().update(updates);
          setJustActivatedItem('poison');
          alert('Gift eingesetzt (Ergebnis wird nach Ende der Frage angezeigt).');
          return;
        }
      };

      // UI: item button classes and disabled state
      const boostBtnClass = `item-btn ${(boostAvailable && !hasAnswered) ? '' : 'item-disabled'} ${ (player.activeEffects && player.activeEffects.boost) ? 'active' : '' }`;
      const poisonBtnClass = `item-btn ${(poisonAvailable) ? '' : 'item-disabled'} `;
      const shieldBtnClass = `item-btn ${(shieldAvailable) ? '' : 'item-disabled'} ${ (player.activeEffects && player.activeEffects.shield) ? 'shield-active' : '' }`;

      return (
        <div className="min-h-screen" style={{padding:20, background:'var(--bg)'}}>
          <div className="player-card">
            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
              <div>Runde {meta.round}/{TOTAL_ROUNDS}</div>
              <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)'}}>{timeLeft}s</div>
            </div>

            <h3 style={{fontSize:18,fontWeight:900, marginTop:12}}>{question.question}</h3>

            <div className="player-answers" style={{marginTop:12, display:'grid', gap:10}}>
              {question.answers.map((ans,i)=>{
                const disabled = hasAnswered || timeLeft <= 0;
                const isSelected = player.currentAnswer === i;
                const style = isSelected ? {background:'var(--rtl-purple)', color:'#fff', borderColor:'var(--rtl-purple)'} : {};
                return (
                  <button key={i} disabled={disabled} onClick={()=>answerClick(i)} style={style} className="p-3 font-bold">
                    <div style={{display:'flex', gap:10, alignItems:'center'}}><div style={{fontWeight:900}}>{String.fromCharCode(65+i)}.</div><div>{ans}</div></div>
                  </button>
                );
              })}
            </div>

            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginTop:14}}>
              <div style={{color: 'var(--muted)'}}>{player.currentAnswer === null ? "Noch nicht geantwortet" : `Du hast Antwort ${String.fromCharCode(65 + player.currentAnswer)} gew√§hlt`}</div>
              <div style={{display:'flex', gap:8, alignItems:'center'}}>
                <div style={{fontWeight:900, color:'var(--rtl-green)'}}>Punkte: {player.score || 0}</div>

                {/* Item bar */}
                <div className="item-bar" style={{alignItems:'center'}}>
                  {/* Boost */}
                  <button
                    className={boostBtnClass}
                    disabled={!boostAvailable || hasAnswered}
                    onClick={activateBoost}
                    title={'Boost: muss vor der Antwort aktiviert werden. Richtige Antwort -> x1.5 (5√ó pro Spiel)'}
                  >
                    <span style={{fontSize:18}}>üî•</span>
                    <span className="item-label">{player.items && player.items.boost ? player.items.boost : 0}</span>
                    <div style={{fontSize:12}}>{ (player.activeEffects && player.activeEffects.boost) ? 'Aktiv' : 'Boost' }</div>
                  </button>

                  {/* Poison */}
                  <button
                    className={poisonBtnClass}
                    disabled={!poisonAvailable}
                    onClick={activatePoison}
                    title={'Vergiften: w√§hle ein Ziel. (5√ó pro Spiel). Ergebnis wird nach Frage gezeigt.'}
                  >
                    <span style={{fontSize:18}}>‚ò†Ô∏è</span>
                    <span className="item-label">{player.items && player.items.poison ? player.items.poison : 0}</span>
                    <div style={{fontSize:12}}>Poison</div>
                  </button>

                  {/* Shield */}
                  <button
                    className={shieldBtnClass}
                    disabled={!shieldAvailable}
                    onClick={activateShield}
                    title={'Schild: wird sofort verbraucht, sch√ºtzt diese Frage (3√ó pro Spiel)'}
                  >
                    <span style={{fontSize:18}}>üõ°</span>
                    <span className="item-label">{player.items && player.items.shield ? player.items.shield : 0}</span>
                    <div style={{fontSize:12}}>{ (player.activeEffects && player.activeEffects.shield) ? 'Aktiv' : 'Schild' }</div>
                  </button>
                </div>
              </div>
            </div>

            <div style={{marginTop:10, color:'var(--muted)', fontSize:13}}>
              Info: Items sind Ressourcen f√ºr das gesamte Spiel.<br/>
              üî• Boost: muss <strong>vor</strong> der Antwort aktiviert werden und wirkt nur f√ºr diese Frage (x1.5 bei richtig).<br/>
              ‚ò†Ô∏è Gift: w√§hle ein Ziel w√§hrend der Frage; Ziel verliert -20 Punkte f√ºr diese Frage (Schild blockt). Der Angreifer erf√§hrt nicht, ob das Ziel gesch√ºtzt war (√úberraschung).<br/>
              üõ° Schild: verbraucht sich sofort bei Aktivierung und sch√ºtzt diese Frage ‚Äì auch wenn niemand angreift (Risiko).
            </div>
          </div>
        </div>
      );
    }

    // RESULTS VIEW (Player sees lastPoints and effects; attackers now can see whether poison hit or was blocked)
    if(meta.phase === 'results' && question){
      const wasCorrect = player.currentAnswer === question.correct;
      const poisonedBy = (player.activeEffects && player.activeEffects.poisonedBy) ? player.activeEffects.poisonedBy : [];
      const shieldActive = player.activeEffects && player.activeEffects.shield;

      // Build poison message: show who poisoned you (and whether shield prevented?) - for target we can show shield info
      let poisonMsg = '';
      if(poisonedBy.length === 0){
        if(shieldActive){
          poisonMsg = 'Schild aktiv ‚Äî kein Gift';
        } else {
          poisonMsg = 'Nicht vergiftet';
        }
      } else {
        // map attacker ids to names using game.players
        const names = poisonedBy.map(id => {
          const found = Object.entries(game.players || {}).find(([k]) => k === id);
          return found ? found[1].name : id;
        });
        poisonMsg = `Vergiftet von: ${names.join(', ')}`;
      }

      return (
        <div className="min-h-screen" style={{padding:20, background:'var(--bg)'}}>
          <div className="player-card" style={{textAlign:'center'}}>
            <h3 style={{fontSize:26, fontWeight:900, color: wasCorrect ? 'var(--rtl-green)' : '#ff6b6b'}}>{wasCorrect ? 'Richtig! üéâ' : 'Falsch üòï'}</h3>
            <p style={{marginTop:8}}>Richtige Antwort: <strong style={{color:'var(--rtl-green)'}}>{question.answers[question.correct]}</strong></p>
            <p style={{marginTop:8}}>Punkte diese Frage: <strong style={{color:'var(--rtl-green)'}}>{player.lastPoints || 0}</strong></p>
            <p style={{marginTop:8}}>Dein Punktestand: <strong style={{color:'var(--rtl-green)'}}>{player.score || 0}</strong></p>
            <p style={{marginTop:8, color:'var(--muted)'}}>Status: {poisonMsg}{shieldActive ? ' (Schild aktiv)' : ''}</p>
            <p style={{marginTop:8, color:'var(--muted)'}}>Warte auf den Host f√ºr die n√§chste Frage.</p>
          </div>
        </div>
      );
    }

    // ROUND SUMMARY OR FINISHED view for player
    if(meta.phase === 'roundSummary' || meta.phase === 'finished'){
      const playersSorted = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      const title = meta.phase === 'finished' ? 'üéâ Spiel beendet!' : `üèÜ Zwischenstand nach Runde ${meta.round - 1}`;
      const subtitle = meta.phase === 'finished' ? 'Das Quiz ist vorbei - hier sind die finalen Ergebnisse' : 'Hier ist der aktuelle Stand';

      return (
        <div className="min-h-screen" style={{padding:20, background:'var(--bg)'}}>
          <div className="player-card">
            <h3 style={{fontSize:20, fontWeight:900, color:'var(--rtl-orange)', textAlign:'center', marginBottom:8}}>{title}</h3>
            <p style={{textAlign:'center', color:'var(--muted)', marginBottom:16}}>{subtitle}</p>

            <div style={{marginTop:12, background:'rgba(255,255,255,0.01)', padding:8}}>
              {playersSorted.map((p,i)=> {
                const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':'';
                return (
                  <div key={p.pid} style={{
                    display:'flex',
                    justifyContent:'space-between',
                    alignItems:'center',
                    padding:'10px 0',
                    borderBottom: i < playersSorted.length - 1 ? '1px solid rgba(255,255,255,0.05)' : 'none'
                  }}>
                    <div style={{display:'flex', gap:8, alignItems:'center', flex:1}}>
                      <span style={{fontSize:16, minWidth:30}}>{medal || `#${i+1}`}</span>
                      <span style={{fontWeight:700}}>{p.name}</span>
                    </div>
                    <div style={{display:'flex', gap:12, alignItems:'center'}}>
                      {/* Show item counts in round summary (player requested) */}
                      <span style={{fontSize:16}}>üî•{(p.items && p.items.boost) ? p.items.boost : 0}</span>
                      <span style={{fontSize:16}}>‚ò†Ô∏è{(p.items && p.items.poison) ? p.items.poison : 0}</span>
                      <span style={{fontSize:16}}>üõ°{(p.items && p.items.shield) ? p.items.shield : 0}</span>
                      <span style={{fontWeight:900, minWidth:60, textAlign:'right'}}>{p.score || 0} pts</span>
                    </div>
                  </div>
                );
              })}
            </div>

            <p style={{marginTop:16, color:'var(--muted)', textAlign:'center', fontSize:14}}>
              {meta.phase === 'finished' ? 'Warte auf den Host...' : 'Host startet die n√§chste Runde, sobald er bereit ist.'}
            </p>
          </div>
        </div>
      );
    }

    return <div>Warte...</div>;
  }

  /****************************************
   * PLAYER JOIN (Einloggen ins Spiel)
   ****************************************/
  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');
    const [error,setError] = useState('');

    const handleJoin = async ()=>{
      setError('');
      try{
        const snap = await db.ref(`games/${joinGameId}`).get();
        if(!snap.exists()){ setError('Spiel nicht gefunden'); return; }
        const pid = makePlayerId();
        const playerObj = {
          name,
          score: 0,
          currentAnswer: null,
          joinedAt: Date.now(),
          items: DEFAULT_ITEMS,
          activeEffects: { boost:false, shield:false, poisonedBy: [] },
          lastPoints: 0
        };
        await db.ref(`games/${joinGameId}/players/${pid}`).set(playerObj);
        localStorage.setItem(`quiz_player_${joinGameId}`, pid);
        localStorage.setItem(`quiz_name_${joinGameId}`, name);
        onJoined(joinGameId, pid, name);
      }catch(e){ console.error(e); setError('Fehler beim Beitreten'); }
    };

    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div className="player-card">
          <div style={{display:'flex', gap:12, alignItems:'center'}}>
            <RTLLogo size="sm" />
            <div style={{fontWeight:900}}>AdAlliance</div>
          </div>
          <h2 style={{fontSize:20, fontWeight:900, marginTop:8, color:'var(--rtl-orange)'}}>Spiel beitreten</h2>
          <p>Code: <span style={{fontFamily:'monospace'}}>{joinGameId}</span></p>
          <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} />
          <button className="btn btn-host w-full" onClick={handleJoin} disabled={!name}>Beitreten</button>
          {error && <div style={{color:'#ff6b6b', marginTop:8}}>{error}</div>}
        </div>
      </div>
    );
  }

  /****************************************
   * APP (Routing zwischen Start / Host / Player)
   ****************************************/
  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');
    const [playerName,setPlayerName] = useState('');
    const [hostName,setHostName] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ setMode('playerJoin'); setGameId(joinCode); }
    },[]);

    const handleCreate = async (name)=>{
      setHostName(name);
      const gid = randomGameID();
      setGameId(gid);
      // create game with meta lobby
      await db.ref(`games/${gid}/meta`).set({ phase: 'lobby' });
      setMode('hostLobby');
    };

    const handleJoin = async (name, code)=>{
      try{
        const snap = await db.ref(`games/${code}`).get();
        if(!snap.exists()){ alert('Spiel nicht gefunden'); return; }
        const pid = makePlayerId();
        const playerObj = {
          name,
          score: 0,
          currentAnswer: null,
          joinedAt: Date.now(),
          items: DEFAULT_ITEMS,
          activeEffects: { boost:false, shield:false, poisonedBy: [] },
          lastPoints: 0
        };
        await db.ref(`games/${code}/players/${pid}`).set(playerObj);
        setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame');
      }catch(e){ console.error(e); alert('Fehler'); }
    };

    const handlePlayerJoined = (code,pid,name) => { setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} hostName={hostName} />}
        {mode === 'playerGame' && <PlayerView gameId={gameId} playerId={playerId} />}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }

  ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>




