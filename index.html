<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Final Stable</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script src="https://cdn.tailwindcss.com"></script>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    :root{
      --rtl-orange:#FF6600;
      --rtl-red:#E31F23;
      --rtl-purple:#7B2CBF;
      --rtl-green:#22C55E;
      --bg:#0b0b0b;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
    }
    
    /* RADIKALER RESET F√úR KANTIGES DESIGN */
    * { border-radius: 0px !important; }
    button, div, span, input, img { border-radius: 0px !important; }

    html,body,#root{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; overflow: hidden;}
    body{ background:linear-gradient(180deg,var(--bg), #090909); color:var(--tile); }
    
    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: var(--rtl-orange); }
    ::-webkit-scrollbar-thumb:hover { background: #ff8533; }

    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 12px; font-weight: 600; }
    
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight:900; padding:14px 28px; cursor:pointer; border:none; background:rgba(255,255,255,0.1); color:var(--tile); font-size:18px; transition: background 0.2s; text-transform: uppercase; letter-spacing: 1px; border: 1px solid rgba(255,255,255,0.1); }
    .btn:hover { background:rgba(255,255,255,0.25); }
    .btn:active { transform: translateY(2px); }

    .btn-host{ background:var(--rtl-orange); color:white; border: 1px solid var(--rtl-orange); }
    .btn-host:hover { background: #ff7b24; }
    
    .btn-join{ background:var(--rtl-purple); color:white; border: 1px solid var(--rtl-purple); }
    
    /* Gold Pause Button */
    .btn-pause-gold {
      background: #FFD700;
      color: #000;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      font-weight: 900;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 50;
    }
    .btn-pause-gold:hover { background: #ffeb3b; transform: scale(1.05); }

    .btn-show-results{
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: var(--tile);
    }
    .btn-show-results:hover { background: rgba(255,255,255,0.3); }

    .card{ padding:30px; background: #111; border:1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    
    .host-screen{ display:flex; width: 100%; height:100vh; overflow:hidden; position: relative; background: var(--bg); }
    .host-side{ flex:0 0 400px; padding:30px; background: #050505; border-left:2px solid rgba(255,255,255,0.05); display: flex; flexDirection: column; gap: 20px; z-index: 10; }
    .host-main{ flex:1; display:flex; flex-direction:column; height: 100%; position: relative; }
    
    .host-main-inner {
        padding: 40px;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at center, #1a1a1a 0%, #000000 120%);
    }

    .game-top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 40px;
        background: #000;
        border-bottom: 2px solid rgba(255,255,255,0.08);
    }

    .countdown-badge{ width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:2.8rem; font-weight:900; color:var(--tile); border:4px solid rgba(255,255,255,0.15); background:#000; }
    .countdown-badge.warning{ border-color:var(--rtl-orange); color:var(--rtl-orange); }
    .countdown-badge.danger{ border-color:var(--rtl-red); color:var(--rtl-red); background: rgba(227,31,35,0.1); }
    
    /* Question Area Filling Fix */
    .question-area { 
        flex-grow: 1; /* Nimmt allen verf√ºgbaren Platz ein */
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px 60px; 
        text-align: center;
    }
    .question-text {
        font-size: 6vh; /* Dynamisch gro√ü */
        font-weight: 900;
        line-height: 1.2;
        text-shadow: 0 4px 10px rgba(0,0,0,0.8);
    }

    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:24px; height: 35vh; margin-top: auto; }
    .answer-btn{ background: #e0e0e0; color:#0b0b0b; padding:30px; font-size:1.8rem; font-weight:800; height: 100%; display:flex; align-items: center; gap:24px; border: 4px solid transparent; transition: transform 0.1s; }
    .answer-btn:hover { transform: translateY(-2px); background: #fff; }
    
    .results-split-view { display: grid; grid-template-columns: 4fr 3fr; gap: 40px; height: 100%; overflow: hidden; }
    .results-col { display: flex; flex-direction: column; gap: 16px; overflow: hidden; max-height: 100%; }
    .scroll-area { overflow-y: auto; padding-right: 8px; }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.95); display:flex; align-items:center; justify-content:center; z-index:9999; backdrop-filter: blur(5px); }
    .modal-card{ width:95%; max-width:600px; background:#000; border:3px solid var(--rtl-orange); padding:40px; color:var(--tile); box-shadow: 0 0 80px rgba(255,102,0,0.3); }
    
    .toggle-switch { position: relative; display: inline-block; width: 60px; height: 32px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: .2s; }
    input:checked + .toggle-slider { background-color: var(--rtl-orange); }
    
    .action-log-item { padding: 12px; background: rgba(255,255,255,0.03); border-left: 5px solid rgba(255,255,255,0.1); margin-bottom: 8px; font-size: 15px; font-weight: 600; }
    .action-log-item.boost { border-left-color: #ffd580; }
    .action-log-item.poison { border-left-color: #ff6b6b; }
    .action-log-item.shield { border-left-color: #8ec5ff; }
    .action-log-item.trade { border-left-color: #22C55E; }

    .item-btn { border: 1px solid rgba(255,255,255,0.2); padding: 10px; background: transparent; color: white; font-weight: 800; font-size: 14px; }
    .item-btn.active { background: var(--rtl-orange); border-color: var(--rtl-orange); color: #000; }
    .item-btn.item-disabled { opacity: 0.3; cursor: not-allowed; }

  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 2;
  const QUESTION_TIME = 40;
  const BASE_POINTS = 100;
  const CATEGORY_CHOOSER_BONUS = 1.2;
  const FINAL_QUESTIONS = 5;
  const FINAL_TIME = 60;
  const FINAL_POINTS = 200;

  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ Kategorien & Fragen ************/
  const CATEGORY_LIST = ["Geografie", "Wissenschaft", "Geschichte", "Kultur & Kunst", "Sport", "Technik & Digitalisierung"];
  
  const QUESTION_POOL = [
    { question: "Welches Land hat die l√§ngste K√ºstenlinie der Welt?", answers: ["USA","Kanada","Australien","Indonesien"], correct: 1, category: "Geografie" },
    { question: "Welche Stadt liegt am Bosporus?", answers: ["Belgrad","Istanbul","Athen","Sofia"], correct: 1, category: "Geografie" },
    { question: "Wie viele Chromosomen hat der Mensch normalerweise?", answers: ["42","44","46","48"], correct: 2, category: "Wissenschaft" },
    { question: "Welches Gas atmen wir haupts√§chlich ein?", answers: ["Sauerstoff","Stickstoff","Kohlendioxid","Helium"], correct: 1, category: "Wissenschaft" },
    { question: "Wer war der erste Kanzler der Bundesrepublik Deutschland?", answers: ["Brandt","Schmidt","Adenauer","Kohl"], correct: 2, category: "Geschichte" },
    { question: "In welchem Jahr begann der Zweite Weltkrieg?", answers: ["1938","1939","1940","1941"], correct: 1, category: "Geschichte" },
    { question: "Wer komponierte die 9. Sinfonie?", answers: ["Beethoven","Mozart","Bach","Haydn"], correct: 0, category: "Kultur & Kunst" },
    { question: "Welcher K√ºnstler schuf die 'Sternennacht'?", answers: ["Monet","Van Gogh","Gauguin","Da Vinci"], correct: 1, category: "Kultur & Kunst" },
    { question: "Wie viele Spieler hat eine Fu√üballmannschaft auf dem Feld?", answers: ["9","10","11","12"], correct: 2, category: "Sport" },
    { question: "Wer gewann die Fu√üball-WM 2014?", answers: ["Brasilien","Deutschland","Spanien","Argentinien"], correct: 1, category: "Sport" },
    { question: "Was bedeutet die Abk√ºrzung 'CPU'?", answers: ["Central Performance Unit","Central Processing Unit","Computer Personal Unit","Control Processing Unit"], correct: 1, category: "Technik & Digitalisierung" },
    { question: "Welche Firma entwickelte das erste iPhone?", answers: ["Samsung","Apple","Nokia","Motorola"], correct: 1, category: "Technik & Digitalisierung" },
  ];

  const FINAL_QUESTION_POOL = [
    { question: "In welchem Jahr wurde die Berliner Mauer errichtet?", answer: "1961" },
    { question: "Wie hei√üt der h√∂chste Berg Deutschlands?", answer: "Zugspitze" },
    { question: "Welches chemische Element hat das Symbol 'Au'?", answer: "Gold" },
    { question: "Wie viele Bundesl√§nder hat Deutschland?", answer: "16" },
    { question: "In welcher Stadt steht die Freiheitsstatue?", answer: "New York" },
    { question: "Welcher Planet ist der Sonne am n√§chsten?", answer: "Merkur" },
    { question: "Wie viele Tasten hat ein Standardklavier?", answer: "88" },
    { question: "Welches Jahr markiert den Beginn des Ersten Weltkriegs?", answer: "1914" },
  ];

  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }

  function getQuestionsForCategory(category, count, usedQuestions = []) {
    let pool = QUESTION_POOL.filter(q => q.category === category && !usedQuestions.includes(q.question));
    if (pool.length < count) {
      const fallbackPool = QUESTION_POOL.filter(q => !usedQuestions.includes(q.question));
      pool = fallbackPool.length > 0 ? fallbackPool : QUESTION_POOL.filter(q => q.category === category);
    }
    pool = shuffle(pool).slice(0, count);
    return pool.map((q, idx) => ({ 
      id: `${category}-${Date.now()}-${Math.random().toString(36).substr(2,5)}-${idx}`, 
      ...q 
    }));
  }

  const DEFAULT_ITEMS = { boost: 5, poison: 5, shield: 3 };

  function RTLLogo({ size = "md" }) {
    const sizeMap = { sm: 40, md: 60, lg: 80 };
    const height = sizeMap[size] || 60;
    return <img src="Logo.png" alt="Logo" style={{ height, width: "auto" }} />;
  }

  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=300&margin=1&dark=000000&light=ffffff`;
  }

  /****************************************
   * START SCREEN
   ****************************************/
  function StartScreen({ onCreate, onJoin }){
    const [name,setName] = useState('');
    const [code,setCode] = useState('');
    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div style={{maxWidth:760, width:'100%'}} className="card">
          <div style={{display:'flex', alignItems:'center', gap:12}}>
            <RTLLogo size="md" />
            <div style={{fontWeight:900, fontSize:24}}>AdAlliance Quiz</div>
          </div>
          <h1 style={{fontSize:32, fontWeight:900, marginTop:20, color:'var(--rtl-orange)'}}>Quiz Master</h1>
          <div style={{marginTop:30}}>
            <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} style={{fontSize:18}} />
            <div style={{display:'flex', gap:12}}>
              <button className="btn btn-host flex-1" onClick={()=>onCreate(name)} disabled={!name}>Host werden</button>
              <input className="p-2" placeholder="Code" value={code} onChange={e=>setCode(e.target.value.toUpperCase())} style={{width:'140px', textAlign:'center', fontSize:18, fontWeight:900}} />
              <button className="btn btn-join" onClick={()=>onJoin(name,code)} disabled={!name || !code}>Beitreten</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /****************************************
   * HOST SCREEN
   ****************************************/
  function HostScreen({ gameId, hostName }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [pauseModalOpen, setPauseModalOpen] = useState(false);
    const [finaleEnabled, setFinaleEnabled] = useState(true);
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => {
        const val = snap.val();
        setMeta(val);
        if (val && val.finaleEnabled !== undefined) setFinaleEnabled(val.finaleEnabled);
      });
      return ()=> { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    useEffect(()=>{
      if(!meta) { setTimeLeft(0); return; }
      if((meta.phase === 'question' && meta.questionStartTime) || (meta.phase === 'finalQuestion' && meta.finalQuestionStartTime)){
        const isFinal = meta.phase === 'finalQuestion';
        const start = isFinal ? meta.finalQuestionStartTime : meta.questionStartTime;
        const duration = isFinal ? FINAL_TIME : QUESTION_TIME;
        const tick = async ()=>{
          const elapsed = Math.floor((Date.now() - start)/1000);
          const rem = Math.max(0, duration - elapsed);
          setTimeLeft(rem);
          if(rem === 0) { isFinal ? await nextFinalQuestion() : await showResultsNow(); }
        };
        tick();
        clearInterval(timerRef.current);
        timerRef.current = setInterval(tick, 500);
        return ()=> clearInterval(timerRef.current);
      } else { setTimeLeft(0); }
    },[meta?.phase, meta?.questionStartTime, meta?.finalQuestionStartTime]);

    const handlePause = () => setPauseModalOpen(true);
    const resumeGame = () => setPauseModalOpen(false);

    const backToLobby = async ()=>{
      await db.ref(`games/${gameId}/meta`).set({ phase: 'lobby', finaleEnabled: meta?.finaleEnabled ?? true });
      await db.ref(`games/${gameId}/questions`).remove();
      await db.ref(`games/${gameId}/finalQuestions`).remove();
      setPauseModalOpen(false);
    };

    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g || g.meta.phase === 'results') return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if(!q) return;

        const playerObj = g.players || {};
        const updates = {};
        const categoryChooser = g.meta?.categoryChooserForRound || null;

        Object.entries(playerObj).forEach(([pid,p])=>{
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          let points = correct ? BASE_POINTS : 0;
          if(correct && p.activeEffects?.boost) points = Math.round(points * 1.5);
          if(correct && categoryChooser === pid) points = Math.round(points * CATEGORY_CHOOSER_BONUS);
          const poisonCount = Array.isArray(p.activeEffects?.poisonedBy) ? p.activeEffects.poisonedBy.length : 0;
          points -= (poisonCount * 20);
          if(points < 0) points = 0;
          updates[`games/${gameId}/players/${pid}/score`] = (p.score || 0) + points;
          updates[`games/${gameId}/players/${pid}/lastPoints`] = points;
        });
        await db.ref().update(updates);
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });
      }catch(e){ console.error(e); }
    };

    // --- STABILISIERTE NEXT ROUND LOGIK ---
    const startNextRound = async ()=>{
      if(!meta) return;
      const gameSnap = await db.ref(`games/${gameId}`).get();
      const g = gameSnap.val();
      if (!g) { alert("Datenfehler: Spiel nicht gefunden"); return; }
      
      const currentIndex = g.meta.questionIndex || 0;
      const currentQuestions = g.questions || [];
      const nextIndex = currentIndex + 1;
      
      // --- PHASE 1: Wir kommen von den Ergebnissen ---
      if(meta.phase === 'results'){
        
        // Pr√ºfe, ob wir am Ende einer Runde sind
        // Wir sind am Ende einer Runde, wenn die n√§chste Frage ein Vielfaches von QUESTIONS_PER_ROUND ist
        const isRoundEnd = (nextIndex % QUESTIONS_PER_ROUND) === 0;

        if (isRoundEnd) {
             // Wir sind am Ende einer Runde -> Gehe zum Zwischenstand (Round Summary)
             const finishedRound = Math.floor(currentIndex / QUESTIONS_PER_ROUND) + 1;
             
             // Check: War das die allerletzte Runde?
             if (finishedRound >= TOTAL_ROUNDS) {
                if(meta.finaleEnabled === false) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
                else await prepareFinale();
                return;
             }

             // Ermittle Verlierer f√ºr Kategorie-Wahl
             const pObj = g.players || {};
             const sorted = Object.entries(pObj).sort(([,a],[,b]) => (a.score||0) - (b.score||0));
             const minScore = sorted[0]?.[1].score || 0;
             const losers = sorted.filter(([,p]) => (p.score||0) === minScore).map(([id]) => id);
             const pickedLoser = losers[Math.floor(Math.random() * losers.length)];

             await db.ref(`games/${gameId}/meta`).update({
               phase: 'roundSummary',
               round: finishedRound + 1,
               categoryChooserCandidate: pickedLoser
             });
             return;

        } else {
            // Wir sind noch INNERHALB einer Runde (z.B. von Frage 1 zu Frage 2)
            // Hier ist der "Stuck Bug" passiert. Wir erzwingen jetzt das Weitermachen.
            await proceedToQuestion(nextIndex, g.meta.currentCategory, g.meta.categoryChooserForRound);
        }
      }
      
      // --- PHASE 2: Wir kommen vom Zwischenstand (Round Summary) ---
      else if(meta.phase === 'roundSummary'){
         const chosenCat = meta.nextCategory || null;
         const chooser = meta.categoryChooserForRound || null;
         
         // Fallback Kategorie
         let finalCat = chosenCat;
         if(!finalCat) {
            const used = meta.categoryState?.used || [];
            const avail = CATEGORY_LIST.filter(c => !used.includes(c));
            finalCat = avail.length > 0 ? avail[0] : CATEGORY_LIST[0];
         }

         // Neue Fragen generieren
         const newBlock = getQuestionsForCategory(finalCat, QUESTIONS_PER_ROUND, currentQuestions.map(q=>q.question));
         const newQuestions = [...currentQuestions, ...newBlock];
         
         await db.ref(`games/${gameId}/questions`).set(newQuestions);
         const used = [...(meta.categoryState?.used || []), finalCat];
         await db.ref(`games/${gameId}/meta/categoryState/used`).set(used);
         
         await db.ref(`games/${gameId}/meta/nextCategory`).remove();
         await db.ref(`games/${gameId}/meta/categoryChooserCandidate`).remove();

         // Sicherstellen, dass wir den korrekten Index nutzen (L√§nge der alten Liste)
         const safeStartIndex = currentQuestions.length; 
         await proceedToQuestion(safeStartIndex, finalCat, chooser);
      }
    };

    const proceedToQuestion = async (index, category, chooser) => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, boostTarget:null, shield:false, shieldTarget:null, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/hasTraded`] = false;
      });
      await db.ref().update(updates);

      await db.ref(`games/${gameId}/meta`).update({
          questionIndex: index,
          phase: 'question',
          questionStartTime: Date.now(),
          currentCategory: category,
          categoryChooserForRound: chooser,
          round: Math.floor(index / QUESTIONS_PER_ROUND) + 1
      });
    };

    const prepareFinale = async () => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const playersArr = Object.entries(pObj).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      if(playersArr.length < 2){ await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' }); return; }
      const top2 = playersArr.slice(0, 2).map(p => p.pid);
      await db.ref(`games/${gameId}/finalQuestions`).set(shuffle(FINAL_QUESTION_POOL).slice(0, FINAL_QUESTIONS));
      const updates = {};
      Object.keys(pObj).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/isFinalist`] = top2.includes(pid);
        updates[`games/${gameId}/players/${pid}/finalAnswers`] = {};
        updates[`games/${gameId}/players/${pid}/finalistReady`] = false;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({ phase: 'finalIntro', finalists: top2 });
    };

    const startFinalQuestion = async () => db.ref(`games/${gameId}/meta`).update({ phase: 'finalQuestion', finalQuestionIndex: 0, finalQuestionStartTime: Date.now() });
    const nextFinalQuestion = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const currentIndex = (snap.val()?.meta?.finalQuestionIndex || 0) + 1;
      if(currentIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finalReview', finalReviewIndex: 0 });
      else await db.ref(`games/${gameId}/meta`).update({ finalQuestionIndex: currentIndex, finalQuestionStartTime: Date.now() });
    };
    const judgeFinalAnswer = async (playerId, correct) => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = snap.val()?.meta?.finalReviewIndex || 0;
      const player = snap.val()?.players?.[playerId];
      if(!player) return;
      const points = correct ? FINAL_POINTS : 0;
      await db.ref(`games/${gameId}/players/${playerId}`).update({ score: (player.score || 0) + points, [`finalScores/${reviewIndex}`]: points });
    };
    const nextFinalReview = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = (snap.val()?.meta?.finalReviewIndex || 0) + 1;
      if(reviewIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
      else await db.ref(`games/${gameId}/meta`).update({ finalReviewIndex: reviewIndex });
    };

    const startGame = async ()=>{
      const categoriesForGame = shuffle(CATEGORY_LIST).slice(0, TOTAL_ROUNDS);
      const firstCat = categoriesForGame[0];
      const block = getQuestionsForCategory(firstCat, QUESTIONS_PER_ROUND, []);
      
      await db.ref(`games/${gameId}/questions`).set(block);
      await db.ref(`games/${gameId}/meta/categoryState`).set({ used: [firstCat], remaining: categoriesForGame.slice(1) });
      await db.ref(`games/${gameId}/meta`).set({ 
        phase: 'question', questionIndex: 0, round: 1, questionStartTime: Date.now(), 
        currentCategory: firstCat, categoryChooserForRound: null, finaleEnabled: finaleEnabled 
      });

      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/items`] = DEFAULT_ITEMS;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, boostTarget:null, shield:false, shieldTarget:null, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
        updates[`games/${gameId}/players/${pid}/hasTraded`] = false;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta/actions`).remove();
    };

    const toggleFinale = async () => {
      const newValue = !finaleEnabled;
      setFinaleEnabled(newValue);
      await db.ref(`games/${gameId}/meta/finaleEnabled`).set(newValue);
    };

    if(!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const isLobby = meta.phase === 'lobby';
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];
    const countdownClass = timeLeft <= 10 ? 'danger' : timeLeft <= 20 ? 'warning' : '';

    return (
      <div className="host-screen">
        {isLobby ? (
          <div style={{display:'flex', width:'100%'}}>
             <div style={{flex:1, display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', padding:40}}>
                <RTLLogo size="lg" />
                <h2 style={{fontSize:48, fontWeight:900, margin:'20px 0', color:'var(--tile)'}}>Willkommen</h2>
                <div style={{background:'rgba(255,255,255,0.1)', padding:20, border:'2px solid white', display:'flex', flexDirection:'column', alignItems:'center', gap:10}}>
                    <div style={{fontSize:16, color:'var(--muted)'}}>CODE ZUM BEITRETEN:</div>
                    <div style={{fontFamily:'monospace', fontSize:50, fontWeight:900, letterSpacing:4}}>{gameId}</div>
                </div>
                <div style={{marginTop:40, display:'flex', gap:20, alignItems:'center'}}>
                  <button className="btn btn-host" onClick={startGame} style={{fontSize:24, padding:'20px 40px'}}>Spiel starten ‚ñ∂</button>
                  <div style={{display:'flex', alignItems:'center', gap:10, padding:'15px', background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                    <span style={{fontSize:'16px', fontWeight:700}}>Finale?</span>
                    <label className="toggle-switch">
                      <input type="checkbox" checked={finaleEnabled} onChange={toggleFinale} />
                      <span className="toggle-slider"></span>
                    </label>
                  </div>
                </div>
             </div>
             <div className="host-side">
                <div style={{textAlign:'center', padding:20, background:'white', height: 300, display:'flex', alignItems:'center', justifyContent:'center'}}>
                  <img src={qrUrlForGame(gameId)} alt="QR Code" style={{maxWidth:'100%', maxHeight:'100%', objectFit:'contain', aspectRatio:'1/1'}} />
                </div>
                <h3 style={{fontSize:24, fontWeight:900, color:'var(--rtl-orange)', borderBottom:'2px solid var(--rtl-orange)', paddingBottom:10}}>Spieler ({playersArr.length})</h3>
                <div className="scroll-area" style={{flex:1}}>
                   {playersArr.map((p)=>(
                     <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:15, background:'rgba(255,255,255,0.05)', marginBottom:4, fontSize:18}}>
                        <strong>{p.name}</strong><span style={{color:'var(--rtl-green)'}}>‚úì</span>
                     </div>
                   ))}
                </div>
             </div>
          </div>
        ) : (
          <div className="host-main">
            {/* TOP BAR */}
            {meta.phase !== 'finalIntro' && meta.phase !== 'finished' && (
                <div className="game-top-bar">
                     <div style={{display:'flex', alignItems:'center', gap:20}}>
                        <div className={`countdown-badge ${countdownClass}`}>{timeLeft}</div>
                        <div>
                          <div style={{color:'var(--muted)', fontSize:'1rem', textTransform:'uppercase'}}>Runde {meta.round || 1} | Frage {(qIndex%QUESTIONS_PER_ROUND)+1}</div>
                          <div style={{fontWeight:900, fontSize:'1.8rem', color:'var(--rtl-orange)'}}>{meta.currentCategory || question?.category || 'Finale'}</div>
                        </div>
                     </div>
                     <div style={{display:'flex', alignItems:'center', gap:20}}>
                        {meta.phase === 'question' && <button className="btn btn-show-results" onClick={showResultsNow}>L√∂sung anzeigen ‚ñ∂</button>}
                        {meta.phase === 'results' && <button className="btn btn-host" onClick={startNextRound}>Weiter ‚ñ∂</button>}
                        {meta.phase === 'roundSummary' && <button className="btn btn-host" onClick={startNextRound}>N√§chste Runde ‚ñ∂</button>}
                        <button className="btn-pause-gold" onClick={handlePause} title="Spiel pausieren">II</button>
                     </div>
                </div>
            )}

            <div className="host-main-inner">
                {meta.phase === 'question' && question && (
                  <>
                    <div className="question-area">
                        <h2 className="question-text">{question.question}</h2>
                    </div>
                    <div className="answers-grid">
                      {question.answers.map((a,i)=>(
                        <div key={i} className="answer-btn">
                          <div style={{fontWeight:900, color:'var(--rtl-orange)', fontSize:'3rem'}}>{String.fromCharCode(65+i)}</div>
                          <div style={{fontSize:'2.2rem'}}>{a}</div>
                        </div>
                      ))}
                    </div>
                  </>
                )}

                {meta.phase === 'results' && question && (
                   <div className="results-split-view">
                      <div className="results-col">
                         <div style={{padding:30, background:'#fff', color:'#000', marginBottom:20}}>
                            <div style={{fontSize:16, textTransform:'uppercase', fontWeight:900, color:'var(--rtl-green)'}}>Richtige Antwort</div>
                            <div style={{fontSize:40, fontWeight:900}}>{question.answers[question.correct]}</div>
                         </div>
                         <div style={{display:'grid', gap:12, flex:1, overflow:'auto'}}>
                            {question.answers.map((a,i)=>{
                              const isCorrect = i === question.correct;
                              const voters = playersArr.filter(p => p.currentAnswer === i);
                              return (
                                <div key={i} style={{padding:20, border: isCorrect ? '5px solid var(--rtl-green)' : '1px solid rgba(255,255,255,0.1)', background: isCorrect ? 'rgba(34,197,94,0.15)' : 'rgba(255,255,255,0.02)'}}>
                                  <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                    <div style={{fontWeight:900, fontSize:22}}>{String.fromCharCode(65+i)}. {a}</div>
                                    {isCorrect && <div style={{fontSize:28}}>‚úÖ</div>}
                                  </div>
                                  <div style={{marginTop:8, fontSize:18, color:'var(--muted)'}}>
                                    {voters.length} Stimmen {voters.length>0 && `(${voters.map(p=>p.name).join(', ')})`}
                                  </div>
                                </div>
                              )
                            })}
                         </div>
                      </div>
                      <div className="results-col">
                         <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                           <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Aktionen</h3>
                           <div className="scroll-area" style={{flex:1}}>
                             {(() => {
                                const actions = (game.meta?.actions?.[qIndex] || []);
                                if(actions.length === 0) return <div style={{color:'var(--muted)', fontStyle:'italic'}}>Keine Aktionen.</div>;
                                return actions.map((act, idx) => {
                                   const from = game.players[act.from]?.name || '???';
                                   const to = game.players[act.to]?.name || '???';
                                   if(act.type === 'boost') return <div key={idx} className="action-log-item boost">üî• <b>{from}</b> boostet {act.target === act.from ? 'sich selbst' : to}</div>;
                                   if(act.type === 'poison') return <div key={idx} className="action-log-item poison">‚ò†Ô∏è <b>{from}</b> vergiftet {to} {act.blocked ? '(üõ° abgewehrt)' : ''}</div>;
                                   if(act.type === 'shield') return <div key={idx} className="action-log-item shield">üõ° <b>{from}</b> sch√ºtzt {act.target === act.from ? 'sich selbst' : to}</div>;
                                   if(act.type === 'trade') return <div key={idx} className="action-log-item trade">ü§ù <b>{from}</b> handelt mit {to}</div>;
                                });
                             })()}
                           </div>
                         </div>
                         <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                            <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Rangliste</h3>
                            <div className="scroll-area" style={{flex:1}}>
                              {playersArr.map((p,i)=>(
                                <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:'12px', background:i<3?'rgba(255,255,255,0.05)':'transparent', marginBottom:4}}>
                                  <div style={{display:'flex', gap:8}}>
                                    <span style={{fontWeight:700, fontSize:18}}>#{i+1} {p.name}</span>
                                    {meta.categoryChooserForRound === p.pid && <span style={{fontSize:12, background:'var(--rtl-purple)', padding:'2px 6px', alignSelf:'center'}}>W√ÑHLER (x1.2)</span>}
                                  </div>
                                  <div style={{fontWeight:900, color: p.lastPoints>0 ? 'var(--rtl-green)' : 'var(--tile)', fontSize:18}}>
                                    {p.score} <span style={{fontSize:14, opacity:0.7}}>(+{p.lastPoints})</span>
                                  </div>
                                </div>
                              ))}
                            </div>
                         </div>
                      </div>
                   </div>
                )}

                {meta.phase === 'roundSummary' && (
                   <div style={{width:'100%', height:'100%', display:'flex', flexDirection:'column'}}>
                      <h2 style={{textAlign:'center', fontSize:48, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20}}>Stand nach Runde {meta.round - 1}</h2>
                      <div style={{textAlign:'center', color:'var(--muted)', marginBottom:30, fontSize:20}}>
                        Der Spieler auf dem letzten Platz w√§hlt die n√§chste Kategorie.
                        {meta.categoryChooserCandidate && <div style={{color:'white', fontWeight:900, marginTop:10}}>W√ÑHLER: {game.players[meta.categoryChooserCandidate]?.name}</div>}
                      </div>
                      <div className="scroll-area" style={{flex:1, background:'rgba(255,255,255,0.02)', padding:40, border:'1px solid rgba(255,255,255,0.05)'}}>
                         {playersArr.map((p,i)=>(
                            <div key={p.pid} style={{
                               display:'flex', alignItems:'center', justifyContent:'space-between',
                               padding:25, marginBottom:10,
                               background: i===0 ? 'linear-gradient(90deg, rgba(255,215,0,0.2), rgba(0,0,0,0))' : 
                                           i===1 ? 'linear-gradient(90deg, rgba(192,192,192,0.2), rgba(0,0,0,0))' : 
                                           i===2 ? 'linear-gradient(90deg, rgba(205,127,50,0.2), rgba(0,0,0,0))' : 'rgba(255,255,255,0.02)',
                               borderLeft: i===0 ? '6px solid gold' : i===1 ? '6px solid silver' : i===2 ? '6px solid #cd7f32' : '6px solid transparent'
                            }}>
                               <div style={{display:'flex', alignItems:'center', gap:30}}>
                                  <div style={{fontSize:36, fontWeight:900, width:60}}>{i===0?'1.':i===1?'2.':i===2?'3.':`${i+1}.`}</div>
                                  <div style={{fontSize:28, fontWeight:700}}>{p.name}</div>
                                  {meta.categoryChooserCandidate === p.pid && <div style={{background:'var(--rtl-red)', padding:'6px 12px', fontWeight:900, fontSize:16}}>DARF W√ÑHLEN!</div>}
                               </div>
                               <div style={{display:'flex', alignItems:'center', gap:40}}>
                                  <div style={{fontSize:20, color:'var(--muted)', display:'flex', gap:20}}>
                                    <span>üî•{p.items?.boost||0}</span>
                                    <span>‚ò†Ô∏è{p.items?.poison||0}</span>
                                    <span>üõ°{p.items?.shield||0}</span>
                                  </div>
                                  <div style={{fontSize:36, fontWeight:900, color:'var(--rtl-green)'}}>{p.score}</div>
                               </div>
                            </div>
                         ))}
                      </div>
                   </div>
                )}

                {['finalIntro', 'finalQuestion', 'finalReview', 'finished'].includes(meta.phase) && (
                    <div style={{flex:1, display:'flex', justifyContent:'center', alignItems:'center', flexDirection:'column'}}>
                        {meta.phase === 'finalIntro' && <FinalIntroHostView game={game} meta={meta} onStart={startFinalQuestion} />}
                        {meta.phase === 'finalQuestion' && <FinalQuestionHostView game={game} meta={meta} timeLeft={timeLeft} onNext={nextFinalQuestion} />}
                        {meta.phase === 'finalReview' && <FinalReviewHostView game={game} meta={meta} onJudge={judgeFinalAnswer} onNext={nextFinalReview} />}
                        {meta.phase === 'finished' && (
                           <div style={{textAlign:'center'}}>
                              <h1 style={{fontSize:100, fontWeight:900, margin:0, color:'var(--rtl-orange)'}}>ENDE</h1>
                              <div style={{fontSize:40, marginTop:30}}>Gewinner: {playersArr[0]?.name}</div>
                              <div style={{fontSize:80, marginTop:10, color:'gold'}}>{playersArr[0]?.score} Pkt</div>
                              <button className="btn btn-host" style={{marginTop:60, fontSize:24, padding:'20px 50px'}} onClick={backToLobby}>Zur√ºck zur Lobby</button>
                           </div>
                        )}
                    </div>
                )}
            </div>
          </div>
        )}

        {pauseModalOpen && (
          <div className="modal-backdrop">
            <div className="modal-card" style={{textAlign:'center'}}>
              <h3 style={{fontWeight:900, fontSize:32, marginBottom:30, color:'var(--rtl-orange)'}}>PAUSE</h3>
              <div style={{display:'flex', flexDirection:'column', gap:20}}>
                <button className="btn btn-host" onClick={resumeGame} style={{fontSize:20, padding:'20px'}}>‚ñ∂ WEITER</button>
                <button className="btn" onClick={backToLobby} style={{fontSize:20, padding:'20px', background:'rgba(255,255,255,0.1)'}}>‚Ü© LOBBY / RESET</button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * FINAL COMPONENTS
   ****************************************/
  function FinalIntroHostView({ game, meta, onStart }){
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allReady = finalists.every(f => f.finalistReady === true);
    return (
      <div style={{textAlign:'center', width:'100%'}}>
        <h2 style={{fontSize:60, fontWeight:900, color:'var(--rtl-orange)', marginBottom:50}}>FINALE</h2>
        <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:60, width:'100%', maxWidth:1200, margin:'0 auto'}}>
          {finalists.map((f, idx) => (
            <div key={f.pid} style={{padding:50, background:'rgba(255,255,255,0.05)', border: f.finalistReady ? '6px solid var(--rtl-green)' : '6px solid var(--rtl-orange)'}}>
              <div style={{fontSize:100}}>{idx === 0 ? '1.' : '2.'}</div>
              <div style={{fontSize:50, fontWeight:900}}>{f.name}</div>
              <div style={{fontSize:40, color:'var(--muted)'}}>{f.score} Pkt</div>
              <div style={{marginTop:40, padding:20, background: f.finalistReady ? 'var(--rtl-green)' : 'rgba(255,255,255,0.1)', fontWeight:700, fontSize:24}}>
                {f.finalistReady ? 'BEREIT' : 'WARTEN...'}
              </div>
            </div>
          ))}
        </div>
        {allReady && <button className="btn btn-host" onClick={onStart} style={{marginTop:60, fontSize:32, padding:'30px 60px'}}>START ‚ñ∂</button>}
      </div>
    );
  }

  function FinalQuestionHostView({ game, meta, timeLeft, onNext }){
    const finalQIndex = meta.finalQuestionIndex || 0;
    const question = (game.finalQuestions || [])[finalQIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allAnswered = finalists.every(f => f.finalAnswers?.[finalQIndex]);
    return (
      <div style={{textAlign:'center', width:'100%', maxWidth:1400}}>
        <h2 style={{fontSize:50, fontWeight:900, lineHeight:1.3}}>{question?.question}</h2>
        <div style={{display:'flex', gap:40, marginTop:80}}>
          {finalists.map(f => (
             <div key={f.pid} style={{flex:1, padding:40, background:'rgba(255,255,255,0.05)', border: f.finalAnswers?.[finalQIndex] ? '5px solid var(--rtl-green)' : '2px solid rgba(255,255,255,0.1)'}}>
                <div style={{fontWeight:900, fontSize:36}}>{f.name}</div>
                <div style={{marginTop:20, fontSize:24, color: f.finalAnswers?.[finalQIndex] ? 'var(--rtl-green)' : 'var(--muted)'}}>
                   {f.finalAnswers?.[finalQIndex] ? '‚úì ANTWORT DA' : 'Tippt...'}
                </div>
             </div>
          ))}
        </div>
        {(timeLeft === 0 || allAnswered) && <button className="btn btn-host" onClick={onNext} style={{marginTop:60, fontSize:28, padding:'20px 40px'}}>{finalQIndex+1 >= FINAL_QUESTIONS ? 'ZUR AUSWERTUNG' : 'N√ÑCHSTE FRAGE'}</button>}
      </div>
    );
  }

  function FinalReviewHostView({ game, meta, onJudge, onNext }){
    const reviewIndex = meta.finalReviewIndex || 0;
    const question = (game.finalQuestions || [])[reviewIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const [judged, setJudged] = useState({});
    const handleJudge = async (pid, ok) => { await onJudge(pid, ok); setJudged(prev => ({...prev, [pid]: ok})); };
    return (
      <div className="results-split-view" style={{width:'100%'}}>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           <h3 style={{color:'var(--muted)', textTransform:'uppercase', fontWeight:900, fontSize:20}}>Frage {reviewIndex+1}</h3>
           <div style={{fontSize:40, fontWeight:900, marginBottom:40, lineHeight:1.2}}>{question?.question}</div>
           <div style={{padding:40, background:'#fff', color:'#000'}}>
              <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-green)'}}>L√ñSUNG</div>
              <div style={{fontSize:36, fontWeight:900}}>{question?.answer}</div>
           </div>
        </div>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           {finalists.map(f => (
              <div key={f.pid} style={{padding:30, background:'rgba(255,255,255,0.05)', marginBottom:20}}>
                 <div style={{display:'flex', justifyContent:'space-between', marginBottom:15}}>
                    <span style={{fontWeight:900, fontSize:24}}>{f.name}</span>
                    <span style={{color:'var(--muted)', fontSize:20}}>{f.score} Pkt</span>
                 </div>
                 <div style={{fontSize:28, padding:20, background:'rgba(0,0,0,0.5)', marginBottom:20, fontStyle:'italic'}}>"{f.finalAnswers?.[reviewIndex] || '---'}"</div>
                 {judged[f.pid] === undefined ? (
                    <div style={{display:'flex', gap:20}}>
                       <button className="btn" style={{flex:1, background:'var(--rtl-green)'}} onClick={()=>handleJudge(f.pid, true)}>‚úì KORREKT</button>
                       <button className="btn" style={{flex:1, background:'var(--rtl-red)'}} onClick={()=>handleJudge(f.pid, false)}>‚úó FALSCH</button>
                    </div>
                 ) : (
                    <div style={{textAlign:'center', fontWeight:900, color: judged[f.pid] ? 'var(--rtl-green)' : 'var(--rtl-red)', fontSize:20}}>{judged[f.pid] ? 'PUNKTE VERGEBEN' : 'ALS FALSCH GEWERTET'}</div>
                 )}
              </div>
           ))}
           {Object.keys(judged).length === finalists.length && <button className="btn btn-host" onClick={()=>{ setJudged({}); onNext(); }} style={{marginTop:30, fontSize:24, padding:'20px 40px'}}>WEITER ‚ñ∂</button>}
        </div>
      </div>
    );
  }

  /****************************************
   * PLAYER VIEW
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [poisonModalOpen, setPoisonModalOpen] = useState(false);
    const [poisonTargets, setPoisonTargets] = useState([]);
    const [boostModalOpen, setBoostModalOpen] = useState(false);
    const [shieldModalOpen, setShieldModalOpen] = useState(false);
    const [bonusCategoryModalOpen, setBonusCategoryModalOpen] = useState(false);
    const [finalAnswer, setFinalAnswer] = useState('');

    useEffect(() => { if(playerId && gameId) { sessionStorage.setItem(`quiz_pid_${gameId}`, playerId); } }, [playerId, gameId]);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); mRef.off(); pRef.off(); };
    },[gameId, playerId]);

    useEffect(()=>{
      if(!meta){ setTimeLeft(0); return; }
      if(meta.phase === 'question' && meta.questionStartTime){
        const tick = ()=>{ const elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000); setTimeLeft(Math.max(0, QUESTION_TIME - elapsed)); };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else if(meta.phase === 'finalQuestion' && meta.finalQuestionStartTime){
        const tick = ()=>{ const elapsed = Math.floor((Date.now() - meta.finalQuestionStartTime)/1000); setTimeLeft(Math.max(0, FINAL_TIME - elapsed)); };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else { setTimeLeft(0); }
    },[meta?.questionStartTime, meta?.finalQuestionStartTime, meta?.phase]);

    useEffect(() => {
        if(meta && meta.phase === 'roundSummary' && meta.categoryChooserCandidate === playerId) {
            setBonusCategoryModalOpen(true);
        } else {
            setBonusCategoryModalOpen(false);
        }
    }, [meta?.phase, meta?.categoryChooserCandidate, playerId]);

    const openBoostModal = () => { setPoisonTargets(Object.entries(game.players || {}).map(([pid,p]) => ({ pid, name: p.name }))); setBoostModalOpen(true); };
    const sendBoostTo = async (targetPid) => {
      setBoostModalOpen(false);
      if(!(player.items && player.items.boost > 0)) return;
      const updates = {};
      updates[`games/${gameId}/players/${playerId}/items/boost`] = (player.items.boost - 1);
      updates[`games/${gameId}/players/${targetPid}/activeEffects/boost`] = true;
      await db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).once('value', s => {
         const arr = s.val() || []; arr.push({ type:'boost', from: playerId, to: targetPid, target: targetPid });
         db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).set(arr);
      });
      await db.ref().update(updates);
    };
    const openPoisonModal = () => { setPoisonTargets(Object.entries(game.players || {}).filter(([pid]) => pid !== playerId).map(([pid,p]) => ({ pid, name: p.name }))); setPoisonModalOpen(true); };
    const sendPoisonTo = async (targetPid) => { 
        setPoisonModalOpen(false); 
        if(!(player.items && player.items.poison > 0)) return;
        await db.ref(`games/${gameId}/players/${playerId}/items/poison`).set(player.items.poison-1);
        const tSnap = await db.ref(`games/${gameId}/players/${targetPid}`).get();
        const tData = tSnap.val();
        const blocked = tData.activeEffects?.shield;
        if(!blocked){
             const prev = tData.activeEffects?.poisonedBy || [];
             await db.ref(`games/${gameId}/players/${targetPid}/activeEffects/poisonedBy`).set([...prev, playerId]);
        }
        await db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).once('value', s => {
             const arr = s.val() || []; arr.push({ type:'poison', from: playerId, to: targetPid, blocked: !!blocked });
             db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).set(arr);
        });
    };
    const openShieldModal = () => { setPoisonTargets(Object.entries(game.players || {}).map(([pid,p]) => ({ pid, name: p.name }))); setShieldModalOpen(true); };
    const sendShieldTo = async (targetPid) => {
        setShieldModalOpen(false);
        if(!(player.items && player.items.shield > 0)) return;
        await db.ref(`games/${gameId}/players/${playerId}/items/shield`).set(player.items.shield-1);
        await db.ref(`games/${gameId}/players/${targetPid}/activeEffects/shield`).set(true);
        await db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).once('value', s => {
             const arr = s.val() || []; arr.push({ type:'shield', from: playerId, to: targetPid, target: targetPid });
             db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).set(arr);
        });
    };
    const pickCategory = async (cat) => {
        await db.ref(`games/${gameId}/meta`).update({ nextCategory: cat, categoryChooserForRound: playerId });
        setBonusCategoryModalOpen(false);
    };

    if(!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    if(meta.phase === 'finalIntro') {
        if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale</h2><p>Du bist Zuschauer.</p></div></div>;
        return (
            <div className="min-h-screen p-4 flex items-center justify-center">
                <div className="card" style={{textAlign:'center', width:'100%'}}>
                    <h2 style={{fontSize:30, marginBottom:20}}>FINALE!</h2>
                    <p style={{marginBottom:30}}>Bist du bereit?</p>
                    {!player.finalistReady ? (
                        <button className="btn btn-host w-full" style={{padding:30, fontSize:24}} onClick={()=>db.ref(`games/${gameId}/players/${playerId}/finalistReady`).set(true)}>ICH BIN BEREIT</button>
                    ) : (
                        <div style={{color:'var(--rtl-green)', fontSize:20, fontWeight:900}}>WARTEN AUF GEGNER...</div>
                    )}
                </div>
            </div>
        );
    }
    if(meta.phase === 'finalQuestion'){
       const question = (game.finalQuestions||[])[meta.finalQuestionIndex||0];
       if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale l√§uft...</h2></div></div>;
       const hasAnswered = player.finalAnswers && player.finalAnswers[meta.finalQuestionIndex||0];
       return (
          <div className="min-h-screen p-4"><div className="card"><h2>Frage {meta.finalQuestionIndex+1}</h2><p>{question?.question}</p>
          {!hasAnswered ? <><input className="w-full p-3 mt-4" value={finalAnswer} onChange={e=>setFinalAnswer(e.target.value)}/><button className="btn btn-host w-full mt-2" onClick={()=>{db.ref(`games/${gameId}/players/${playerId}/finalAnswers/${meta.finalQuestionIndex}`).set(finalAnswer); setFinalAnswer('');}}>Senden</button></> : <p>Antwort gesendet.</p>}</div></div>
       );
    }

    if(meta.phase === 'question'){
       const question = (game.questions||[])[meta.questionIndex||0];
       const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
       return (
         <div className="min-h-screen p-4" style={{overflowY:'auto'}}>
           <div className="card">
             <div style={{display:'flex',justifyContent:'space-between'}}><span>Runde {meta.round}</span><span style={{fontWeight:900,color:'var(--rtl-orange)'}}>{timeLeft}s</span></div>
             <h3 style={{fontSize:20,fontWeight:900,marginTop:12}}>{question?.question}</h3>
             <div style={{display:'grid', gap:10, marginTop:20}}>
               {question?.answers.map((a,i)=>(
                 <button key={i} disabled={hasAnswered||timeLeft<=0} onClick={()=>db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i)} style={{padding:15,background:player.currentAnswer===i?'var(--rtl-purple)':'rgba(255,255,255,0.05)', textAlign:'left', fontSize:18}}>{a}</button>
               ))}
             </div>
             <div style={{marginTop:20, display:'grid', gridTemplateColumns:'1fr 1fr', gap:10}}>
                <button className={`item-btn ${player.items?.boost>0?'':'item-disabled'}`} onClick={openBoostModal}>üî• {player.items?.boost}</button>
                <button className={`item-btn ${player.items?.poison>0?'':'item-disabled'}`} onClick={openPoisonModal}>‚ò†Ô∏è {player.items?.poison}</button>
                <button className={`item-btn ${player.items?.shield>0?'':'item-disabled'}`} style={{gridColumn:'span 2'}} onClick={openShieldModal}>üõ° {player.items?.shield}</button>
             </div>
           </div>
           {(boostModalOpen||poisonModalOpen||shieldModalOpen) && (
               <div className="modal-backdrop">
                   <div className="modal-card">
                       <h3>Ziel w√§hlen</h3>
                       <div style={{display:'flex',flexDirection:'column',gap:10}}>
                         {poisonTargets.map(t=>(
                            <button key={t.pid} className="btn" onClick={()=>{
                                if(boostModalOpen) sendBoostTo(t.pid);
                                if(poisonModalOpen) sendPoisonTo(t.pid);
                                if(shieldModalOpen) sendShieldTo(t.pid);
                            }}>{t.name}</button>
                         ))}
                         <button className="btn" style={{background:'red'}} onClick={()=>{setBoostModalOpen(false);setPoisonModalOpen(false);setShieldModalOpen(false)}}>Abbrechen</button>
                       </div>
                   </div>
               </div>
           )}
         </div>
       );
    }
    
    if(meta.phase === 'roundSummary' && bonusCategoryModalOpen) {
        const used = meta.categoryState?.used || [];
        const available = CATEGORY_LIST.filter(c => !used.includes(c));
        const displayCats = available.length > 0 ? available : CATEGORY_LIST;
        return (
            <div className="modal-backdrop">
                <div className="modal-card">
                    <h3 style={{textAlign:'center', marginBottom:20, fontSize:20, fontWeight:900}}>DU W√ÑHLST DIE KATEGORIE!</h3>
                    <p style={{textAlign:'center', marginBottom:20, color:'var(--muted)'}}>Du erh√§ltst in der n√§chsten Runde <b>x1.2 Punkte</b> auf richtige Antworten.</p>
                    <div style={{display:'flex', flexDirection:'column', gap:10}}>
                        {displayCats.slice(0, 3).map(c => (<button key={c} className="btn btn-host" onClick={()=>pickCategory(c)}>{c}</button>))}
                        <button className="btn" onClick={()=>pickCategory(displayCats[0])}>ZUFALL</button>
                    </div>
                </div>
            </div>
        );
    }

    if(meta.phase === 'results') return <div className="min-h-screen flex items-center justify-center p-4"><div className="card" style={{textAlign:'center'}}><h2>{player.currentAnswer===((game.questions||[])[meta.questionIndex||0]).correct ? 'Richtig!' : 'Falsch'}</h2><p>Punkte: {player.score}</p></div></div>;
    return <div className="min-h-screen flex items-center justify-center"><div>Warte auf Host...</div></div>;
  }

  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');
    const handleJoin = async ()=>{
      if(!name) return;
      const snap = await db.ref(`games/${joinGameId}`).get();
      if(!snap.exists()) return alert('Code falsch');
      const pid = makePlayerId();
      await db.ref(`games/${joinGameId}/players/${pid}`).set({ name, score:0, items:DEFAULT_ITEMS });
      onJoined(joinGameId, pid, name);
    };
    return <div className="min-h-screen flex items-center justify-center"><div className="card"><input value={name} onChange={e=>setName(e.target.value)} placeholder="Name" className="mb-3 w-full"/><button className="btn btn-host w-full" onClick={handleJoin}>Beitreten</button></div></div>;
  }

  /****************************************
   * MAIN APP
   ****************************************/
  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');
    const [playerName,setPlayerName] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ 
        const savedPid = sessionStorage.getItem(`quiz_pid_${joinCode}`);
        if(savedPid) {
          db.ref(`games/${joinCode}/players/${savedPid}`).once('value', snap => {
            if(snap.exists()) { setGameId(joinCode); setPlayerId(savedPid); setPlayerName(snap.val().name); setMode('playerGame'); }
            else { setMode('playerJoin'); setGameId(joinCode); }
          });
        } else { setMode('playerJoin'); setGameId(joinCode); }
      }
    },[]);

    const handleCreate = async (name)=>{ const gid = randomGameID(); setGameId(gid); await db.ref(`games/${gid}/meta`).set({ phase: 'lobby', finaleEnabled: true }); setMode('hostLobby'); };
    
    const handleJoin = async (name, code)=>{
        try {
            const snap = await db.ref(`games/${code}`).get();
            if(!snap.exists()) { alert('Spiel nicht gefunden!'); return; }
            const pid = makePlayerId();
            await db.ref(`games/${code}/players/${pid}`).set({ name, score: 0, items: DEFAULT_ITEMS });
            sessionStorage.setItem(`quiz_pid_${code}`, pid);
            setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame');
        } catch(e) { console.error(e); alert('Fehler beim Beitreten'); }
    };
    
    const handlePlayerJoined = (code,pid,name) => { sessionStorage.setItem(`quiz_pid_${code}`, pid); setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} hostName={playerName} />}
        {mode === 'playerGame' && <PlayerView gameId={gameId} playerId={playerId} />}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>







