<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Item System V9</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    :root{
      --rtl-orange:#FF6600;
      --rtl-purple:#7B2CBF;
      --bg:#0b0b0b;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
    }
    
    * { border-radius: 0px !important; }
    button, div, span, input, img { border-radius: 0px !important; }

    html,body,#root{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; overflow: hidden;}
    body{ background:linear-gradient(180deg,var(--bg), #090909); color:var(--tile); }
    
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: var(--rtl-orange); }
    ::-webkit-scrollbar-thumb:hover { background: #ff8533; }

    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 12px; font-weight: 600; }
    
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight:900; padding:14px 28px; cursor:pointer; border:none; background:rgba(255,255,255,0.1); color:var(--tile); font-size:18px; transition: background 0.2s; text-transform: uppercase; letter-spacing: 1px; border: 1px solid rgba(255,255,255,0.1); }
    .btn:hover { background:rgba(255,255,255,0.25); }
    .btn:active { transform: translateY(2px); }

    .btn-host{ background:var(--rtl-orange); color:white; border: 1px solid var(--rtl-orange); }
    .btn-host:hover { background: #ff7b24; }
    
    .btn-join{ background:var(--rtl-purple); color:white; border: 1px solid var(--rtl-purple); }
    
    .btn-pause-gold {
      background: #FFD700;
      color: #000;
      border: 2px solid #fff;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      font-weight: 900;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 50;
    }
    .btn-pause-gold:hover { background: #ffeb3b; transform: scale(1.05); }

    .btn-show-results{
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: var(--tile);
    }
    .btn-show-results:hover { background: rgba(255,255,255,0.3); }

    .card{ padding:30px; background: #111; border:1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    
    .host-screen{ display:flex; width: 100%; height:100vh; overflow:hidden; position: relative; background: var(--bg); }
    .host-main{ flex:1; display:flex; flex-direction:column; height: 100%; position: relative; }
    
    .host-main-inner {
        padding: 40px;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at center, #1a1a1a 0%, #000000 120%);
    }

    .game-top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 40px;
        background: #000;
        border-bottom: 2px solid rgba(255,255,255,0.08);
        height: 130px;
    }

    .countdown-badge{ width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:2.8rem; font-weight:900; color:var(--tile); border:4px solid rgba(255,255,255,0.15); background:#000; }
    .countdown-badge.warning{ border-color:var(--rtl-orange); color:var(--rtl-orange); }
    .countdown-badge.danger{ border-color:var(--rtl-orange); color:var(--rtl-orange); background: rgba(255,102,0,0.1); }
    
    .question-area { 
        flex-grow: 1; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px 60px; 
        text-align: center;
    }
    .question-text {
        font-size: 6vh; 
        font-weight: 900;
        line-height: 1.2;
        text-shadow: 0 4px 10px rgba(0,0,0,0.8);
    }

    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:24px; height: 35vh; margin-top: auto; }
    .answer-btn{ background: #e0e0e0; color:#0b0b0b; padding:30px; font-size:1.8rem; font-weight:800; height: 100%; display:flex; align-items: center; gap:24px; border: 4px solid transparent; transition: transform 0.1s; }
    .answer-btn:hover { transform: translateY(-2px); background: #fff; }
    
    .results-split-view { display: grid; grid-template-columns: 4fr 3fr; gap: 40px; height: 100%; overflow: hidden; }
    .results-col { display: flex; flex-direction: column; gap: 16px; overflow: hidden; max-height: 100%; }
    .scroll-area { overflow-y: auto; padding-right: 8px; }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.95); display:flex; align-items:center; justify-content:center; z-index:9999; backdrop-filter: blur(5px); }
    .modal-card{ width:95%; max-width:600px; background:#000; border:3px solid var(--rtl-orange); padding:40px; color:var(--tile); box-shadow: 0 0 80px rgba(255,102,0,0.3); }
    
    .toggle-switch { position: relative; display: inline-block; width: 60px; height: 32px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: .2s; }
    input:checked + .toggle-slider { background-color: var(--rtl-orange); }
    
    .action-log-item { padding: 12px; background: rgba(255,255,255,0.03); border-left: 5px solid rgba(255,255,255,0.1); margin-bottom: 8px; font-size: 15px; font-weight: 600; }
    .action-log-item.boost { border-left-color: var(--rtl-orange); }
    .action-log-item.poison { border-left-color: var(--rtl-orange); }
    .action-log-item.shield { border-left-color: var(--rtl-purple); }
    .action-log-item.trade { border-left-color: var(--rtl-orange); }
    .action-log-item.karma { border-left-color: #ffffff; background: rgba(255,255,255,0.1); }

    /* NEW: Item Slot Styling */
    .item-slot {
      width: 80px;
      height: 80px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .item-slot:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
    .item-slot.empty { opacity: 0.3; cursor: default; }
    .item-slot.active { border-color: var(--rtl-orange); box-shadow: 0 0 20px rgba(255,102,0,0.5); }
    
    .rarity-common { border-color: #888; }
    .rarity-uncommon { border-color: #4CAF50; }
    .rarity-rare { border-color: #2196F3; }
    .rarity-legendary { border-color: #FFD700; box-shadow: 0 0 30px rgba(255,215,0,0.4); }

    .lobby-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 15px;
        padding: 20px;
    }
    .lobby-player-chip {
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 15px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 20px;
        font-weight: 700;
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    .podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 40px; height: 50vh; margin-top: 50px; }
    .podium-place { display: flex; flex-direction: column; align-items: center; text-align: center; position: relative; }
    .podium-bar { width: 180px; background: rgba(255,255,255,0.1); display: flex; align-items: flex-end; justify-content: center; padding-bottom: 20px; font-size: 80px; font-weight: 900; color: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.2); position: relative; overflow: hidden;}
    
    .podium-1 .podium-bar { height: 350px; background: linear-gradient(180deg, #FFD700 0%, #B8860B 100%); border-color: #FFD700; color: rgba(255,255,255,0.5); box-shadow: 0 0 100px rgba(255, 215, 0, 0.4); }
    .podium-2 .podium-bar { height: 250px; background: linear-gradient(180deg, #C0C0C0 0%, #808080 100%); border-color: #C0C0C0; color: rgba(255,255,255,0.5); }
    .podium-3 .podium-bar { height: 180px; background: linear-gradient(180deg, #CD7F32 0%, #8B4513 100%); border-color: #CD7F32; color: rgba(255,255,255,0.5); }

    .winner-name { font-size: 32px; fontWeight: 900; margin-bottom: 15px; text-shadow: 0 2px 10px rgba(0,0,0,0.8); }
    .winner-score { font-size: 24px; color: var(--muted); margin-bottom: 5px; }

    .confetti { position: absolute; width: 10px; height: 10px; background: #f00; animation: fall 3s linear infinite; z-index: 0; }
    @keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1;} 100% { transform: translateY(110vh) rotate(720deg); opacity: 0; } }
    
    @keyframes revealPulse { 0% { box-shadow: 0 0 0 rgba(255,255,255,0); } 50% { box-shadow: 0 0 30px rgba(255,255,255,0.3); } 100% { box-shadow: 0 0 0 rgba(255,255,255,0); } }
    .reveal-correct { 
        animation: revealPulse 2s infinite; 
        background: #fff !important; 
        color: #000 !important; 
        border-color: #fff !important; 
    }

    .frozen-overlay {
      position: absolute;
      inset: 0;
      background: rgba(100, 150, 255, 0.3);
      backdrop-filter: blur(3px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: 900;
      color: white;
      text-shadow: 0 0 20px rgba(0,0,0,0.8);
    }

    /* Item Box Roulette Animation */
    .item-roulette-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      animation: fadeIn 0.3s ease-out;
    }

    .item-box-container {
      position: relative;
      width: 400px;
      height: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    .item-box-display {
      width: 200px;
      height: 200px;
      border: 6px solid var(--rtl-orange);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 100px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 60px rgba(255, 102, 0, 0.6);
    }

    .item-box-display::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(255,102,0,0.3) 50%, transparent 70%);
      animation: shine 2s linear infinite;
    }

    @keyframes shine {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .item-roulette-strip {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
      animation: rouletteSpin 0.1s linear infinite;
    }

    @keyframes rouletteSpin {
      0% { transform: translateX(-50%) translateY(0); }
      100% { transform: translateX(-50%) translateY(-110px); }
    }

    .item-roulette-strip.slowing {
      animation: rouletteSlowSpin 0.2s linear infinite;
    }

    @keyframes rouletteSlowSpin {
      0% { transform: translateX(-50%) translateY(0); }
      100% { transform: translateX(-50%) translateY(-110px); }
    }

    .item-roulette-strip.stopping {
      animation: rouletteStopSpin 0.4s ease-out forwards;
    }

    @keyframes rouletteStopSpin {
      0% { transform: translateX(-50%) translateY(0); }
      100% { transform: translateX(-50%) translateY(-55px); }
    }

    .roulette-item {
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.2);
    }

    .roulette-item.mystery {
      font-size: 70px;
      color: var(--rtl-orange);
    }

    .item-box-text {
      font-size: 28px;
      font-weight: 900;
      color: var(--rtl-orange);
      text-transform: uppercase;
      letter-spacing: 2px;
      animation: pulse 1s ease-in-out infinite;
    }

    .item-revealed {
      animation: itemPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes itemPop {
      0% { transform: scale(0) rotate(0deg); }
      50% { transform: scale(1.3) rotate(180deg); }
      100% { transform: scale(1) rotate(360deg); }
    }

    .item-box-info {
      text-align: center;
      margin-top: 20px;
    }

    .item-box-info h3 {
      font-size: 32px;
      font-weight: 900;
      color: white;
      margin-bottom: 10px;
    }

    .item-box-info .rarity-badge {
      display: inline-block;
      padding: 8px 20px;
      font-size: 16px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 15px;
    }

    .item-box-info .rarity-badge.common { background: #888; color: white; }
    .item-box-info .rarity-badge.uncommon { background: #4CAF50; color: white; }
    .item-box-info .rarity-badge.rare { background: #2196F3; color: white; }
    .item-box-info .rarity-badge.legendary { background: linear-gradient(45deg, #FFD700, #FFA500); color: #000; }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.05); }
    }

  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 2;
  const QUESTION_TIME = 60; // CHANGED: 60 seconds
  
  const ROUND_POINTS = { 1: 100, 2: 200, 3: 400, 4: 800 };
  
  const FINAL_QUESTIONS = 5;
  const FINAL_TIME = 60;
  const FINAL_ROUND_POINTS = [500, 750, 1000, 1500, 2000];

  /************ NEW: ITEM SYSTEM ************/
  const ITEM_SLOTS = 2; // Each player has 2 slots

  const ITEM_TYPES = {
    // OFFENSIVE
    GIFTPFEIL: { id: 'giftpfeil', name: 'Giftpfeil', icon: '‚ò†Ô∏è', rarity: 'common', effect: 'poison', needsTarget: true, description: 'Reduziert die Punkte eines Gegners um 25%' },
    FREEZE: { id: 'freeze', name: 'Eisschock', icon: '‚ùÑÔ∏è', rarity: 'uncommon', effect: 'freeze', needsTarget: true, description: 'Friert einen Gegner f√ºr 8 Sekunden ein' },
    ZEITSCHNAPPER: { id: 'zeitschnapper', name: 'Zeitschnapper', icon: '‚è±Ô∏è', rarity: 'rare', effect: 'time_reduce', needsTarget: true, description: 'Halbiert die verbleibende Zeit eines Gegners' },
    
    // DEFENSIVE
    SCHILD: { id: 'schild', name: 'Schild', icon: 'üõ°Ô∏è', rarity: 'uncommon', effect: 'shield', needsTarget: false, description: 'Sch√ºtzt dich vor allen Angriffen und reflektiert sie' },
    SPIEGELGLAS: { id: 'spiegelglas', name: 'Spiegelglas', icon: 'üîÆ', rarity: 'rare', effect: 'mirror', needsTarget: false, description: 'Zeigt die meistgew√§hlte Antwort' },
    
    // BOOST
    TURBO: { id: 'turbo', name: 'Turbo-Boost', icon: 'üî•', rarity: 'common', effect: 'boost', needsTarget: false, description: 'Erh√∂ht deine Punkte bei richtiger Antwort um 50%' },
    MAGNET: { id: 'magnet', name: 'Magnet', icon: 'üß≤', rarity: 'uncommon', effect: 'magnet', needsTarget: false, description: 'Bonus wenn andere richtig: +15% pro Spieler' },
    ZAPFER: { id: 'zapfer', name: 'Frage-Zapfer', icon: 'üí°', rarity: 'rare', effect: '5050', needsTarget: false, description: 'Eliminiert 2 falsche Antworten (50/50)' },
    
    // CHAOS
    PLATZTAUSCHER: { id: 'platztauscher', name: 'Platztauscher', icon: 'üîÑ', rarity: 'legendary', effect: 'swap_points', needsTarget: false, description: 'Tauscht deine Punkte mit einem zuf√§lligen Spieler' },
    SCANNER: { id: 'scanner', name: 'Antwort-Scanner', icon: 'üëÅÔ∏è', rarity: 'rare', effect: 'scanner', needsTarget: true, description: 'Zeigt dir die Antwort eines anderen Spielers' }
  };

  // Rarity weights for item distribution (catch-up mechanic)
  const RARITY_WEIGHTS = {
    top: { common: 65, uncommon: 25, rare: 8, legendary: 2 },
    mid: { common: 45, uncommon: 35, rare: 15, legendary: 5 },
    low: { common: 25, uncommon: 30, rare: 30, legendary: 15 }
  };

  function getRandomItem(playerPosition) {
    const weights = RARITY_WEIGHTS[playerPosition] || RARITY_WEIGHTS.mid;
    const rarityRoll = Math.random() * 100;
    
    let rarity = 'common';
    let cumulative = 0;
    for (const [r, weight] of Object.entries(weights)) {
      cumulative += weight;
      if (rarityRoll <= cumulative) {
        rarity = r;
        break;
      }
    }
    
    const itemsOfRarity = Object.values(ITEM_TYPES).filter(item => item.rarity === rarity);
    return itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
  }

  function getPlayerPosition(playerScore, allScores) {
    const sorted = allScores.sort((a, b) => b - a);
    const third = Math.ceil(sorted.length / 3);
    const playerRank = sorted.indexOf(playerScore);
    
    if (playerRank < third) return 'top';
    if (playerRank < third * 2) return 'mid';
    return 'low';
  }

  /************ Firebase Setup ************/
  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ Question Pool ************/
  const CATEGORY_LIST = ["Geografie", "Wissenschaft", "Geschichte", "Kultur & Kunst", "Sport", "Technik & Digitalisierung"];
  
  const QUESTION_POOL = [
    { question: "Welches Land hat die l√§ngste K√ºstenlinie der Welt?", answers: ["USA","Kanada","Australien","Indonesien"], correct: 1, category: "Geografie" },
    { question: "Welche Stadt liegt am Bosporus?", answers: ["Belgrad","Istanbul","Athen","Sofia"], correct: 1, category: "Geografie" },
    { question: "Wie viele Chromosomen hat der Mensch normalerweise?", answers: ["42","44","46","48"], correct: 2, category: "Wissenschaft" },
    { question: "Welches Gas atmen wir haupts√§chlich ein?", answers: ["Sauerstoff","Stickstoff","Kohlendioxid","Helium"], correct: 1, category: "Wissenschaft" },
    { question: "Wer war der erste Kanzler der Bundesrepublik Deutschland?", answers: ["Brandt","Schmidt","Adenauer","Kohl"], correct: 2, category: "Geschichte" },
    { question: "In welchem Jahr begann der Zweite Weltkrieg?", answers: ["1938","1939","1940","1941"], correct: 1, category: "Geschichte" },
    { question: "Wer komponierte die 9. Sinfonie?", answers: ["Beethoven","Mozart","Bach","Haydn"], correct: 0, category: "Kultur & Kunst" },
    { question: "Welcher K√ºnstler schuf die 'Sternennacht'?", answers: ["Monet","Van Gogh","Gauguin","Da Vinci"], correct: 1, category: "Kultur & Kunst" },
    { question: "Wie viele Spieler hat eine Fu√üballmannschaft auf dem Feld?", answers: ["9","10","11","12"], correct: 2, category: "Sport" },
    { question: "Wer gewann die Fu√üball-WM 2014?", answers: ["Brasilien","Deutschland","Spanien","Argentinien"], correct: 1, category: "Sport" },
    { question: "Was bedeutet die Abk√ºrzung 'CPU'?", answers: ["Central Performance Unit","Central Processing Unit","Computer Personal Unit","Control Processing Unit"], correct: 1, category: "Technik & Digitalisierung" },
    { question: "Welche Firma entwickelte das erste iPhone?", answers: ["Samsung","Apple","Nokia","Motorola"], correct: 1, category: "Technik & Digitalisierung" },
  ];

  const FINAL_QUESTION_POOL = [
    { question: "In welchem Jahr wurde die Berliner Mauer errichtet?", answer: "1961" },
    { question: "Wie hei√üt der h√∂chste Berg Deutschlands?", answer: "Zugspitze" },
    { question: "Welches chemische Element hat das Symbol 'Au'?", answer: "Gold" },
    { question: "Wie viele Bundesl√§nder hat Deutschland?", answer: "16" },
    { question: "In welcher Stadt steht die Freiheitsstatue?", answer: "New York" },
    { question: "Welcher Planet ist der Sonne am n√§chsten?", answer: "Merkur" },
    { question: "Wie viele Tasten hat ein Standardklavier?", answer: "88" },
    { question: "Welches Jahr markiert den Beginn des Ersten Weltkriegs?", answer: "1914" },
  ];

  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[i],a[j]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }

  function getQuestionsForCategory(category, count, usedQuestions = []) {
    let pool = QUESTION_POOL.filter(q => q.category === category && !usedQuestions.includes(q.question));
    if (pool.length < count) {
      const fallbackPool = QUESTION_POOL.filter(q => !usedQuestions.includes(q.question));
      pool = fallbackPool.length > 0 ? fallbackPool : QUESTION_POOL.filter(q => q.category === category);
    }
    pool = shuffle(pool).slice(0, count);
    return pool.map((q, idx) => ({ 
      id: `${category}-${Date.now()}-${Math.random().toString(36).substr(2,5)}-${idx}`, 
      ...q 
    }));
  }

  function RTLLogo({ size = "md" }) {
    const sizeMap = { sm: 40, md: 60, lg: 80 };
    const height = sizeMap[size] || 60;
    return <img src="Logo.png" alt="Logo" style={{ height, width: "auto" }} />; 
  }

  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=500&margin=1&dark=000000&light=ffffff`;
  }

  function ConfettiRain() {
     const particles = Array.from({length: 50});
     return (
        <div style={{position:'fixed', inset:0, pointerEvents:'none', overflow:'hidden', zIndex:0}}>
           {particles.map((_, i) => (
              <div key={i} className="confetti" style={{
                 left: Math.random() * 100 + 'vw',
                 animationDelay: Math.random() * 3 + 's',
                 backgroundColor: ['#FF6600', '#7B2CBF', '#FFF'][Math.floor(Math.random()*3)]
              }} />
           ))}
        </div>
     )
  }

  /****************************************
   * START SCREEN
   ****************************************/
  function StartScreen({ onCreate, onJoin }){
    const [name,setName] = useState('');
    const [code,setCode] = useState('');
    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div style={{maxWidth:760, width:'100%'}} className="card">
          <div style={{display:'flex', alignItems:'center', gap:12}}>
            <RTLLogo size="md" />
            <div style={{fontWeight:900, fontSize:24}}>AdAlliance Quiz</div>
          </div>
          <h1 style={{fontSize:32, fontWeight:900, marginTop:20, color:'var(--rtl-orange)'}}>Quiz Master</h1>
          <div style={{marginTop:30}}>
            <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} style={{fontSize:18}} />
            <div style={{display:'flex', gap:12}}>
              <button className="btn btn-host flex-1" onClick={()=>onCreate(name)} disabled={!name}>Host werden</button>
              <input className="p-2" placeholder="Code" value={code} onChange={e=>setCode(e.target.value.toUpperCase())} style={{width:'140px', textAlign:'center', fontSize:18, fontWeight:900}} />
              <button className="btn btn-join" onClick={()=>onJoin(name,code)} disabled={!name || !code}>Beitreten</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /****************************************
   * HOST SCREEN
   ****************************************/
  function HostScreen({ gameId, hostName }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [pauseModalOpen, setPauseModalOpen] = useState(false);
    const [finaleEnabled, setFinaleEnabled] = useState(true);
    const [revealAnswer, setRevealAnswer] = useState(false);
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => {
        const val = snap.val();
        setMeta(val);
        if (val && val.finaleEnabled !== undefined) setFinaleEnabled(val.finaleEnabled);
      });
      return ()=> { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    useEffect(()=>{
      if(!meta) { setTimeLeft(0); return; }
      if((meta.phase === 'question' && meta.questionStartTime) || (meta.phase === 'finalQuestion' && meta.finalQuestionStartTime)){
        const isFinal = meta.phase === 'finalQuestion';
        const start = isFinal ? meta.finalQuestionStartTime : meta.questionStartTime;
        const duration = isFinal ? FINAL_TIME : QUESTION_TIME;
        const tick = async ()=>{
          const elapsed = Math.floor((Date.now() - start)/1000);
          const rem = Math.max(0, duration - elapsed);
          setTimeLeft(rem);
          if(rem === 0) { isFinal ? await nextFinalQuestion() : await showResultsNow(); }
        };
        tick();
        clearInterval(timerRef.current);
        timerRef.current = setInterval(tick, 500);
        return ()=> clearInterval(timerRef.current);
      } else { setTimeLeft(0); }
    },[meta?.phase, meta?.questionStartTime, meta?.finalQuestionStartTime]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setRevealAnswer(false);
            const t = setTimeout(() => setRevealAnswer(true), 3000); 
            return () => clearTimeout(t);
        } else {
            setRevealAnswer(false);
        }
    }, [meta?.phase]);

    const handlePause = () => setPauseModalOpen(true);
    const resumeGame = () => setPauseModalOpen(false);

    const backToLobby = async ()=>{
      await db.ref(`games/${gameId}/meta`).set({ phase: 'lobby', finaleEnabled: meta?.finaleEnabled ?? true });
      await db.ref(`games/${gameId}/questions`).remove();
      await db.ref(`games/${gameId}/finalQuestions`).remove();
      setPauseModalOpen(false);
    };

    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g || g.meta.phase === 'results') return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if(!q) return;

        const playerObj = g.players || {};
        const updates = {};
        const currentRound = g.meta.round || 1;
        const basePoints = ROUND_POINTS[currentRound] || 100;
        
        // Calculate who answered what
        const answerCounts = {};
        Object.entries(playerObj).forEach(([pid, p]) => {
          const ans = p.currentAnswer;
          if (typeof ans === 'number') {
            answerCounts[ans] = (answerCounts[ans] || 0) + 1;
          }
        });

        Object.entries(playerObj).forEach(([pid,p])=>{
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          
          let points = correct ? basePoints : 0;
          let currentTotal = p.score || 0;
          let penalty = 0;
          
          // Apply active effects
          const effects = p.activeEffects || {};
          
          // Turbo Boost
          if(correct && effects.turbo) points = Math.round(points * 1.5);
          
          // Magnet - bonus if others also answered correctly (15% per other correct player)
          if(correct && effects.magnet) {
            const othersCorrect = Object.entries(playerObj).filter(([id, pl]) => 
              id !== pid && pl.currentAnswer === q.correct
            ).length;
            if(othersCorrect > 0) {
              points = Math.round(points * (1 + othersCorrect * 0.15));
            }
          }
          
          // Giftpfeil (Poison) - 25% reduction
          if(correct && effects.poisoned) {
            points = Math.round(points * 0.75);
          }

          const finalPoints = points - penalty;
          
          updates[`games/${gameId}/players/${pid}/score`] = currentTotal + finalPoints;
          updates[`games/${gameId}/players/${pid}/lastPoints`] = finalPoints;
          
          // Give item box if slot available
          const itemSlots = p.itemSlots || [];

    // Spiegelglas: meistgew√§hlte Antwort bestimmen
    let mostChosenIndex = null;
    if (player?.activeEffects?.mirror && game?.players) {
      const counts = {};
      Object.values(game.players || {}).forEach(pl => {
        if (typeof pl.currentAnswer === 'number') {
          const idx = pl.currentAnswer;
          counts[idx] = (counts[idx] || 0) + 1;
        }
      });
      let bestIdx = null, bestCount = 0;
      Object.entries(counts).forEach(([idx,count])=>{
        if(count>bestCount){
          bestCount=count; bestIdx=parseInt(idx,10);
        }
      });
      mostChosenIndex = bestIdx;
    }

          if(itemSlots.length < ITEM_SLOTS) {
            const allScores = Object.values(playerObj).map(pl => pl.score || 0);
            const position = getPlayerPosition(p.score || 0, allScores);
            const newItem = getRandomItem(position);
            updates[`games/${gameId}/players/${pid}/itemSlots`] = [...itemSlots, newItem];
            updates[`games/${gameId}/players/${pid}/hasNewItem`] = true;
          }
        });
        
        await db.ref().update(updates);
        
        // Handle Platztauscher (point swaps) AFTER scores are updated
        const swapUpdates = {};
        Object.entries(playerObj).forEach(([pid, p]) => {
          if(p.activeEffects?.swapPointsWith) {
            const targetPid = p.activeEffects.swapPointsWith;
            const targetPlayer = playerObj[targetPid];
            
            if(targetPlayer) {
              // Get new scores after current updates
              const myNewScore = (p.score || 0) + (updates[`games/${gameId}/players/${pid}/lastPoints`] || 0);
              const targetNewScore = (targetPlayer.score || 0) + (updates[`games/${gameId}/players/${targetPid}/lastPoints`] || 0);
              
              // Swap scores
              swapUpdates[`games/${gameId}/players/${pid}/score`] = targetNewScore;
              swapUpdates[`games/${gameId}/players/${targetPid}/score`] = myNewScore;
              
              // Mark that swap happened
              swapUpdates[`games/${gameId}/players/${pid}/activeEffects/swappedWith`] = targetPid;
              swapUpdates[`games/${gameId}/players/${targetPid}/activeEffects/swappedWith`] = pid;
            }
          }
        });
        
        if(Object.keys(swapUpdates).length > 0) {
          await db.ref().update(swapUpdates);
        }
        
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });
      }catch(e){ console.error(e); }
    };

    const startNextRound = async ()=>{
      if(!meta) return;
      const gameSnap = await db.ref(`games/${gameId}`).get();
      const g = gameSnap.val();
      if (!g) { alert("Datenfehler: Spiel nicht gefunden"); return; }
      
      const currentIndex = g.meta.questionIndex || 0;
      const currentQuestions = g.questions || [];
      const nextIndex = currentIndex + 1;
      
      if(meta.phase === 'results'){
        const isRoundEnd = (nextIndex % QUESTIONS_PER_ROUND) === 0;
        if (isRoundEnd) {
             const finishedRound = Math.floor(currentIndex / QUESTIONS_PER_ROUND) + 1;
             if (finishedRound >= TOTAL_ROUNDS) {
                if(meta.finaleEnabled === false) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
                else await prepareFinale();
                return;
             }
             const pObj = g.players || {};
             const sorted = Object.entries(pObj).sort(([,a],[,b]) => (a.score||0) - (b.score||0));
             const minScore = sorted[0]?.[1].score || 0;
             const losers = sorted.filter(([,p]) => (p.score||0) === minScore).map(([id]) => id);
             const pickedLoser = losers.length > 0 ? losers[Math.floor(Math.random() * losers.length)] : null;

             await db.ref(`games/${gameId}/meta`).update({
               phase: 'roundSummary',
               round: finishedRound + 1,
               categoryChooserCandidate: pickedLoser || null
             });
             return;

        } else {
            await proceedToQuestion(nextIndex, g.meta.currentCategory, g.meta.categoryChooserForRound || null);
        }
      }
      else if(meta.phase === 'roundSummary'){
         const chosenCat = meta.nextCategory || null;
         const chooser = meta.categoryChooserForRound || null;
         
         let finalCat = chosenCat;
         if(!finalCat) {
            const used = meta.categoryState?.used || [];
            const avail = CATEGORY_LIST.filter(c => !used.includes(c));
            finalCat = avail.length > 0 ? avail[0] : CATEGORY_LIST[0];
         }

         const newBlock = getQuestionsForCategory(finalCat, QUESTIONS_PER_ROUND, currentQuestions.map(q=>q.question));
         const newQuestions = [...currentQuestions, ...newBlock];
         
         await db.ref(`games/${gameId}/questions`).set(newQuestions);
         const used = [...(meta.categoryState?.used || []), finalCat];
         await db.ref(`games/${gameId}/meta/categoryState/used`).set(used);
         
         await db.ref(`games/${gameId}/meta/nextCategory`).remove();
         await db.ref(`games/${gameId}/meta/categoryChooserCandidate`).remove();

         const safeStartIndex = currentQuestions.length; 
         await proceedToQuestion(safeStartIndex, finalCat, chooser);
      }
    };

    const proceedToQuestion = async (index, category, chooser) => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = {};
        updates[`games/${gameId}/players/${pid}/hasNewItem`] = false;
      });
      await db.ref().update(updates);

      await db.ref(`games/${gameId}/meta`).update({
          questionIndex: index,
          phase: 'question',
          questionStartTime: Date.now(),
          currentCategory: category,
          categoryChooserForRound: chooser || null,
          round: Math.floor(index / QUESTIONS_PER_ROUND) + 1
      });
    };

    const prepareFinale = async () => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const playersArr = Object.entries(pObj).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      if(playersArr.length < 2){ await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' }); return; }
      const top2 = playersArr.slice(0, 2).map(p => p.pid);
      await db.ref(`games/${gameId}/finalQuestions`).set(shuffle(FINAL_QUESTION_POOL).slice(0, FINAL_QUESTIONS));
      const updates = {};
      Object.keys(pObj).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/isFinalist`] = top2.includes(pid);
        updates[`games/${gameId}/players/${pid}/finalAnswers`] = {};
        updates[`games/${gameId}/players/${pid}/finalistReady`] = false;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({ phase: 'finalIntro', finalists: top2 });
    };

    const startFinalQuestion = async () => db.ref(`games/${gameId}/meta`).update({ phase: 'finalQuestion', finalQuestionIndex: 0, finalQuestionStartTime: Date.now() });
    const nextFinalQuestion = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const currentIndex = (snap.val()?.meta?.finalQuestionIndex || 0) + 1;
      if(currentIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finalReview', finalReviewIndex: 0 });
      else await db.ref(`games/${gameId}/meta`).update({ finalQuestionIndex: currentIndex, finalQuestionStartTime: Date.now() });
    };
    const judgeFinalAnswer = async (playerId, correct) => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = snap.val()?.meta?.finalReviewIndex || 0;
      const player = snap.val()?.players?.[playerId];
      if(!player) return;
      const points = correct ? (FINAL_ROUND_POINTS[reviewIndex] || 2000) : 0;
      await db.ref(`games/${gameId}/players/${playerId}`).update({ score: (player.score || 0) + points, [`finalScores/${reviewIndex}`]: points });
    };
    const nextFinalReview = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = (snap.val()?.meta?.finalReviewIndex || 0) + 1;
      if(reviewIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
      else await db.ref(`games/${gameId}/meta`).update({ finalReviewIndex: reviewIndex });
    };

    const startGame = async ()=>{
      const categoriesForGame = shuffle(CATEGORY_LIST).slice(0, TOTAL_ROUNDS);
      const firstCat = categoriesForGame[0];
      const block = getQuestionsForCategory(firstCat, QUESTIONS_PER_ROUND, []);
      
      await db.ref(`games/${gameId}/questions`).set(block);
      await db.ref(`games/${gameId}/meta/categoryState`).set({ used: [firstCat], remaining: categoriesForGame.slice(1) });
      await db.ref(`games/${gameId}/meta`).set({ 
        phase: 'question', questionIndex: 0, round: 1, questionStartTime: Date.now(), 
        currentCategory: firstCat, categoryChooserForRound: null, finaleEnabled: finaleEnabled 
      });

      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/itemSlots`] = [];
        updates[`games/${gameId}/players/${pid}/activeEffects`] = {};
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta/actions`).remove();
    };

    const toggleFinale = async () => {
      const newValue = !finaleEnabled;
      setFinaleEnabled(newValue);
      await db.ref(`games/${gameId}/meta/finaleEnabled`).set(newValue);
    };

    if(!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const isLobby = meta.phase === 'lobby';
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];
    const countdownClass = timeLeft <= 10 ? 'danger' : timeLeft <= 20 ? 'warning' : '';

    const isFinalPhase = meta.phase.startsWith('final');
    const displayCategory = isFinalPhase ? "FINALE" : (meta.currentCategory || question?.category || 'Allgemein');
    const displayCategoryColor = isFinalPhase ? 'var(--rtl-orange)' : 'var(--rtl-orange)';

    const resultsRanking = [...playersArr].sort((a,b) => (b.lastPoints||0) - (a.lastPoints||0));

    return (
      <div className="host-screen">
        {isLobby ? (
          <div style={{display:'flex', flexDirection:'column', width:'100%', height:'100vh', background:'#000'}}>
             <div style={{flex: '0 0 60%', display:'flex', alignItems:'center', justifyContent:'center', borderBottom:'2px solid rgba(255,255,255,0.1)', background:'radial-gradient(circle at center, #111 0%, #000 100%)'}}>
                <div style={{display:'flex', alignItems:'center', gap:80, transform:'scale(1.1)'}}>
                    <div style={{padding:20, background:'white'}}>
                        <img src={qrUrlForGame(gameId)} alt="QR" style={{width:'40vh', height:'40vh'}} />
                    </div>
                    <div style={{display:'flex', flexDirection:'column', gap:10}}>
                        <RTLLogo size="lg" />
                        <div style={{fontSize:'2rem', color:'var(--muted)', letterSpacing:2, marginTop:20}}>JOIN CODE:</div>
                        <div style={{fontSize:'8rem', fontWeight:900, lineHeight:1, color:'white', letterSpacing:10}}>{gameId}</div>
                    </div>
                </div>
             </div>
             
             <div style={{flex:1, background:'#0a0a0a', display:'flex', flexDirection:'column'}}>
                <div style={{display:'flex', justifyContent:'space-between', padding:'20px 40px', borderBottom:'1px solid rgba(255,255,255,0.1)', background:'#111'}}>
                    <div style={{fontSize:24, fontWeight:900, color:'var(--rtl-orange)'}}>LOBBY</div>
                    <div style={{display:'flex', alignItems:'center', gap:30}}>
                        <div style={{fontSize:24, fontWeight:700}}>Spieler: {playersArr.length}</div>
                         <div style={{display:'flex', alignItems:'center', gap:10, padding:'5px 15px', background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                            <span style={{fontSize:'14px', fontWeight:700}}>Finale?</span>
                            <label className="toggle-switch" style={{transform:'scale(0.8)'}}>
                              <input type="checkbox" checked={finaleEnabled} onChange={toggleFinale} />
                              <span className="toggle-slider"></span>
                            </label>
                          </div>
                        <button className="btn btn-host" onClick={startGame} style={{fontSize:20, padding:'10px 30px'}}>START ‚ñ∂</button>
                    </div>
                </div>
                <div className="scroll-area lobby-grid">
                   {playersArr.map(p => (
                       <div key={p.pid} className="lobby-player-chip">
                           <span>{p.name}</span>
                           <span style={{color:'var(--rtl-orange)'}}>‚óè</span>
                       </div>
                   ))}
                </div>
             </div>
          </div>
        ) : (
          <div className="host-main">
            {meta.phase !== 'finalIntro' && meta.phase !== 'finished' && (
                <div className="game-top-bar">
                     {meta.phase === 'roundSummary' ? (
                        <div style={{display:'flex', alignItems:'center', width:'100%'}}>
                            <div style={{fontSize:'3rem', fontWeight:900, color:'white', letterSpacing:2}}>ZWISCHENSTAND</div>
                        </div>
                     ) : (
                        <div style={{display:'flex', alignItems:'center', gap:20}}>
                            <div className={`countdown-badge ${countdownClass}`}>{timeLeft}</div>
                            <div>
                              <div style={{color:'var(--muted)', fontSize:'1rem', textTransform:'uppercase'}}>
                                  {isFinalPhase ? 'Das Finale' : `Runde ${meta.round || 1} | Frage ${(qIndex%QUESTIONS_PER_ROUND)+1}`}
                              </div>
                              <div style={{fontWeight:900, fontSize:'1.8rem', color: displayCategoryColor}}>{displayCategory}</div>
                            </div>
                        </div>
                     )}
                     
                     <div style={{display:'flex', alignItems:'center', gap:20}}>
                        {meta.phase === 'question' && <button className="btn btn-show-results" onClick={showResultsNow}>L√∂sung anzeigen ‚ñ∂</button>}
                        {meta.phase === 'results' && <button className="btn btn-host" onClick={startNextRound}>Weiter ‚ñ∂</button>}
                        {meta.phase === 'roundSummary' && <button className="btn btn-host" onClick={startNextRound}>N√§chste Runde ‚ñ∂</button>}
                        <button className="btn-pause-gold" onClick={handlePause} title="Spiel pausieren">II</button>
                     </div>
                </div>
            )}

            <div className="host-main-inner">
                {meta.phase === 'question' && question && (
                  <>
                    <div className="question-area">
                        <h2 className="question-text">{question.question}</h2>
                    </div>
                    <div className="answers-grid">
                      {question.answers.map((a,i)=>(
                        <div key={i} className="answer-btn">
                          <div style={{fontWeight:900, color:'var(--rtl-orange)', fontSize:'3rem'}}>{String.fromCharCode(65+i)}</div>
                          <div style={{fontSize:'2.2rem'}}>{a}</div>
                        </div>
                      ))}
                    </div>
                    <div style={{marginTop: 'auto', paddingTop: 30, borderTop:'1px solid rgba(255,255,255,0.1)', width:'100%'}}>
                        <div style={{fontSize:16, color:'var(--muted)', marginBottom:15, textAlign:'center', textTransform:'uppercase', letterSpacing:1, fontWeight:700}}>
                            Spieler Status ({playersArr.filter(p => p.currentAnswer !== undefined && p.currentAnswer !== null).length} / {playersArr.length})
                        </div>
                        <div style={{display:'flex', flexWrap:'wrap', gap:10, justifyContent:'center'}}>
                            {playersArr.map(p => {
                                const hasAnswered = p.currentAnswer !== null && p.currentAnswer !== undefined;
                                return (
                                    <div key={p.pid} style={{
                                        padding: '8px 16px',
                                        background: hasAnswered ? 'var(--rtl-orange)' : 'rgba(255,255,255,0.1)',
                                        color: hasAnswered ? '#000' : 'rgba(255,255,255,0.5)',
                                        fontWeight: 900,
                                        fontSize: 14,
                                        border: hasAnswered ? '1px solid var(--rtl-orange)' : '1px solid rgba(255,255,255,0.1)',
                                        display:'flex', alignItems:'center', gap:6
                                    }}>
                                        {p.name}
                                        {hasAnswered && <span>‚úì</span>}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                  </>
                )}

                {meta.phase === 'results' && question && (
                   <div className="results-split-view">
                      <div className="results-col">
                         <div style={{display:'grid', gap:12, flex:1, overflow:'auto', alignContent:'center', height:'100%'}}>
                            {question.answers.map((a,i)=>{
                              const isCorrect = i === question.correct;
                              const voters = playersArr.filter(p => p.currentAnswer === i);
                              const showHighlight = isCorrect && revealAnswer;

                              return (
                                <div key={i} className={showHighlight ? 'reveal-correct' : ''} style={{
                                    padding:30, 
                                    border: showHighlight ? '5px solid white' : '1px solid rgba(255,255,255,0.1)', 
                                    background: showHighlight ? 'rgba(255,255,255,1)' : 'rgba(255,255,255,0.02)',
                                    color: showHighlight ? '#000' : '#fff',
                                    transition: 'all 0.5s ease'
                                }}>
                                  <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                    <div style={{fontWeight:900, fontSize:28}}>{String.fromCharCode(65+i)}. {a}</div>
                                  </div>
                                  <div style={{marginTop:12, fontSize:20, color: showHighlight ? '#000' : 'var(--muted)'}}>
                                    {voters.length} Stimmen {voters.length>0 && `(${voters.map(p=>p.name).join(', ')})`}
                                  </div>
                                </div>
                              )
                            })}
                         </div>
                      </div>
                      <div className="results-col">
                         {revealAnswer && (
                            <>
                                <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                                   <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Aktionen</h3>
                                   <div className="scroll-area" style={{flex:1}}>
                                     {(() => {
                                        const actions = (game.meta?.actions?.[qIndex] || []);
                                        if(actions.length === 0) return <div style={{color:'var(--muted)', fontStyle:'italic'}}>Keine Aktionen.</div>;
                                        return actions.map((act, idx) => {
                                           const from = game.players[act.from]?.name || '???';
                                           const to = game.players[act.to]?.name || '???';
                                           const itemInfo = ITEM_TYPES[act.itemId];
                                           return <div key={idx} className={`action-log-item ${act.type}`}>{itemInfo?.icon} <b>{from}</b> ‚Üí {to}: {itemInfo?.name}</div>;
                                        });
                                     })()}
                                   </div>
                                </div>
                                <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                                    <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Score (Frage)</h3>
                                    <div className="scroll-area" style={{flex:1}}>
                                      {resultsRanking.map((p,i)=>(
                                        <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:'12px', background:i<3?'rgba(255,255,255,0.05)':'transparent', marginBottom:4}}>
                                          <div style={{display:'flex', gap:8}}>
                                            <span style={{fontWeight:700, fontSize:18}}>{p.name}</span>
                                          </div>
                                          <div style={{fontWeight:900, color: p.lastPoints>0 ? 'var(--rtl-orange)' : (p.lastPoints<0 ? 'var(--rtl-orange)' : 'var(--muted)'), fontSize:18}}>
                                             {p.lastPoints > 0 ? '+' : ''}{p.lastPoints}
                                          </div>
                                        </div>
                                      ))}
                                    </div>
                                </div>
                            </>
                         )}
                      </div>
                   </div>
                )}

                {meta.phase === 'roundSummary' && (
                   <div style={{width:'100%', height:'100%', display:'flex', flexDirection:'column'}}>
                      <h2 style={{textAlign:'center', fontSize:48, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20}}>Stand nach Runde {meta.round - 1}</h2>
                      <div style={{textAlign:'center', color:'var(--muted)', marginBottom:30, fontSize:20, display:'flex', flexDirection:'column', gap:10, alignItems:'center'}}>
                         <div>Der Spieler auf dem letzten Platz w√§hlt die n√§chste Kategorie.</div>
                         {meta.categoryChooserCandidate && (
                            <div style={{background:'rgba(255,255,255,0.1)', padding:'10px 20px', border:'1px solid rgba(255,255,255,0.2)', display:'flex', gap:15, alignItems:'center'}}>
                                <span style={{fontWeight:700}}>W√ÑHLER: {game.players[meta.categoryChooserCandidate]?.name}</span>
                                {game.meta?.nextCategory ? (
                                    <span style={{color:'var(--rtl-orange)', fontWeight:900}}>HAT GEW√ÑHLT: {game.meta.nextCategory}</span>
                                ) : (
                                    <span style={{color:'var(--rtl-orange)', fontWeight:900, animation:'pulse 1s infinite'}}>W√ÑHLT...</span>
                                )}
                            </div>
                         )}
                      </div>
                      <div className="scroll-area" style={{flex:1, background:'rgba(255,255,255,0.02)', padding:40, border:'1px solid rgba(255,255,255,0.05)'}}>
                         {playersArr.map((p,i)=>(
                            <div key={p.pid} style={{
                               display:'flex', alignItems:'center', justifyContent:'space-between',
                               padding:25, marginBottom:10,
                               background: i===0 ? 'linear-gradient(90deg, rgba(255,215,0,0.2), rgba(0,0,0,0))' : 
                                           i===1 ? 'linear-gradient(90deg, rgba(192,192,192,0.2), rgba(0,0,0,0))' : 
                                           i===2 ? 'linear-gradient(90deg, rgba(205,127,50,0.2), rgba(0,0,0,0))' : 'rgba(255,255,255,0.02)',
                               borderLeft: i===0 ? '6px solid gold' : i===1 ? '6px solid silver' : i===2 ? '6px solid #cd7f32' : '6px solid transparent'
                            }}>
                               <div style={{display:'flex', alignItems:'center', gap:30}}>
                                  <div style={{fontSize:36, fontWeight:900, width:60}}>{i+1}.</div>
                                  <div style={{fontSize:28, fontWeight:700}}>{p.name}</div>
                                  {meta.categoryChooserCandidate === p.pid && <div style={{background:'var(--rtl-orange)', color: '#000', padding:'6px 12px', fontWeight:900, fontSize:16}}>DARF W√ÑHLEN!</div>}
                               </div>
                               <div style={{display:'flex', alignItems:'center', gap:40}}>
                                  <div style={{fontSize:20, color:'var(--muted)', display:'flex', gap:10}}>
                                    {(p.itemSlots || []).map((item, idx) => (
                                      <span key={idx}>{item.icon}</span>
                                    ))}
                                  </div>
                                  <div style={{fontSize:36, fontWeight:900, color:'var(--tile)'}}>{p.score}</div>
                               </div>
                            </div>
                         ))}
                      </div>
                   </div>
                )}

                {['finalIntro', 'finalQuestion', 'finalReview', 'finished'].includes(meta.phase) && (
                    <div style={{flex:1, display:'flex', justifyContent:'center', alignItems:'center', flexDirection:'column'}}>
                        {meta.phase === 'finalIntro' && <FinalIntroHostView game={game} meta={meta} onStart={startFinalQuestion} />}
                        {meta.phase === 'finalQuestion' && <FinalQuestionHostView game={game} meta={meta} timeLeft={timeLeft} onNext={nextFinalQuestion} />}
                        {meta.phase === 'finalReview' && <FinalReviewHostView game={game} meta={meta} onJudge={judgeFinalAnswer} onNext={nextFinalReview} />}
                        {meta.phase === 'finished' && (
                           <div style={{width:'100%', height:'100%', position:'relative', display:'flex', flexDirection:'column', alignItems:'center'}}>
                              <ConfettiRain />
                              <div style={{zIndex:10, textAlign:'center', paddingTop:40}}>
                                  <h1 style={{fontSize:80, fontWeight:900, margin:0, color:'var(--rtl-orange)', textTransform:'uppercase', letterSpacing:4}}>Siegerehrung</h1>
                              </div>
                              <div className="podium-container" style={{zIndex:10}}>
                                  {playersArr[1] && (
                                      <div className="podium-place podium-2">
                                          <div className="winner-score">{playersArr[1].score}</div>
                                          <div className="winner-name">{playersArr[1].name}</div>
                                          <div className="podium-bar">2</div>
                                      </div>
                                  )}
                                  {playersArr[0] && (
                                      <div className="podium-place podium-1">
                                          <div className="winner-score">{playersArr[0].score}</div>
                                          <div className="winner-name">üëë {playersArr[0].name}</div>
                                          <div className="podium-bar">1</div>
                                      </div>
                                  )}
                                  {playersArr[2] && (
                                      <div className="podium-place podium-3">
                                          <div className="winner-score">{playersArr[2].score}</div>
                                          <div className="winner-name">{playersArr[2].name}</div>
                                          <div className="podium-bar">3</div>
                                      </div>
                                  )}
                              </div>
                              <button className="btn btn-host" style={{zIndex:10, marginTop:'auto', marginBottom:40, fontSize:24, padding:'20px 50px'}} onClick={backToLobby}>Zur√ºck zur Lobby</button>
                           </div>
                        )}
                    </div>
                )}
            </div>
          </div>
        )}

        {pauseModalOpen && (
          <div className="modal-backdrop">
            <div className="modal-card" style={{textAlign:'center'}}>
              <h3 style={{fontWeight:900, fontSize:32, marginBottom:10, color:'var(--rtl-orange)'}}>PAUSE</h3>
              
              <div style={{marginBottom: 30, padding: 20, background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)'}}>
                  <div style={{fontSize: 16, color: 'var(--muted)', textTransform: 'uppercase', letterSpacing: 2, marginBottom: 5}}>Game Code</div>
                  <div style={{fontSize: 60, fontWeight: 900, color: 'white', letterSpacing: 8, fontFamily: 'monospace'}}>{gameId}</div>
              </div>

              <div style={{display:'flex', flexDirection:'column', gap:20}}>
                <button className="btn btn-host" onClick={resumeGame} style={{fontSize:20, padding:'20px'}}>‚ñ∂ WEITER</button>
                <button className="btn" onClick={backToLobby} style={{fontSize:20, padding:'20px', background:'rgba(255,255,255,0.1)'}}>‚Ü© LOBBY / RESET</button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * FINAL COMPONENTS
   ****************************************/
  function FinalIntroHostView({ game, meta, onStart }){
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allReady = finalists.every(f => f.finalistReady === true);
    return (
      <div style={{textAlign:'center', width:'100%'}}>
        <h2 style={{fontSize:60, fontWeight:900, color:'var(--rtl-orange)', marginBottom:50}}>FINALE</h2>
        <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:60, width:'100%', maxWidth:1200, margin:'0 auto'}}>
          {finalists.map((f, idx) => (
            <div key={f.pid} style={{padding:50, background:'rgba(255,255,255,0.05)', 
                 border: f.finalistReady ? '6px solid var(--rtl-orange)' : '6px solid var(--rtl-orange)'
            }}>
              <div style={{fontSize:100}}>{idx === 0 ? '1.' : '2.'}</div>
              <div style={{fontSize:50, fontWeight:900}}>{f.name}</div>
              <div style={{fontSize:40, color:'var(--muted)'}}>{f.score} Pkt</div>
              <div style={{marginTop:40, padding:20, 
                  background: f.finalistReady ? 'var(--rtl-orange)' : 'rgba(255,255,255,0.1)', 
                  color: f.finalistReady ? '#000' : '#fff',
                  fontWeight:700, fontSize:24}}>
                {f.finalistReady ? 'BEREIT' : 'WARTEN...'}
              </div>
            </div>
          ))}
        </div>
        {allReady && <button className="btn btn-host" onClick={onStart} style={{marginTop:60, fontSize:32, padding:'30px 60px'}}>START ‚ñ∂</button>}
      </div>
    );
  }

  function FinalQuestionHostView({ game, meta, timeLeft, onNext }){
    const finalQIndex = meta.finalQuestionIndex || 0;
    const question = (game.finalQuestions || [])[finalQIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allAnswered = finalists.every(f => f.finalAnswers?.[finalQIndex]);
    
    const buttonText = finalQIndex + 1 >= FINAL_QUESTIONS ? 'ZUR AUSWERTUNG' : 'N√ÑCHSTE FRAGE';

    return (
      <div style={{textAlign:'center', width:'100%', maxWidth:1400}}>
        <h2 style={{fontSize:50, fontWeight:900, lineHeight:1.3}}>{question?.question}</h2>
        <div style={{display:'flex', gap:40, marginTop:80}}>
          {finalists.map(f => (
             <div key={f.pid} style={{flex:1, padding:40, background:'rgba(255,255,255,0.05)', 
                 border: f.finalAnswers?.[finalQIndex] ? '5px solid var(--rtl-orange)' : '2px solid rgba(255,255,255,0.1)'
             }}>
                <div style={{fontWeight:900, fontSize:36}}>{f.name}</div>
                <div style={{marginTop:20, fontSize:24, 
                    color: f.finalAnswers?.[finalQIndex] ? 'var(--rtl-orange)' : 'var(--muted)'}}>
                   {f.finalAnswers?.[finalQIndex] ? '‚úì ANTWORT DA' : 'Tippt...'}
                </div>
             </div>
          ))}
        </div>
        {(timeLeft === 0 || allAnswered) && <button className="btn btn-host" onClick={onNext} style={{marginTop:60, fontSize:28, padding:'20px 40px'}}>{buttonText}</button>}
      </div>
    );
  }

  function FinalReviewHostView({ game, meta, onJudge, onNext }){
    const reviewIndex = meta.finalReviewIndex || 0;
    const question = (game.finalQuestions || [])[reviewIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const [judged, setJudged] = useState({});
    const handleJudge = async (pid, ok) => { await onJudge(pid, ok); setJudged(prev => ({...prev, [pid]: ok})); };
    return (
      <div className="results-split-view" style={{width:'100%'}}>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           <h3 style={{color:'var(--muted)', textTransform:'uppercase', fontWeight:900, fontSize:20}}>Frage {reviewIndex+1}</h3>
           <div style={{fontSize:40, fontWeight:900, marginBottom:40, lineHeight:1.2}}>{question?.question}</div>
           <div style={{padding:40, background:'#fff', color:'#000'}}>
              <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)'}}>L√ñSUNG</div>
              <div style={{fontSize:36, fontWeight:900}}>{question?.answer}</div>
           </div>
        </div>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           {finalists.map(f => (
              <div key={f.pid} style={{padding:30, background:'rgba(255,255,255,0.05)', marginBottom:20}}>
                 <div style={{display:'flex', justifyContent:'space-between', marginBottom:15}}>
                    <span style={{fontWeight:900, fontSize:24}}>{f.name}</span>
                    <span style={{color:'var(--muted)', fontSize:20}}>{f.score} Pkt</span>
                 </div>
                 <div style={{fontSize:28, padding:20, background:'rgba(0,0,0,0.5)', marginBottom:20, fontStyle:'italic'}}>"{f.finalAnswers?.[reviewIndex] || '---'}"</div>
                 {judged[f.pid] === undefined ? (
                    <div style={{display:'flex', gap:20}}>
                       <button className="btn" style={{flex:1, background:'white', color:'black', border:'2px solid white', fontSize:20}} onClick={()=>handleJudge(f.pid, true)}>‚úì KORREKT</button>
                       <button className="btn" style={{flex:1, background:'transparent', border:'2px solid rgba(255,255,255,0.2)', color:'white'}} onClick={()=>handleJudge(f.pid, false)}>‚úó FALSCH</button>
                    </div>
                 ) : (
                    <div style={{textAlign:'center', fontWeight:900, color: judged[f.pid] ? 'var(--rtl-orange)' : 'var(--rtl-orange)', fontSize:20}}>{judged[f.pid] ? 'PUNKTE VERGEBEN' : 'ALS FALSCH GEWERTET'}</div>
                 )}
              </div>
           ))}
           {Object.keys(judged).length === finalists.length && <button className="btn btn-host" onClick={()=>{ setJudged({}); onNext(); }} style={{marginTop:30, fontSize:24, padding:'20px 40px'}}>WEITER ‚ñ∂</button>}
        </div>
      </div>
    );
  }

  /****************************************
   * PLAYER VIEW
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [itemModalOpen, setItemModalOpen] = useState(false);
    const [selectedItem, setSelectedItem] = useState(null);
    const [targetModalOpen, setTargetModalOpen] = useState(false);
    const [bonusCategoryModalOpen, setBonusCategoryModalOpen] = useState(false);
    const [finalAnswer, setFinalAnswer] = useState('');
    const [playerReveal, setPlayerReveal] = useState(false);
    const [eliminated5050, setEliminated5050] = useState([]);
    const [scannedAnswers, setScannedAnswers] = useState({});
    const [isFrozen, setIsFrozen] = useState(false);
    const [freezeTimeLeft, setFreezeTimeLeft] = useState(0);
    
    // NEW: Item Box Roulette States
    const [showItemRoulette, setShowItemRoulette] = useState(false);
    const [rouletteItems, setRouletteItems] = useState([]);
    const [finalRouletteItem, setFinalRouletteItem] = useState(null);
    const [roulettePhase, setRoulettePhase] = useState('spinning'); // spinning, slowing, stopping, revealed
    const [pendingNewItem, setPendingNewItem] = useState(null);
    
    // NEW: Item Tooltip States
    const [showItemTooltip, setShowItemTooltip] = useState(false);
    const [tooltipItem, setTooltipItem] = useState(null);
    const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
    const longPressTimer = useRef(null);
    
    // NEW: Attack Notification
    const [attackNotification, setAttackNotification] = useState(null);
    
    // NEW: Items Info Modal
    const [showItemsInfo, setShowItemsInfo] = useState(false);
    
    // NEW: Time reduction tracking
    const [timeReductionApplied, setTimeReductionApplied] = useState(false);

    useEffect(() => { if(playerId && gameId) { sessionStorage.setItem(`quiz_pid_${gameId}`, playerId); } }, [playerId, gameId]);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); mRef.off(); pRef.off(); };
    },[gameId, playerId]);

    useEffect(() => {
        setEliminated5050([]);
        setScannedAnswers({});
        setTimeReductionApplied(false);
        setIsActivatingItem(false);
    }, [meta?.questionIndex]);

    // Show round start screen
    useEffect(() => {
      if(meta?.phase === 'question' && meta?.questionStartTime) {
        const elapsed = Date.now() - meta.questionStartTime;
        if(elapsed < 100) { // Just started
          const currentRound = meta.round || 1;
          const points = ROUND_POINTS[currentRound] || 100;
          setShowRoundStart(true);
          
          setTimeout(() => {
            setShowRoundStart(false);
          }, 3000);
        }
      }
    }, [meta?.phase, meta?.questionStartTime]);

    useEffect(()=>{
      if(!meta){ setTimeLeft(0); return; }
      if(meta.phase === 'question' && meta.questionStartTime){
        const tick = ()=>{ 
          let elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000);
          
          // Apply time reduction if active
          if(player?.activeEffects?.timeReduced && !timeReductionApplied) {
            // Skip ahead by half the total time
            elapsed += Math.floor(QUESTION_TIME / 2);
            setTimeReductionApplied(true);
            
            // Show notification
            setAttackNotification({
              icon: '‚è±Ô∏è',
              title: 'ZEIT HALBIERT',
              message: 'Ein Gegner hat deine Zeit reduziert'
            });
            setTimeout(() => setAttackNotification(null), 3000);
          }
          
          setTimeLeft(Math.max(0, QUESTION_TIME - elapsed)); 
        };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else if(meta.phase === 'finalQuestion' && meta.finalQuestionStartTime){
        const tick = ()=>{ const elapsed = Math.floor((Date.now() - meta.finalQuestionStartTime)/1000); setTimeLeft(Math.max(0, FINAL_TIME - elapsed)); };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else { setTimeLeft(0); }
    },[meta?.questionStartTime, meta?.finalQuestionStartTime, meta?.phase, player?.activeEffects?.timeReduced, timeReductionApplied]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setPlayerReveal(false);
            const t = setTimeout(() => setPlayerReveal(true), 3000); 
            return () => clearTimeout(t);
        } else {
            setPlayerReveal(false);
        }
    }, [meta?.phase, meta?.questionIndex]);

    // NEW: Detect when new item is received and trigger roulette
    useEffect(() => {
      if(player?.hasNewItem && meta?.phase === 'results' && playerReveal) {
        const currentSlots = player.itemSlots || [];
        const lastItem = currentSlots[currentSlots.length - 1];
        if(lastItem && !pendingNewItem) {
          setPendingNewItem(lastItem);
          
          // Wait 1.5 seconds after reveal, then start roulette
          setTimeout(() => {
            startItemRoulette(lastItem);
          }, 1500);
        }
      }
    }, [player?.hasNewItem, meta?.phase, playerReveal]);

    const startItemRoulette = (finalItem) => {
      // Generate roulette items with mystery boxes until reveal
      const randomItems = [];
      
      // Add 15 mystery boxes
      for(let i = 0; i < 15; i++) {
        randomItems.push({ icon: '‚ùì', key: `mystery-${i}`, isMystery: true });
      }
      
      // Add the final item at position that will be centered when animation stops
      randomItems.push({...finalItem, key: 'final-item'});
      
      // Add a few more mystery boxes after
      for(let i = 0; i < 5; i++) {
        randomItems.push({ icon: '‚ùì', key: `mystery-after-${i}`, isMystery: true });
      }
      
      setRouletteItems(randomItems);
      setFinalRouletteItem(finalItem);
      setRoulettePhase('spinning');
      setShowItemRoulette(true);
      
      // Timing sequence
      setTimeout(() => setRoulettePhase('slowing'), 2000);
      setTimeout(() => setRoulettePhase('stopping'), 3000);
      setTimeout(() => setRoulettePhase('revealed'), 3800);
    };

    const closeItemRoulette = () => {
      setShowItemRoulette(false);
      setPendingNewItem(null);
      db.ref(`games/${gameId}/players/${playerId}/hasNewItem`).set(false);
    };

    // Item Tooltip handlers removed - no longer needed

    // Check for freeze effect
    useEffect(() => {
      if(player?.activeEffects?.frozen && player?.activeEffects?.frozenUntil) {
        const checkFreeze = () => {
          const now = Date.now();
          if(now < player.activeEffects.frozenUntil) {
            setIsFrozen(true);
            setFreezeTimeLeft(Math.ceil((player.activeEffects.frozenUntil - now) / 1000));
          } else {
            setIsFrozen(false);
            setFreezeTimeLeft(0);
          }
        };
        checkFreeze();
        const interval = setInterval(checkFreeze, 100);
        return () => clearInterval(interval);
      } else {
        setIsFrozen(false);
        setFreezeTimeLeft(0);
      }
    }, [player?.activeEffects]);

    // Check for attack notifications
    useEffect(() => {
      if(player?.activeEffects?.poisoned && meta?.phase === 'question') {
        setAttackNotification({
          icon: '‚ò†Ô∏è',
          title: 'VERGIFTET',
          message: 'Du erh√§ltst 25% weniger Punkte'
        });
        setTimeout(() => setAttackNotification(null), 3000);
      }
      
      if(player?.activeEffects?.frozen && meta?.phase === 'question') {
        setAttackNotification({
          icon: '‚ùÑÔ∏è',
          title: 'EINGEFROREN',
          message: 'Du bist f√ºr 8 Sekunden blockiert'
        });
        setTimeout(() => setAttackNotification(null), 3000);
      }
      
      if(player?.activeEffects?.swappedWith && meta?.phase === 'results') {
        const swappedPlayer = game?.players?.[player.activeEffects.swappedWith];
        setAttackNotification({
          icon: 'üîÑ',
          title: 'PLATZTAUSCHER',
          message: `Punkte getauscht mit ${swappedPlayer?.name || 'einem Spieler'}`
        });
        setTimeout(() => setAttackNotification(null), 4000);
      }
    }, [player?.activeEffects?.poisoned, player?.activeEffects?.frozen, player?.activeEffects?.swappedWith, meta?.questionIndex, meta?.phase]);

    const useItem = (item, slotIndex) => {
      if(isFrozen || isActivatingItem) return;
      setIsActivatingItem(true);
      
      if(item.needsTarget) {
        setSelectedItem({...item, slotIndex});
        setTargetModalOpen(true);
      } else {
        activateItem(item, slotIndex, null);
      }
    };

    const activateItem = async (item, slotIndex, targetId) => {
      setItemModalOpen(false);
      setTargetModalOpen(false);
      
      const updates = {};
      const currentSlots = player.itemSlots || [];
      const newSlots = currentSlots.filter((_, idx) => idx !== slotIndex);
      updates[`games/${gameId}/players/${playerId}/itemSlots`] = newSlots;

      // Apply item effects
      if(item.id === 'schild') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/shield`] = true;
      } else if(item.id === 'turbo') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/turbo`] = true;
      } else if(item.id === 'magnet') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/magnet`] = true;
      } else if(item.id === 'spiegelglas') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/mirror`] = true;
      } else if(item.id === 'giftpfeil' && targetId) {
        // Check if target has shield
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer?.activeEffects?.shield) {
          // Reflected back!
          updates[`games/${gameId}/players/${playerId}/activeEffects/poisoned`] = true;
        } else {
          updates[`games/${gameId}/players/${targetId}/activeEffects/poisoned`] = true;
        }
      } else if(item.id === 'freeze' && targetId) {
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer?.activeEffects?.shield) {
          // Reflected - freeze yourself
          const frozenUntil = Date.now() + 8000;
          updates[`games/${gameId}/players/${playerId}/activeEffects/frozen`] = true;
          updates[`games/${gameId}/players/${playerId}/activeEffects/frozenUntil`] = frozenUntil;
        } else {
          const frozenUntil = Date.now() + 8000;
          updates[`games/${gameId}/players/${targetId}/activeEffects/frozen`] = true;
          updates[`games/${gameId}/players/${targetId}/activeEffects/frozenUntil`] = frozenUntil;
        }
      } else if(item.id === 'zeitschnapper' && targetId) {
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer?.activeEffects?.shield) {
          // Reflected
          updates[`games/${gameId}/players/${playerId}/activeEffects/timeReduced`] = true;
        } else {
          updates[`games/${gameId}/players/${targetId}/activeEffects/timeReduced`] = true;
        }
      } else if(item.id === 'zapfer') {
        const q = (game.questions || [])[meta.questionIndex || 0];
        if(q) {
          const wrong = q.answers.map((_, i) => i).filter(i => i !== q.correct);
          const toEliminate = shuffle(wrong).slice(0, 2);
          setEliminated5050(toEliminate);
        }
      } else if(item.id === 'scanner' && targetId) {
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer && targetPlayer.currentAnswer !== null && targetPlayer.currentAnswer !== undefined) {
          setScannedAnswers(prev => ({...prev, [targetId]: targetPlayer.currentAnswer}));
        }
      } else if(item.id === 'platztauscher') {
        // Find random other player to swap with
        const otherPlayers = Object.keys(game.players || {}).filter(pid => pid !== playerId);
        if(otherPlayers.length > 0) {
          const randomTarget = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
          
          // Perform the swap at results phase
          updates[`games/${gameId}/players/${playerId}/activeEffects/swapPointsWith`] = randomTarget;
          updates[`games/${gameId}/players/${randomTarget}/activeEffects/swappedWith`] = playerId;
        }
      }

      // Log action
      if(targetId || item.id === 'turbo' || item.id === 'magnet' || item.id === 'platztauscher') {
        await db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).once('value', s => {
           const arr = s.val() || [];
           arr.push({ type: item.effect, from: playerId, to: targetId || playerId, itemId: item.id.toUpperCase() });
           db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).set(arr);
        });
      }

      await db.ref().update(updates);
      
      // Reset activation lock after a short delay
      setTimeout(() => setIsActivatingItem(false), 500);
    };

    const pickCategory = async (cat) => {
        await db.ref(`games/${gameId}/meta`).update({ 
            nextCategory: cat, 
            categoryChooserForRound: playerId 
        });
        setBonusCategoryModalOpen(false);
    };

    if(!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    if(meta.phase === 'finalIntro') {
        if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale</h2><p>Du bist Zuschauer.</p></div></div>;
        return (
            <div className="min-h-screen p-4 flex items-center justify-center">
                <div className="card" style={{textAlign:'center', width:'100%'}}>
                    <h2 style={{fontSize:30, marginBottom:20}}>FINALE!</h2>
                    <p style={{marginBottom:30}}>Bist du bereit?</p>
                    {!player.finalistReady ? (
                        <button className="btn btn-host w-full" style={{padding:30, fontSize:24}} onClick={()=>db.ref(`games/${gameId}/players/${playerId}/finalistReady`).set(true)}>ICH BIN BEREIT</button>
                    ) : (
                        <div style={{color:'var(--rtl-orange)', fontSize:20, fontWeight:900}}>WARTEN AUF GEGNER...</div>
                    )}
                </div>
            </div>
        );
    }
    if(meta.phase === 'finalQuestion'){
       const question = (game.finalQuestions||[])[meta.finalQuestionIndex||0];
       if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale l√§uft...</h2></div></div>;
       const hasAnswered = player.finalAnswers && player.finalAnswers[meta.finalQuestionIndex||0];
       return (
          <div className="min-h-screen p-4"><div className="card"><h2>Frage {meta.finalQuestionIndex+1}</h2><p>{question?.question}</p>
          {!hasAnswered ? <><input className="w-full p-3 mt-4" value={finalAnswer} onChange={e=>setFinalAnswer(e.target.value)}/><button className="btn btn-host w-full mt-2" onClick={()=>{db.ref(`games/${gameId}/players/${playerId}/finalAnswers/${meta.finalQuestionIndex}`).set(finalAnswer); setFinalAnswer('');}}>Senden</button></> : <p>Antwort gesendet.</p>}</div></div>
       );
    }

    if(meta.phase === 'question'){
       const question = (game.questions||[])[meta.questionIndex||0];
       const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
       const itemSlots = player.itemSlots || [];
       
       return (
         <div className="min-h-screen p-4" style={{overflowY:'auto', position:'relative'}}>
           {/* Round Start Screen */}
           {showRoundStart && (
             <div className="round-start-overlay">
               <div className="round-start-content">
                 <h2>Runde {meta.round}</h2>
                 <div className="points-label">Punkte f√ºr richtige Antwort</div>
                 <div className="points-info">{ROUND_POINTS[meta.round || 1]} Punkte</div>
                 <div style={{fontSize: 14, color: 'var(--muted)'}}>Viel Erfolg</div>
               </div>
             </div>
           )}

           {isFrozen && (
              <div className="frozen-overlay">
                EINGEFROREN {freezeTimeLeft}s
              </div>
           )}
           
           {/* Attack Notification */}
           {attackNotification && (
             <div className="attack-notification">
               <h3>{attackNotification.icon} {attackNotification.title}</h3>
               <p>{attackNotification.message}</p>
             </div>
           )}
           
           <div className="card">
             <div style={{display:'flex', justifyContent:'space-between', borderBottom:'1px solid rgba(255,255,255,0.1)', paddingBottom:10, marginBottom:15}}>
                 <span style={{fontWeight:700, color:'var(--muted)'}}>Runde {meta.round}</span>
                 <span style={{fontWeight:900, color:'var(--tile)'}}>Gesamt: {player.score}</span>
             </div>
             
             {player.hasNewItem && (
                <div style={{background:'var(--rtl-orange)', color:'#000', padding:15, marginBottom:15, fontWeight:900, textAlign:'center'}}>
                  üì¶ NEUES ITEM ERHALTEN!
                </div>
             )}

             <div style={{display:'flex',justifyContent:'space-between'}}><span>Zeit:</span><span style={{fontWeight:900,color:'var(--rtl-orange)'}}>{timeLeft}s</span></div>
             <h3 style={{fontSize:20,fontWeight:900,marginTop:12}}>{question?.question}</h3>
             
             {/* Item Slots */}
             <div style={{display:'flex', gap:10, marginTop:15, justifyContent:'center'}}>
               {[0, 1].map(slotIdx => {
                  const item = itemSlots[slotIdx];
                  return (
                    <div 
                      key={slotIdx}
                      className={`item-slot ${item ? `rarity-${item.rarity}` : 'empty'}`}
                      onClick={() => item && !isFrozen && !isActivatingItem && useItem(item, slotIdx)}
                      title={item ? item.name : 'Leer'}
                      style={{cursor: item && !isFrozen && !isActivatingItem ? 'pointer' : 'default'}}
                    >
                      {item ? item.icon : '‚ùì'}
                    </div>
                  );
               })}
             </div>

             <div style={{display:'grid', gap:10, marginTop:20}}>
               {question?.answers.map((a,i)=>{
                 const is5050Eliminated = eliminated5050.includes(i);
                 const isScanned = Object.values(scannedAnswers).includes(i);
                 return (
                   <button 
                      key={i} 
                      disabled={hasAnswered||timeLeft<=0||isFrozen||is5050Eliminated} 
                      onClick={()=>!isFrozen && db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i)} 
                      style={{
                          padding:15,
                          background:player.currentAnswer===i?'var(--rtl-orange)':(is5050Eliminated ? '#333' : 'white'), 
                          color:player.currentAnswer===i?'white':(is5050Eliminated ? '#666' : '#0b0b0b'),
                          border: player.currentAnswer===i ? '1px solid var(--rtl-orange)' : ((isMostChosen ? '3px solid orange' : (isScanned ? '3px solid #2196F3' : '1px solid #e0e0e0'))),
                          textAlign:'left', 
                          fontSize:18,
                          display:'flex',
                          alignItems:'center',
                          gap: '10px',
                          transition: 'all 0.2s',
                          opacity: is5050Eliminated ? 0.3 : 1,
                          position: 'relative'
                      }}>
                      <span style={{fontWeight:900, color: player.currentAnswer===i?'white':(is5050Eliminated ? '#666' : 'var(--rtl-orange)'), marginRight: '10px'}}>{String.fromCharCode(65+i)}.</span>
                      {a}
                      {isScanned && <span style={{marginLeft:'auto', color:'#2196F3'}}>üëÅÔ∏è</span>}
                   </button>
                 )
               })}
             </div>
           </div>
           
           {/* Item Tooltip */}
           {showItemTooltip && tooltipItem && (
             <div 
               className="item-tooltip" 
               style={{
                 left: tooltipPosition.x,
                 top: tooltipPosition.y,
                 transform: 'translate(-50%, -100%)'
               }}
             >
               <h4>
                 <span style={{fontSize: 28}}>{tooltipItem.icon}</span>
                 {tooltipItem.name}
               </h4>
               <div className={`rarity-mini ${tooltipItem.rarity}`}>
                 {tooltipItem.rarity}
               </div>
               <p>{tooltipItem.description}</p>
               <div style={{fontSize: 11, color: 'var(--rtl-orange)', marginTop: 10, fontWeight: 700}}>
                 {tooltipItem.needsTarget ? 'üéØ Ben√∂tigt Ziel' : '‚ú® Auf dich selbst'}
               </div>
             </div>
           )}
           
           {targetModalOpen && selectedItem && (
               <div className="modal-backdrop">
                   <div className="modal-card">
                       <h3>{selectedItem.name} - Ziel w√§hlen</h3>
                       <div style={{display:'flex',flexDirection:'column',gap:10, marginTop:20}}>
                         {Object.entries(game.players || {})
                           .filter(([pid]) => pid !== playerId)
                           .map(([pid, p]) => (
                            <button key={pid} className="btn btn-host" onClick={()=>activateItem(selectedItem, selectedItem.slotIndex, pid)}>
                              {p.name}
                            </button>
                         ))}
                         <button className="btn" style={{background:'rgba(255,255,255,0.1)'}} onClick={()=>{setTargetModalOpen(false); setSelectedItem(null); setIsActivatingItem(false);}}>Abbrechen</button>
                       </div>
                   </div>
               </div>
           )}
         </div>
       );
    }
    
    if(meta.phase === 'roundSummary') {
        // Check if this player is the category chooser
        if(meta.categoryChooserCandidate === playerId && !meta.nextCategory) {
            const used = meta.categoryState?.used || [];
            const available = CATEGORY_LIST.filter(c => !used.includes(c));
            const displayCats = available.length > 0 ? available : CATEGORY_LIST;
            
            return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="card" style={{width:'100%'}}>
                        <h3 style={{textAlign:'center', marginBottom:20, fontSize:24, fontWeight:900, color:'var(--rtl-orange)'}}>DU W√ÑHLST DIE KATEGORIE</h3>
                        <p style={{textAlign:'center', marginBottom:20, color:'var(--muted)'}}>Als Letztplatzierter darfst du die n√§chste Kategorie bestimmen.</p>
                        <div style={{display:'flex', flexDirection:'column', gap:10}}>
                            {displayCats.slice(0, 3).map(c => (<button key={c} className="btn btn-host" style={{padding:20}} onClick={()=>pickCategory(c)}>{c}</button>))}
                            <button className="btn" style={{padding:20}} onClick={()=>pickCategory(displayCats[0])}>ZUFALL</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        // Not the chooser - show waiting screen
        return (
            <div className="min-h-screen flex items-center justify-center p-4">
                <div className="card" style={{textAlign:'center'}}>
                    <h2 style={{fontSize:28, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20}}>ZWISCHENSTAND</h2>
                    <p style={{fontSize:18, color:'var(--muted)'}}>Warte auf Kategoriewahl...</p>
                    <div style={{marginTop:30, padding:20, background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                        <div style={{fontSize:16, color:'var(--muted)', marginBottom:10}}>Dein Score</div>
                        <div style={{fontSize:48, fontWeight:900}}>{player.score}</div>
                    </div>
                </div>
            </div>
        );
    }

    if(meta.phase === 'finished') {
      return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="card" style={{textAlign:'center'}}>
            <h2 style={{fontSize:32, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20}}>SPIEL BEENDET</h2>
            <p style={{fontSize:18, color:'var(--muted)'}}>Danke f√ºrs Spielen</p>
            <div style={{marginTop:30, padding:20, background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                <div style={{fontSize:16, color:'var(--muted)', marginBottom:10}}>Dein Endergebnis</div>
                <div style={{fontSize:48, fontWeight:900}}>{player.score} Punkte</div>
            </div>
          </div>
        </div>
      );
    }

    if(meta.phase === 'results') {
        const pointsEarned = player.lastPoints || 0;
        const isCorrect = player.currentAnswer===((game.questions||[])[meta.questionIndex||0]).correct;
        
        if (!playerReveal) {
             return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="card" style={{textAlign:'center', width:'100%'}}>
                        <h2 style={{fontSize:32, fontWeight:900, color: 'var(--rtl-orange)', marginBottom:20}}>ANTWORT ERFASST</h2>
                        <div style={{fontSize:20, color:'var(--muted)'}}>Warte auf die offizielle Aufl√∂sung durch den Host...</div>
                    </div>
                </div>
            );
        }

        return (
            <>
              <div className="min-h-screen flex items-center justify-center p-4" style={{background:'var(--bg)'}}>
                  <div className="card" style={{textAlign:'center', width:'100%'}}>
                      <div style={{display:'flex', justifyContent:'flex-end', borderBottom:'1px solid rgba(255,255,255,0.1)', paddingBottom:10, marginBottom:20}}>
                           <span style={{fontWeight:900, color:'var(--tile)'}}>Gesamt: {player.score}</span>
                      </div>

                      <div style={{fontSize:80, marginBottom:10}}>{isCorrect ? 'üòé' : 'ü´§'}</div>
                      <h2 style={{fontSize:32, fontWeight:900, color: 'var(--rtl-orange)', marginBottom:20}}>
                          {isCorrect ? 'RICHTIG' : 'FALSCH'}
                      </h2>
                      <div style={{background:'rgba(255,255,255,0.05)', padding:30, border:'1px solid rgba(255,255,255,0.1)'}}>
                          <div style={{fontSize:16, color:'var(--muted)', textTransform:'uppercase', fontWeight:700}}>Punkte diese Runde</div>
                          <div style={{fontSize:60, fontWeight:900, color:'white', lineHeight:1}}>
                              {pointsEarned > 0 ? '+' : ''}{pointsEarned}
                          </div>
                      </div>
                      <div style={{marginTop:30, fontSize:14, color:'var(--muted)'}}>Warte auf n√§chste Frage...</div>
                  </div>
              </div>

              {/* Item Box Roulette Animation */}
              {showItemRoulette && (
                <div className="item-roulette-overlay">
                  <div className="item-box-container">
                    <div className="item-box-text">
                      {roulettePhase === 'revealed' ? 'NEUES ITEM' : 'ITEM BOX'}
                    </div>
                    
                    <div className="item-box-display">
                      {roulettePhase === 'revealed' ? (
                        <div className="item-revealed" style={{fontSize: 100}}>
                          {finalRouletteItem?.icon}
                        </div>
                      ) : (
                        <div className={`item-roulette-strip ${roulettePhase}`}>
                          {rouletteItems.map((item, idx) => (
                            <div key={item.key || idx} className={`roulette-item ${item.isMystery ? 'mystery' : ''}`}>
                              {item.icon}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>

                    {roulettePhase === 'revealed' && (
                      <div className="item-box-info">
                        <h3>{finalRouletteItem?.name}</h3>
                        <div className={`rarity-badge ${finalRouletteItem?.rarity}`}>
                          {finalRouletteItem?.rarity.toUpperCase()}
                        </div>
                        <p style={{marginBottom: 20}}>{finalRouletteItem?.description}</p>
                        <button 
                          className="btn btn-host" 
                          onClick={closeItemRoulette}
                          style={{fontSize: 18, padding: '15px 40px'}}
                        >
                          VERSTANDEN
                        </button>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </>
        );
    }

    return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><div style={{color:'var(--muted)'}}>Warte auf Host...</div></div></div>;
  }

  // Items Info Modal Component
  function ItemsInfoModal({ onClose }) {
    const categories = {
      'Offensive Items': ['GIFTPFEIL', 'FREEZE', 'ZEITSCHNAPPER'],
      'Defensive Items': ['SCHILD', 'SPIEGELGLAS'],
      'Boost Items': ['TURBO', 'MAGNET', 'ZAPFER'],
      'Chaos Items': ['PLATZTAUSCHER', 'SCANNER']
    };

    return (
      <div className="items-info-modal" onClick={onClose}>
        <div className="items-info-content" onClick={(e) => e.stopPropagation()}>
          <h2>Alle Items</h2>
          
          {Object.entries(categories).map(([category, itemIds]) => (
            <div key={category}>
              <h3 style={{fontSize: 20, fontWeight: 900, color: 'var(--rtl-orange)', marginTop: 25, marginBottom: 15}}>
                {category}
              </h3>
              {itemIds.map(itemId => {
                const item = ITEM_TYPES[itemId];
                return (
                  <div key={item.id} className={`item-info-card ${item.rarity}`}>
                    <h4>
                      <span style={{fontSize: 28}}>{item.icon}</span>
                      {item.name}
                      <span className={`rarity-mini ${item.rarity}`} style={{marginLeft: 'auto', fontSize: 10}}>
                        {item.rarity.toUpperCase()}
                      </span>
                    </h4>
                    <p>{item.description}</p>
                    <p style={{fontSize: 12, marginTop: 5, color: item.needsTarget ? '#ff9800' : '#4caf50'}}>
                      {item.needsTarget ? 'Ben√∂tigt Ziel' : 'Auf dich selbst'}
                    </p>
                  </div>
                );
              })}
            </div>
          ))}

          <button 
            className="btn btn-host w-full" 
            onClick={onClose}
            style={{marginTop: 30, fontSize: 18, padding: '15px'}}
          >
            SCHLIESSEN
          </button>
        </div>
      </div>
    );
  }

  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');
    
    const handleJoin = async ()=>{
      if(!name) return;
      const snap = await db.ref(`games/${joinGameId}`).get();
      if(!snap.exists()) return alert('Code falsch');
      const pid = makePlayerId();
      await db.ref(`games/${joinGameId}/players/${pid}`).set({ name, score:0, itemSlots:[] });
      onJoined(joinGameId, pid, name);
    };

    return (
      <div className="min-h-screen flex flex-col items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div style={{marginBottom: 40, display:'flex', flexDirection:'column', alignItems:'center'}}>
            <RTLLogo size="md" />
            <h1 style={{marginTop:15, fontSize:24, fontWeight:900, color:'var(--tile)', letterSpacing:1}}>AdAlliance Quiz</h1>
        </div>
        <div className="card" style={{width:'100%', maxWidth:400, textAlign:'center'}}>
          <h2 style={{fontSize:20, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20, textTransform:'uppercase'}}>Spieler Login</h2>
          <div style={{marginBottom:20}}>
             <label style={{display:'block', textAlign:'left', marginBottom:8, fontSize:14, color:'var(--muted)', fontWeight:700}}>DEIN NAME</label>
             <input 
                value={name} 
                onChange={e=>setName(e.target.value)} 
                placeholder="z.B. Max Power" 
                className="w-full"
                maxLength={12}
             />
          </div>
          <button className="btn btn-host w-full" onClick={handleJoin} disabled={!name} style={{fontSize:20, padding:18}}>
            BEITRETEN ‚ñ∂
          </button>
        </div>
      </div>
    );
  }

  /****************************************
   * MAIN APP
   ****************************************/
  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');
    const [playerName,setPlayerName] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ 
        const savedPid = sessionStorage.getItem(`quiz_pid_${joinCode}`);
        if(savedPid) {
          db.ref(`games/${joinCode}/players/${savedPid}`).once('value', snap => {
            if(snap.exists()) { setGameId(joinCode); setPlayerId(savedPid); setPlayerName(snap.val().name); setMode('playerGame'); }
            else { setMode('playerJoin'); setGameId(joinCode); }
          });
        } else { setMode('playerJoin'); setGameId(joinCode); }
      }
    },[]);

    const handleCreate = async (name)=>{ const gid = randomGameID(); setGameId(gid); await db.ref(`games/${gid}/meta`).set({ phase: 'lobby', finaleEnabled: true }); setMode('hostLobby'); };
    
    const handleJoin = async (name, code)=>{
        try {
            const snap = await db.ref(`games/${code}`).get();
            if(!snap.exists()) { alert('Spiel nicht gefunden!'); return; }
            const pid = makePlayerId();
            await db.ref(`games/${code}/players/${pid}`).set({ name, score: 0, itemSlots: [] });
            sessionStorage.setItem(`quiz_pid_${code}`, pid);
            setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame');
        } catch(e) { console.error(e); alert('Fehler beim Beitreten'); }
    };
    
    const handlePlayerJoined = (code,pid,name) => { sessionStorage.setItem(`quiz_pid_${code}`, pid); setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} hostName={playerName} />}
        {mode === 'playerGame' && (
          <>
            <PlayerView gameId={gameId} playerId={playerId} />
            {/* Items Info Modal - accessible from any player view */}
          </>
        )}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>
