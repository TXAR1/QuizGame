<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multiplayer Quiz (Host & Smartphones)</title>

  <!-- React + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    html,body,#root { height: 100%; }
    /* Host full-screen styles for large display */
    .host-screen {
      display:flex;
      flex-direction:row;
      gap:24px;
      align-items:stretch;
      height:100%;
      padding:24px;
      box-sizing:border-box;
    }
    .host-main {
      flex:2;
      background:rgba(255,255,255,0.06);
      border-radius:12px;
      padding:28px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
    }
    .host-side {
      flex:1;
      background:rgba(255,255,255,0.04);
      border-radius:12px;
      padding:18px;
      overflow:auto;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-800 to-purple-700 text-white">
  <div id="root" class="h-full"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 10;
  const QUESTION_TIME = 40; // Sekunden

  // --- Firebase Config: ERSETZE MIT DEINEN WERTEN ---
  const firebaseConfig = {
    apiKey: "DEIN_API_KEY_HIER",
    authDomain: "deinprojekt.firebaseapp.com",
    databaseURL: "https://deinprojekt-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "deinprojekt",
    storageBucket: "deinprojekt.appspot.com",
    messagingSenderId: "123456789",
    appId: "1:123456789:web:abcdef123456"
  };
  /********** END CONFIG **********/

  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Pool mit Fragen (mindestens 40 sinnvoll). Erweitere bei Bedarf.
  const QUESTION_POOL = [
    { question: "Was ist die Hauptstadt von Ã–sterreich?", answers: ["Wien","Graz","Salzburg","Innsbruck"], correct: 0 },
    { question: "Welcher Planet ist der grÃ¶ÃŸte?", answers: ["Mars","Saturn","Jupiter","Neptun"], correct: 2 },
    { question: "Wer malte die Mona Lisa?", answers: ["Picasso","Van Gogh","Da Vinci","Monet"], correct: 2 },
    { question: "In welchem Jahr fiel die Berliner Mauer?", answers: ["1987","1989","1991","1993"], correct: 1 },
    { question: "Was ist die chemische Formel fÃ¼r Wasser?", answers: ["CO2","H2O","O2","NaCl"], correct: 1 },
    { question: "Welches ist der lÃ¤ngste Fluss der Welt?", answers: ["Nil","Amazonas","Yangtze","Mississippi"], correct: 0 },
    { question: "Wie viele Kontinente gibt es?", answers: ["5","6","7","8"], correct: 2 },
    { question: "Welches Tier ist das schnellste an Land?", answers: ["LÃ¶we","Gepard","Antilope","Pferd"], correct: 1 },
    { question: "Wer schrieb 'Romeo und Julia'?", answers: ["Goethe","Shakespeare","Schiller","Kafka"], correct: 1 },
    { question: "Welches ist das grÃ¶ÃŸte SÃ¤ugetier?", answers: ["Elefant","Blauwal","Giraffe","Nilpferd"], correct: 1 },
    { question: "In welchem Land steht der Eiffelturm?", answers: ["Italien","Spanien","Frankreich","Deutschland"], correct: 2 },
    { question: "Was ist 7 x 8?", answers: ["54","56","58","64"], correct: 1 },
    { question: "Welche Farbe hat ein Smaragd?", answers: ["Rot","Blau","GrÃ¼n","Gelb"], correct: 2 },
    { question: "Wie heiÃŸt die Hauptstadt von Deutschland?", answers: ["MÃ¼nchen","Hamburg","Berlin","KÃ¶ln"], correct: 2 },
    { question: "Welcher Ozean ist der grÃ¶ÃŸte?", answers: ["Atlantik","Indischer","Pazifik","Arktis"], correct: 2 },
    { question: "Wie viele Beine hat eine Spinne?", answers: ["6","8","10","12"], correct: 1 },
    { question: "Was ist die Hauptstadt der USA?", answers: ["New York","Los Angeles","Chicago","Washington D.C."], correct: 3 },
    { question: "Welches Instrument hat 88 Tasten?", answers: ["Gitarre","Klavier","Orgel","Keyboard"], correct: 1 },
    { question: "In welcher Stadt steht die Freiheitsstatue?", answers: ["Boston","New York","Chicago","Miami"], correct: 1 },
    { question: "Wie viele Seiten hat ein WÃ¼rfel?", answers: ["4","6","8","10"], correct: 1 },
    { question: "Welches Gas atmen wir ein?", answers: ["Sauerstoff","Stickstoff","Kohlendioxid","Helium"], correct: 0 },
    { question: "Wie heiÃŸt der hÃ¶chste Berg der Welt?", answers: ["K2","Mount Everest","Kilimandscharo","Mont Blanc"], correct: 1 },
    { question: "Welcher Planet ist der Erde am nÃ¤chsten?", answers: ["Mars","Venus","Merkur","Jupiter"], correct: 1 },
    { question: "Wie viele BundeslÃ¤nder hat Ã–sterreich?", answers: ["7","9","11","13"], correct: 1 },
    { question: "Was ist die Quadratwurzel von 64?", answers: ["6","8","10","12"], correct: 1 },
    { question: "Welches Tier legt Eier?", answers: ["Katze","Hund","Huhn","Kuh"], correct: 2 },
    { question: "Wie viele Minuten hat eine Stunde?", answers: ["30","45","60","90"], correct: 2 },
    { question: "Welche Farbe entsteht aus Rot und Gelb?", answers: ["GrÃ¼n","Orange","Lila","Braun"], correct: 1 },
    { question: "In welchem Jahr begann das 21. Jahrhundert?", answers: ["1999","2000","2001","2002"], correct: 2 },
    { question: "Wie heiÃŸt die Hauptstadt von Spanien?", answers: ["Barcelona","Madrid","Valencia","Sevilla"], correct: 1 },
    { question: "Welches Element hat das Symbol 'Au'?", answers: ["Silber","Gold","Kupfer","Eisen"], correct: 1 },
    { question: "Welcher Fluss flieÃŸt durch London?", answers: ["Seine","Donau","Themse","Rhein"], correct: 2 },
    { question: "Was ist die kleinste Primzahl?", answers: ["0","1","2","3"], correct: 2 },
    { question: "Welches Land hat die meisten Einwohner?", answers: ["Indien","China","USA","Indonesien"], correct: 1 },
    { question: "Wie viele Spieler hat eine FuÃŸballmannschaft auf dem Feld?", answers: ["9","10","11","12"], correct: 2 },
    { question: "Welche Sprache wird in Brasilien gesprochen?", answers: ["Spanisch","Portugiesisch","FranzÃ¶sisch","Englisch"], correct: 1 },
    { question: "Wie heiÃŸt das chemische Symbol fÃ¼r Wasserstoff?", answers: ["H","He","O","W"], correct: 0 },
    { question: "Was ist die Hauptstadt von Frankreich?", answers: ["Paris","Lyon","Marseille","Bordeaux"], correct: 0 },
    { question: "Wie viele Tage hat ein Schaltjahr?", answers: ["365","366","364","367"], correct: 1 },
    { question: "Was ist 12 Ã— 12?", answers: ["144","124","132","156"], correct: 0 },
  ];

  // Hilfsfunktionen
  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function generateQuestions() {
    const needed = TOTAL_ROUNDS * QUESTIONS_PER_ROUND;
    let pool = [...QUESTION_POOL];
    while (pool.length < needed) pool = pool.concat(QUESTION_POOL);
    pool = shuffle(pool).slice(0, needed).map((q, idx) => ({ id: idx, ...q }));
    return pool;
  }

  function randomGameID() {
    return Math.random().toString(36).substr(2,6).toUpperCase();
  }

  function makePlayerId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2,4);
  }

  // QuickChart QR URL
  function qrUrlForGame(gameId) {
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=300`;
  }

  /************ Components ************/

  // START SCREEN
  function StartScreen({ onCreate, onJoin }) {
    const [name, setName] = useState('');
    const [code, setCode] = useState('');

    return (
      <div className="min-h-screen flex items-center justify-center px-6">
        <div className="max-w-2xl w-full bg-white/5 p-6 rounded-xl">
          <h1 className="text-4xl font-bold mb-4">ðŸŽ¯ Multiplayer Quiz</h1>
          <p className="text-sm mb-4">Host erstellt Spiel (Quizmaster) oder Spieler treten per Code/QR bei.</p>

          <input className="w-full p-3 rounded mb-3 text-black" placeholder="Dein Name (wird im Spiel angezeigt)" value={name} onChange={e => setName(e.target.value)} />

          <div className="flex gap-3 mb-3">
            <button className="flex-1 bg-green-500 hover:bg-green-600 px-4 py-3 rounded font-bold disabled:opacity-60" disabled={!name} onClick={() => onCreate(name)}>Neues Spiel (Host)</button>
            <input className="w-40 p-2 rounded text-black" placeholder="Spielcode" value={code} onChange={e => setCode(e.target.value.toUpperCase())} />
            <button className="bg-blue-500 hover:bg-blue-600 px-3 py-3 rounded font-bold disabled:opacity-60" disabled={!name || !code} onClick={() => onJoin(name, code)}>Beitreten</button>
          </div>

          <p className="text-xs text-white/70">HINWEIS: Host ist nur Quizmaster und wird nicht als Spieler gezÃ¤hlt.</p>
        </div>
      </div>
    );
  }

  // HOST LOBBY (vor Start) - zeigt QR, Spieler, Start-Button
  function HostLobby({ gameId, hostName }) {
    const [players, setPlayers] = useState({});
    useEffect(() => {
      const ref = db.ref(`games/${gameId}/players`);
      ref.on('value', snap => setPlayers(snap.val() || {}));
      return () => ref.off();
    }, [gameId]);

    return (
      <div className="min-h-screen host-screen">
        <div className="host-main">
          <h2 className="text-4xl font-bold mb-4">Quizmaster: {hostName}</h2>
          <div className="mb-4">
            <div className="text-xl mb-2">Spielcode: <span className="font-mono bg-white text-black px-3 py-1 rounded ml-2">{gameId}</span></div>
            <img src={qrUrlForGame(gameId)} alt="QR zum Joinen" className="mx-auto rounded-md shadow-md mb-3" />
            <div className="text-sm">Scanner den QR-Code mit dem Smartphone oder Ã¶ffne: <span className="underline">{window.location.origin + window.location.pathname}?join={gameId}</span></div>
          </div>

          <div className="mt-auto text-sm text-white/80">Sobald genug Spieler da sind, starte das Spiel Rechts.</div>
        </div>

        <div className="host-side">
          <h3 className="text-xl font-bold mb-2">Aktive Spieler</h3>
          <div className="space-y-2">
            {Object.entries(players).length === 0 && <div className="text-sm text-white/70">Keine Spieler</div>}
            {Object.entries(players).map(([pid,p]) => (
              <div key={pid} className="flex justify-between items-center bg-white/5 p-2 rounded">
                <div>{p.name}</div>
                <div className="text-sm">{p.score || 0} pts</div>
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  // HOST CONTROLLER (kleine Steuerleiste; in HostScreen auch groÃŸ sichtbar)
  function HostController({ gameId }) {
    const [meta, setMeta] = useState(null);
    const [players, setPlayers] = useState({});
    useEffect(() => {
      const ref = db.ref(`games/${gameId}/meta`);
      ref.on('value', snap => setMeta(snap.val()));
      const p = db.ref(`games/${gameId}/players`);
      p.on('value', snap => setPlayers(snap.val() || {}));
      return () => { ref.off(); p.off(); };
    }, [gameId]);

    // start game: write questions + meta
// --- alte Funktion startGame ersetzt durch diese ---
const startGame = async () => {
  const questions = generateQuestions();
  const metaObj = {
    phase: 'question',
    questionIndex: 0,
    round: 1,
    questionStartTime: Date.now(),
    nextQuestionIndex: null
  };
  await db.ref(`games/${gameId}/questions`).set(questions);
  // Spieler ggf. resetten (auch wenn es keine gibt)
  const pSnap = await db.ref(`games/${gameId}/players`).get();
  const pObj = pSnap.val() || {};
  const updates = {};
  Object.keys(pObj).forEach(pid => {
    updates[`games/${gameId}/players/${pid}/score`] = 0;
    updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
  });
  await db.ref().update(updates);
  await db.ref(`games/${gameId}/meta`).set(metaObj);
};

    // compute results (host triggers) -> update scores and set phase results
    const showResultsNow = async () => {
      try {
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if (!g) return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if (!q) return;
        const playerObj = g.players || {};
        const updates = {};
        Object.entries(playerObj).forEach(([pid,p]) => {
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          const newScore = (p.score || 0) + (correct ? 100 : 0);
          updates[`games/${gameId}/players/${pid}/score`] = newScore;
        });
        await db.ref().update(updates);
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });
      } catch (err) { console.error(err); }
    };

    // Next Question or RoundSummary
    const nextQuestion = async () => {
      const snap = await db.ref(`games/${gameId}/meta`).get();
      const metaVal = snap.val();
      const cur = metaVal?.questionIndex || 0;
      const next = cur + 1;
      const isGameEnd = next >= TOTAL_ROUNDS * QUESTIONS_PER_ROUND;
      const isEndOfRound = (cur + 1) % QUESTIONS_PER_ROUND === 0;

      if (isGameEnd) {
        // game finished
        await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
      } else if (isEndOfRound) {
        // show round summary: set nextQuestionIndex for later and go to roundSummary
        await db.ref(`games/${gameId}/meta`).update({ phase: 'roundSummary', nextQuestionIndex: next });
      } else {
        // continue with next question
        // reset players currentAnswer to null
        const pSnap = await db.ref(`games/${gameId}/players`).get();
        const pObj = pSnap.val() || {};
        const updates = {};
        Object.keys(pObj).forEach(pid => updates[`games/${gameId}/players/${pid}/currentAnswer`] = null);
        await db.ref().update(updates);
        await db.ref(`games/${gameId}/meta`).update({
          questionIndex: next,
          phase: 'question',
          questionStartTime: Date.now(),
          round: Math.floor(next / QUESTIONS_PER_ROUND) + 1
        });
      }
    };

    // Start the next round after roundSummary
    const startNextRound = async () => {
      const snap = await db.ref(`games/${gameId}/meta`).get();
      const metaVal = snap.val();
      const nextIndex = metaVal?.nextQuestionIndex ?? (metaVal?.questionIndex ?? 0);
      const round = Math.floor(nextIndex / QUESTIONS_PER_ROUND) + 1;
      // reset answers
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid => updates[`games/${gameId}/players/${pid}/currentAnswer`] = null);
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({
        questionIndex: nextIndex,
        phase: 'question',
        questionStartTime: Date.now(),
        round: round,
        nextQuestionIndex: null
      });
    };

    if (!meta) {
      return <div className="text-center p-3">Warten auf Spielmeta...</div>;
    }

    const isLobby = meta.phase === 'lobby' || !meta.phase;
    return (
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <div>
            <div className="text-sm">Phase: <strong>{meta.phase}</strong></div>
            <div className="text-sm">Runde: <strong>{meta.round || 1}/{TOTAL_ROUNDS}</strong></div>
            <div className="text-sm">Frage: <strong>{(meta.questionIndex || 0) + 1}/{TOTAL_ROUNDS * QUESTIONS_PER_ROUND}</strong></div>
          </div>
          <div className="text-right">
            <div className="text-xs text-white/80">Spieler: {Object.keys(players).length}</div>
          </div>
        </div>

        <div className="flex gap-2">
          { (meta.phase === 'lobby' || !meta.phase) && <button className="bg-green-500 px-4 py-2 rounded" onClick={startGame}>Spiel starten</button> }
          { meta.phase === 'question' && <button className="bg-yellow-500 px-4 py-2 rounded" onClick={showResultsNow}>Ergebnisse anzeigen</button> }
          { meta.phase === 'results' && <button className="bg-blue-600 px-4 py-2 rounded" onClick={nextQuestion}>NÃ¤chste Frage</button> }
          { meta.phase === 'roundSummary' && <button className="bg-blue-600 px-4 py-2 rounded" onClick={startNextRound}>NÃ¤chste Runde starten</button> }
          { meta.phase === 'finished' && <div className="text-green-300 font-bold px-3 py-2 rounded">Spiel beendet</div> }
        </div>
      </div>
    );
  }

  // HOST FULLSCREEN VIEW (groÃŸes Panel fÃ¼r TV/Beamer)
  function HostScreen({ gameId, hostName }) {
    const [game, setGame] = useState(null);
    const [meta, setMeta] = useState(null);
    const [timeLeft, setTimeLeft] = useState(0);
    const timerRef = useRef(null);

    useEffect(() => {
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      return () => { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    }, [gameId]);

    useEffect(() => {
      if (!meta || meta.phase !== 'question' || !meta.questionStartTime) { setTimeLeft(0); return; }
      const tick = () => {
        const elapsed = Math.floor((Date.now() - meta.questionStartTime) / 1000);
        const rem = Math.max(0, QUESTION_TIME - elapsed);
        setTimeLeft(rem);
        if (rem <= 0) {
          // nothing here â€” hostController will call showResultsNow via timer on his side if desired
          // We do not auto-trigger DB changes here to avoid race conditions; host should press "Ergebnisse anzeigen" or hostController already handles auto in earlier version
        }
      };
      tick();
      clearInterval(timerRef.current);
      timerRef.current = setInterval(tick, 500);
      return () => clearInterval(timerRef.current);
    }, [meta?.phase, meta?.questionStartTime]);

    if (!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];

    const playersArr = Object.entries(game.players || {}).map(([pid,p]) => ({ pid, ...p })).sort((a,b) => (b.score || 0) - (a.score || 0));

    return (
      <div className="min-h-screen host-screen">
        <div className="host-main">
          <div style={{width:'100%'}}>
            <div className="text-left mb-4 text-sm text-white/80">Quizmaster: <strong>{hostName}</strong></div>
            { meta.phase === 'lobby' && (
              <div>
                <h2 className="text-5xl font-bold mb-2">Warte auf Spieler</h2>
                <p className="text-xl">Spielcode: <span className="font-mono bg-white text-black px-3 py-1 rounded">{gameId}</span></p>
              </div>
            )}

            { meta.phase === 'question' && question && (
              <div>
                <div className="text-6xl font-extrabold mb-6">{question.question}</div>
                <div className="flex items-center justify-center gap-6">
                  <div className="text-7xl font-bold">{timeLeft}s</div>
                </div>
                <div className="mt-8 grid grid-cols-2 gap-4">
                  {question.answers.map((a,i) => <div key={i} className="bg-white/6 p-4 rounded text-xl font-semibold">{String.fromCharCode(65+i)}. {a}</div>)}
                </div>
              </div>
            )}

            { meta.phase === 'results' && question && (
              <div>
                <div className="text-5xl font-bold mb-4">Ergebnisse</div>
                <div className="text-3xl mb-6">Richtige Antwort: <strong>{question.answers[question.correct]}</strong></div>
                <div className="grid grid-cols-2 gap-3">
                  {question.answers.map((a,i) => {
                    const voters = playersArr.filter(p => p.currentAnswer === i).map(p => p.name).join(', ');
                    const isCorrect = i === question.correct;
                    return (
                      <div key={i} className={`p-4 rounded ${isCorrect ? 'bg-green-600' : 'bg-white/6'}`}>
                        <div className="text-xl font-bold">{String.fromCharCode(65+i)}. {a}</div>
                        <div className="mt-2 text-sm">Antworten: {voters || 'Niemand'}</div>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            { meta.phase === 'roundSummary' && (
              <div>
                <h2 className="text-5xl font-bold mb-4">Zwischenstand - Runde {meta.round}</h2>
                <div className="max-h-96 overflow-auto">
                  {playersArr.map((p,i) => (
                    <div key={p.pid} className="flex justify-between items-center bg-white/5 p-3 rounded mb-2">
                      <div className="text-2xl font-bold">{i+1}. {p.name}</div>
                      <div className="text-2xl font-extrabold">{p.score || 0} pts</div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            { meta.phase === 'finished' && (
              <div>
                <h2 className="text-6xl font-bold mb-6">Spiel beendet</h2>
                <div className="max-h-96 overflow-auto">
                  {playersArr.map((p,i) => (
                    <div key={p.pid} className="flex justify-between items-center bg-white/5 p-3 rounded mb-2">
                      <div className="text-2xl font-bold">{i+1}. {p.name}</div>
                      <div className="text-2xl font-extrabold">{p.score || 0} pts</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>

        <div className="host-side">
          <div className="mb-4">
            <HostController gameId={gameId} />
          </div>

          <div className="mb-4">
            <h3 className="text-xl font-bold mb-2">Spieler & Punkte</h3>
            <div className="space-y-2 max-h-72 overflow-auto">
              {playersArr.map(p => (
                <div key={p.pid} className="flex justify-between items-center bg-white/5 p-2 rounded">
                  <div>{p.name}</div>
                  <div className="text-sm">{p.score || 0} pts</div>
                </div>
              ))}
            </div>
          </div>

          <div className="mb-4">
            <h3 className="text-lg font-bold mb-2">Spiel Info</h3>
            <div className="text-sm">Code: <span className="font-mono bg-white text-black px-2 py-1 rounded">{gameId}</span></div>
            <div className="text-xs mt-2">QR-Code zum Scannen:</div>
            <img src={qrUrlForGame(gameId)} alt="QR Code" className="mt-2 rounded" />
          </div>

          <div>
            <h3 className="text-lg font-bold mb-2">Kurz-Anleitung</h3>
            <ol className="text-sm list-decimal list-inside space-y-1">
              <li>Spieler scannen QR oder geben Code ein.</li>
              <li>Wenn Frage startet: 40s Zeit zum Antworten.</li>
              <li>Host zeigt Ergebnisse, dann "NÃ¤chste Frage".</li>
              <li>Am Ende jeder Runde: Host zeigt Zwischenstand.</li>
            </ol>
          </div>
        </div>
      </div>
    );
  }

  // PLAYER VIEW (Smartphone)
  function PlayerView({ gameId, playerId }) {
    const [game, setGame] = useState(null);
    const [meta, setMeta] = useState(null);
    const [player, setPlayer] = useState(null);
    const [timeLeft, setTimeLeft] = useState(0);

    useEffect(() => {
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return () => { gRef.off(); mRef.off(); pRef.off(); };
    }, [gameId, playerId]);

    useEffect(() => {
      if (!meta || meta.phase !== 'question' || !meta.questionStartTime) { setTimeLeft(0); return; }
      const tick = () => {
        const elapsed = Math.floor((Date.now() - meta.questionStartTime) / 1000);
        setTimeLeft(Math.max(0, QUESTION_TIME - elapsed));
      };
      tick();
      const t = setInterval(tick, 500);
      return () => clearInterval(t);
    }, [meta?.questionStartTime, meta?.phase]);

    if (!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];

    if (meta.phase === 'lobby') {
      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="bg-white/5 p-6 rounded w-full max-w-md text-center">
            <h2 className="text-2xl font-bold mb-2">Warte auf Start</h2>
            <p className="mb-2">Spielcode: <span className="font-mono bg-white text-black px-2 py-1 rounded">{gameId}</span></p>
            <p className="text-sm">Bitte warte, bis der Host das Spiel startet.</p>
            <p className="text-sm mt-3">Dein Name: <strong>{player.name}</strong></p>
          </div>
        </div>
      );
    }

    if (meta.phase === 'question' && question) {
      const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="bg-white/5 p-6 rounded w-full max-w-md">
            <div className="flex justify-between items-center mb-4">
              <div>Runde {meta.round}/{TOTAL_ROUNDS}</div>
              <div className="text-lg font-bold">{timeLeft}s</div>
            </div>
            <h3 className="text-xl font-bold mb-4">{question.question}</h3>

            <div className="grid gap-3">
              {question.answers.map((ans,i) => {
                const disabled = hasAnswered || timeLeft <= 0;
                const isSelected = player.currentAnswer === i;
                return (
                  <button
                    key={i}
                    disabled={disabled}
                    onClick={() => db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i)}
                    className={`p-3 rounded font-bold text-left ${disabled ? (isSelected ? 'bg-green-500 text-white' : 'bg-white/10 text-white/80') : 'bg-blue-500 hover:bg-blue-600 text-white'}`}
                  >
                    {String.fromCharCode(65+i)}. {ans}
                  </button>
                );
              })}
            </div>

            <div className="mt-4 text-sm">
              {player.currentAnswer === null ? "Noch nicht geantwortet" : `Du hast Antwort ${player.currentAnswer + 1} gewÃ¤hlt`}
            </div>
            <div className="mt-4 text-sm">Punkte: <strong>{player.score || 0}</strong></div>
          </div>
        </div>
      );
    }

    if (meta.phase === 'results' && question) {
      const wasCorrect = player.currentAnswer === question.correct;
      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="bg-white/5 p-6 rounded w-full max-w-md text-center">
            <h3 className="text-3xl font-bold mb-3">{wasCorrect ? 'Richtig! ðŸŽ‰' : 'Falsch ðŸ˜•'}</h3>
            <p className="mb-2">Richtige Antwort: <strong>{question.answers[question.correct]}</strong></p>
            <p className="mb-2">Dein Punktestand: <strong>{player.score || 0}</strong></p>
            <p className="text-sm">Warte auf den Host fÃ¼r die nÃ¤chste Frage.</p>
          </div>
        </div>
      );
    }

    if (meta.phase === 'roundSummary') {
      const playersSorted = Object.values(game.players || {}).sort((a,b) => (b.score||0)-(a.score||0));
      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="bg-white/5 p-6 rounded w-full max-w-md">
            <h3 className="text-2xl font-bold mb-3">Zwischenstand Runde {meta.round}</h3>
            <div className="bg-white/10 p-3 rounded mb-3">
              {playersSorted.map((p,i) => <div key={i} className="flex justify-between py-1">{i+1}. {p.name} <span>{p.score||0} pts</span></div>)}
            </div>
            <p className="text-sm">Host startet die nÃ¤chste Runde, sobald er bereit ist.</p>
          </div>
        </div>
      );
    }

    if (meta.phase === 'finished') {
      const playersSorted = Object.values(game.players || {}).sort((a,b) => (b.score||0)-(a.score||0));
      return (
        <div className="min-h-screen flex items-center justify-center p-6">
          <div className="bg-white/5 p-6 rounded w-full max-w-md">
            <h3 className="text-3xl font-bold mb-3">Spiel beendet</h3>
            <div className="bg-white/10 p-3 rounded mb-3">
              {playersSorted.map((p,i) => <div key={i} className="flex justify-between py-1">{i+1}. {p.name} <span>{p.score||0} pts</span></div>)}
            </div>
          </div>
        </div>
      );
    }

    return <div>Warte...</div>;
  }

  // Player Join Screen when opening with ?join=CODE
  function PlayerJoin({ joinGameId, onJoined }) {
    const [name, setName] = useState('');
    const [error, setError] = useState('');

    const handleJoin = async () => {
      setError('');
      try {
        const snap = await db.ref(`games/${joinGameId}`).get();
        if (!snap.exists()) { setError('Spiel nicht gefunden'); return; }
        const pid = makePlayerId();
        const playerObj = { name, score: 0, currentAnswer: null, joinedAt: Date.now() };
        await db.ref(`games/${joinGameId}/players/${pid}`).set(playerObj);
        localStorage.setItem(`quiz_player_${joinGameId}`, pid);
        localStorage.setItem(`quiz_name_${joinGameId}`, name);
        onJoined(joinGameId, pid, name);
      } catch (err) { console.error(err); setError('Fehler beim Beitreten'); }
    };

    return (
      <div className="min-h-screen flex items-center justify-center p-6">
        <div className="bg-white/5 p-6 rounded w-full max-w-md">
          <h2 className="text-2xl font-bold mb-3">Spiel beitreten: {joinGameId}</h2>
          <input className="w-full p-3 rounded mb-3 text-black" placeholder="Dein Name" value={name} onChange={e => setName(e.target.value)} />
          <button className="bg-blue-500 px-4 py-3 rounded w-full font-bold" onClick={handleJoin} disabled={!name}>Beitreten</button>
          {error && <div className="text-red-300 mt-3">{error}</div>}
        </div>
      </div>
    );
  }

  /************ App (Single File) ************/
  function App() {
    const [mode, setMode] = useState('start'); // start | host-lobby | host-screen | player-join | player-play
    const [gameId, setGameId] = useState('');
    const [playerId, setPlayerId] = useState('');
    const [playerName, setPlayerName] = useState('');
    const [hostName, setHostName] = useState('');
    const [isHost, setIsHost] = useState(false);

    // on load: if ?join=code present -> go to player join
    useEffect(() => {
      const params = new URLSearchParams(window.location.search);
      const join = params.get('join');
      if (join) {
        setGameId(join.toUpperCase());
        setMode('player-join');
      }
    }, []);

    // Create Game (host) â€” host is NOT added as player
    const createGame = async (host) => {
      const id = randomGameID();
      const questions = generateQuestions();
      const meta = {
        phase: 'lobby',
        questionIndex: 0,
        round: 1,
        questionStartTime: null,
        nextQuestionIndex: null
      };
      const gameObj = { host, questions, meta, players: {} };
      await db.ref(`games/${id}`).set(gameObj);
      setGameId(id);
      setHostName(host);
      setIsHost(true);
      setMode('host-lobby');
    };

    // Join as player by code from start-screen
    const joinGameFromStart = async (name, id) => {
      const snap = await db.ref(`games/${id}`).get();
      if (!snap.exists()) { alert('Spiel nicht gefunden'); return; }
      const pid = makePlayerId();
      await db.ref(`games/${id}/players/${pid}`).set({ name, score: 0, currentAnswer: null, joinedAt: Date.now() });
      localStorage.setItem(`quiz_player_${id}`, pid);
      localStorage.setItem(`quiz_name_${id}`, name);
      setGameId(id);
      setPlayerId(pid);
      setPlayerName(name);
      setIsHost(false);
      setMode('player-play');
    };

    // After join via ?join=ID screen
    const onJoined = (id, pid, name) => {
      setGameId(id);
      setPlayerId(pid);
      setPlayerName(name);
      setIsHost(false);
      setMode('player-play');
    };

    // If user returns with localStorage for a given gameId from join link, auto-enter.
    useEffect(() => {
      if (mode !== 'player-join') return;
      if (!gameId) return;
      const storedPid = localStorage.getItem(`quiz_player_${gameId}`);
      const storedName = localStorage.getItem(`quiz_name_${gameId}`);
      if (storedPid && storedName) {
        // ensure player exists on server
        db.ref(`games/${gameId}/players/${storedPid}`).get().then(snap => {
          if (!snap.exists()) {
            db.ref(`games/${gameId}/players/${storedPid}`).set({ name: storedName, score: 0, currentAnswer: null, joinedAt: Date.now() });
          }
          setPlayerId(storedPid);
          setPlayerName(storedName);
          setMode('player-play');
        }).catch(err => console.error(err));
      }
    }, [mode, gameId]);

    // If host goes from lobby to playing, open host screen
    useEffect(() => {
      if (mode !== 'host-lobby') return;
      // watch meta phase to auto-show host-screen when meta.phase !== 'lobby'
      const ref = db.ref(`games/${gameId}/meta`);
      const handler = (snap) => {
        const val = snap.val();
        if (!val) return;
        if (val.phase && val.phase !== 'lobby') {
          setMode('host-screen');
        }
      };
      ref.on('value', handler);
      return () => ref.off('value', handler);
    }, [mode, gameId]);

    if (mode === 'start') {
      return <StartScreen onCreate={(host) => createGame(host)} onJoin={(name, code) => joinGameFromStart(name, code)} />;
    }

    if (mode === 'host-lobby') {
      return <HostLobby gameId={gameId} hostName={hostName} />;
    }

    if (mode === 'host-screen') {
      return <HostScreen gameId={gameId} hostName={hostName} />;
    }

    if (mode === 'player-join') {
      return <PlayerJoin joinGameId={gameId} onJoined={onJoined} />;
    }

    if (mode === 'player-play') {
      return <PlayerView gameId={gameId} playerId={playerId} />;
    }

    return <div>...</div>;
  }

  ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>


