<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Item Mayhem V10 (Fixed Finale)</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script src="https://cdn.tailwindcss.com"></script>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    :root{
      --rtl-orange:#FF6600;
      --rtl-purple:#7B2CBF;
      --bg:#0b0b0b;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
    }
    
    /* RESET */
    * { border-radius: 0px !important; box-sizing: border-box; }
    button, div, span, input, img { border-radius: 0px !important; }

    html,body,#root{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, sans-serif; overflow: hidden;}
    body{ background:linear-gradient(180deg,var(--bg), #090909); color:var(--tile); }
    
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: var(--rtl-orange); }

    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 12px; font-weight: 600; }
    
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight:900; padding:14px 28px; cursor:pointer; border:none; background:rgba(255,255,255,0.1); color:var(--tile); font-size:18px; transition: background 0.2s; text-transform: uppercase; letter-spacing: 1px; border: 1px solid rgba(255,255,255,0.1); }
    .btn:hover { background:rgba(255,255,255,0.25); }
    .btn:active { transform: translateY(2px); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }

    .btn-host{ background:var(--rtl-orange); color:white; border: 1px solid var(--rtl-orange); }
    .btn-host:hover { background: #ff7b24; }
    
    .btn-join{ background:var(--rtl-purple); color:white; border: 1px solid var(--rtl-purple); }
    
    .card{ padding:30px; background: #111; border:1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    
    .host-screen{ display:flex; width: 100%; height:100vh; overflow:hidden; position: relative; background: var(--bg); }
    .host-main{ flex:1; display:flex; flex-direction:column; height: 100%; position: relative; }
    
    .host-main-inner {
        padding: 40px;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at center, #1a1a1a 0%, #000000 120%);
    }

    .game-top-bar {
        display: flex; justify-content: space-between; align-items: center;
        padding: 20px 40px; background: #000; border-bottom: 2px solid rgba(255,255,255,0.08);
        height: 130px;
    }

    .countdown-badge{ width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:2.8rem; font-weight:900; color:var(--tile); border:4px solid rgba(255,255,255,0.15); background:#000; }
    .countdown-badge.warning{ border-color:var(--rtl-orange); color:var(--rtl-orange); }
    .countdown-badge.danger{ border-color:#ef4444; color:#ef4444; background: rgba(239,68,68,0.1); }
    
    .question-text { font-size: 5vh; font-weight: 900; line-height: 1.2; text-shadow: 0 4px 10px rgba(0,0,0,0.8); text-align: center; margin-bottom: 40px;}

    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:24px; flex: 1; }
    .answer-btn{ background: #e0e0e0; color:#0b0b0b; padding:20px; font-size:1.5rem; font-weight:800; height: 100%; display:flex; align-items: center; gap:24px; border: 4px solid transparent; transition: transform 0.1s; position: relative; overflow: hidden; }
    .answer-btn:hover { transform: translateY(-2px); background: #fff; }
    
    .results-split-view { display: grid; grid-template-columns: 4fr 3fr; gap: 40px; height: 100%; overflow: hidden; }
    .results-col { display: flex; flex-direction: column; gap: 16px; overflow: hidden; max-height: 100%; }
    .scroll-area { overflow-y: auto; padding-right: 8px; }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.95); display:flex; align-items:center; justify-content:center; z-index:9999; backdrop-filter: blur(5px); }
    .modal-card{ width:95%; max-width:600px; background:#000; border:3px solid var(--rtl-orange); padding:40px; color:var(--tile); box-shadow: 0 0 80px rgba(255,102,0,0.3); }
    
    /* Item Inventory Styles */
    .inventory-slot {
        width: 70px; height: 70px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
        display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative;
        transition: all 0.2s;
    }
    .inventory-slot.filled:hover { border-color: var(--rtl-orange); transform: scale(1.05); }
    .item-tag { padding: 4px 8px; font-size: 12px; font-weight: 900; text-transform: uppercase; }
    .rarity-common { color: #fff; border: 1px solid #fff; }
    .rarity-uncommon { color: #a3e635; border: 1px solid #a3e635; }
    .rarity-rare { color: #3b82f6; border: 1px solid #3b82f6; }
    .rarity-legendary { color: #eab308; border: 1px solid #eab308; box-shadow: 0 0 10px rgba(234,179,8,0.3); }

    .effect-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 50; display: flex; align-items: center; justify-content: center; font-size: 4rem; font-weight: 900; text-transform: uppercase; animation: pulse 1s infinite; opacity: 0.8; }
    .effect-freeze { background: rgba(0, 150, 255, 0.3); color: #00ffff; text-shadow: 0 0 20px blue; }
    @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

    /* Chart Bar for Mirror */
    .chart-bar { transition: height 0.5s ease; background: var(--rtl-orange); width: 40px; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; }
    
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 2;
  const QUESTION_TIME = 60; 
  const FINAL_QUESTIONS = 5;
  const FINAL_TIME = 60;
  
  const ROUND_POINTS = { 1: 100, 2: 200, 3: 400, 4: 800 };
  const FINAL_ROUND_POINTS = [500, 750, 1000, 1500, 2000];

  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ ITEMS SYSTEM ************/
  const ITEM_DEFS = {
    BOOST: { id: 'BOOST', name: 'Turbo-Boost', icon: 'üöÄ', desc: '+50% Punkte', type: 'SELF', rarity: 'COMMON' },
    SHIELD: { id: 'SHIELD', name: 'Schild', icon: 'üõ°Ô∏è', desc: 'Schutz & Reflektion', type: 'SELF', rarity: 'COMMON' },
    POISON: { id: 'POISON', name: 'Giftpfeil', icon: '‚ò†Ô∏è', desc: '-25% Punkte Gegner', type: 'TARGET', rarity: 'UNCOMMON' },
    FREEZE: { id: 'FREEZE', name: 'Eisschock', icon: '‚ùÑÔ∏è', desc: 'Blockiert 10s', type: 'TARGET', rarity: 'UNCOMMON' },
    TIME_SNATCH: { id: 'TIME_SNATCH', name: 'Zeitschnapper', icon: '‚è≥', desc: 'Halbe Zeit Gegner', type: 'TARGET', rarity: 'RARE' },
    MIRROR: { id: 'MIRROR', name: 'Spiegelglas', icon: 'üìä', desc: 'Zeigt Antworten', type: 'SELF', rarity: 'RARE' },
    MAGNET: { id: 'MAGNET', name: 'Magnet', icon: 'üß≤', desc: 'Mehrheits-Bonus', type: 'SELF', rarity: 'UNCOMMON' },
    HINT: { id: 'HINT', name: 'Frage-Zapfer', icon: 'üí°', desc: 'Entfernt 2 falsche', type: 'SELF', rarity: 'RARE' },
    SPY: { id: 'SPY', name: 'Antwort-Scanner', icon: 'üî¶', desc: 'Spioniert Antwort', type: 'TARGET', rarity: 'RARE' },
    SWAP: { id: 'SWAP', name: 'Platztauscher', icon: 'üé≠', desc: 'Punkte Tausch!', type: 'SELF', rarity: 'LEGENDARY' }
  };

  function getRandomItem(normalizedRank) {
    let pool = [];
    if (normalizedRank > 0.75) pool = ['SWAP','HINT','TIME_SNATCH','FREEZE','MIRROR','POISON','SPY'];
    else if (normalizedRank > 0.4) pool = ['POISON','FREEZE','MAGNET','SHIELD','BOOST','HINT'];
    else pool = ['SHIELD','BOOST','MAGNET','POISON'];
    const itemId = pool[Math.floor(Math.random() * pool.length)];
    return ITEM_DEFS[itemId];
  }

  /************ Fragen Pool ************/
  const CATEGORY_LIST = ["Geografie", "Wissenschaft", "Geschichte", "Kultur & Kunst", "Sport", "Technik & Digitalisierung"];
  const QUESTION_POOL = [
    { question: "Welches Land hat die l√§ngste K√ºstenlinie der Welt?", answers: ["USA","Kanada","Australien","Indonesien"], correct: 1, category: "Geografie" },
    { question: "Welche Stadt liegt am Bosporus?", answers: ["Belgrad","Istanbul","Athen","Sofia"], correct: 1, category: "Geografie" },
    { question: "Wie viele Chromosomen hat der Mensch normalerweise?", answers: ["42","44","46","48"], correct: 2, category: "Wissenschaft" },
    { question: "Welches Gas atmen wir haupts√§chlich ein?", answers: ["Sauerstoff","Stickstoff","Kohlendioxid","Helium"], correct: 1, category: "Wissenschaft" },
    { question: "Wer war der erste Kanzler der Bundesrepublik Deutschland?", answers: ["Brandt","Schmidt","Adenauer","Kohl"], correct: 2, category: "Geschichte" },
    { question: "In welchem Jahr begann der Zweite Weltkrieg?", answers: ["1938","1939","1940","1941"], correct: 1, category: "Geschichte" },
    { question: "Wer komponierte die 9. Sinfonie?", answers: ["Beethoven","Mozart","Bach","Haydn"], correct: 0, category: "Kultur & Kunst" },
    { question: "Welcher K√ºnstler schuf die 'Sternennacht'?", answers: ["Monet","Van Gogh","Gauguin","Da Vinci"], correct: 1, category: "Kultur & Kunst" },
    { question: "Wie viele Spieler hat eine Fu√üballmannschaft auf dem Feld?", answers: ["9","10","11","12"], correct: 2, category: "Sport" },
    { question: "Wer gewann die Fu√üball-WM 2014?", answers: ["Brasilien","Deutschland","Spanien","Argentinien"], correct: 1, category: "Sport" },
    { question: "Was bedeutet die Abk√ºrzung 'CPU'?", answers: ["Central Performance Unit","Central Processing Unit","Computer Personal Unit","Control Processing Unit"], correct: 1, category: "Technik & Digitalisierung" },
    { question: "Welche Firma entwickelte das erste iPhone?", answers: ["Samsung","Apple","Nokia","Motorola"], correct: 1, category: "Technik & Digitalisierung" },
  ];
  const FINAL_QUESTION_POOL = [
    { question: "In welchem Jahr wurde die Berliner Mauer errichtet?", answer: "1961" },
    { question: "Wie hei√üt der h√∂chste Berg Deutschlands?", answer: "Zugspitze" },
    { question: "Welches chemische Element hat das Symbol 'Au'?", answer: "Gold" },
    { question: "Wie viele Bundesl√§nder hat Deutschland?", answer: "16" },
    { question: "In welcher Stadt steht die Freiheitsstatue?", answer: "New York" },
  ];

  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[i],a[j]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }

  function getQuestionsForCategory(category, count, usedQuestions = []) {
    let pool = QUESTION_POOL.filter(q => q.category === category && !usedQuestions.includes(q.question));
    if (pool.length < count) pool = QUESTION_POOL.filter(q => !usedQuestions.includes(q.question));
    return shuffle(pool).slice(0, count).map((q, idx) => ({ id: `${category}-${Date.now()}-${idx}`, ...q }));
  }

  function RTLLogo({ size = "md" }) {
    const h = size === 'lg' ? 80 : 50;
    return <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/RTL_Group_logo.svg/2560px-RTL_Group_logo.svg.png" alt="Logo" style={{height: h, filter:'brightness(0) invert(1)'}} />; 
  }
  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=500&margin=1&dark=000000&light=ffffff`;
  }
  function ConfettiRain() {
     const particles = Array.from({length: 50});
     return (
        <div style={{position:'fixed', inset:0, pointerEvents:'none', overflow:'hidden', zIndex:0}}>
           {particles.map((_, i) => (
              <div key={i} style={{
                 position:'absolute', width:10, height:10,
                 left: Math.random() * 100 + 'vw',
                 animation: `fall ${2+Math.random()*3}s linear infinite`,
                 animationDelay: Math.random() * 3 + 's',
                 backgroundColor: ['#FF6600', '#7B2CBF', '#FFF'][Math.floor(Math.random()*3)]
              }} />
           ))}
           <style>{`@keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1;} 100% { transform: translateY(110vh) rotate(720deg); opacity: 0; } }`}</style>
        </div>
     )
  }

  /****************************************
   * HOST SCREEN
   ****************************************/
  function HostScreen({ gameId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [revealAnswer, setRevealAnswer] = useState(false);
    const [judged, setJudged] = useState({}); // For Finale
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => { setGame(snap.val()); setMeta(snap.val()?.meta); });
      return ()=> { gRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    useEffect(()=>{
      if(!meta) { setTimeLeft(0); return; }
      if((meta.phase === 'question' && meta.questionStartTime) || (meta.phase === 'finalQuestion' && meta.finalQuestionStartTime)){
        const isFinal = meta.phase === 'finalQuestion';
        const start = isFinal ? meta.finalQuestionStartTime : meta.questionStartTime;
        const duration = isFinal ? FINAL_TIME : QUESTION_TIME;
        const tick = async ()=>{
          const elapsed = Math.floor((Date.now() - start)/1000);
          const rem = Math.max(0, duration - elapsed);
          setTimeLeft(rem);
          if(rem === 0) { isFinal ? await nextFinalQuestion() : await showResultsNow(); }
        };
        clearInterval(timerRef.current);
        timerRef.current = setInterval(tick, 500);
        tick();
        return ()=> clearInterval(timerRef.current);
      }
    },[meta?.phase, meta?.questionStartTime, meta?.finalQuestionStartTime]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setRevealAnswer(false);
            setTimeout(() => setRevealAnswer(true), 3000); 
        }
    }, [meta?.phase]);

    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g || g.meta.phase === 'results') return;
        
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        const playerObj = g.players || {};
        const updates = {};
        const currentRound = g.meta.round || 1;
        const basePoints = ROUND_POINTS[currentRound] || 100;

        // Calculation Logic (Items + Base)
        let activeSwapUser = null;
        const roundResults = {}; 

        Object.entries(playerObj).forEach(([pid, p]) => {
          const effects = p.activeEffects || {};
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          
          let points = correct ? basePoints : 0;
          if (correct && effects.BOOST) points = Math.round(points * 1.5);
          if (correct && effects.MAGNET) {
             const othersCorrect = Object.values(playerObj).filter(op => op.currentAnswer === q.correct).length;
             if (othersCorrect > 1) points += 50 * (othersCorrect - 1);
          }

          const isShielded = effects.SHIELD;
          const poisonAttackers = effects.poisonedBy || [];
          let poisonPenalty = 0;
          if (!isShielded && poisonAttackers.length > 0) {
             poisonPenalty = Math.round(points * 0.25 * poisonAttackers.length); 
          }
          
          if (effects.SWAP) activeSwapUser = pid; 
          roundResults[pid] = Math.max(0, points - poisonPenalty);
        });

        // SWAP Logic
        if (activeSwapUser) {
             const allPids = Object.keys(playerObj);
             const targetPid = allPids[Math.floor(Math.random() * allPids.length)];
             if (targetPid !== activeSwapUser) {
                 const temp = roundResults[activeSwapUser];
                 roundResults[activeSwapUser] = roundResults[targetPid];
                 roundResults[targetPid] = temp;
                 
                 const actions = g.meta.actions || [];
                 actions[qIndex] = actions[qIndex] || [];
                 actions[qIndex].push({ type:'SWAP', from: activeSwapUser, to: targetPid });
                 updates[`games/${gameId}/meta/actions/${qIndex}`] = actions[qIndex];
             }
        }

        const sortedByScore = Object.entries(playerObj).map(([pid, p]) => ({pid, score: p.score || 0})).sort((a,b) => b.score - a.score);
        
        Object.entries(roundResults).forEach(([pid, pts]) => {
            const currentTotal = playerObj[pid].score || 0;
            updates[`games/${gameId}/players/${pid}/score`] = currentTotal + pts;
            updates[`games/${gameId}/players/${pid}/lastPoints`] = pts;

            // Lootbox Logic
            const pInv = playerObj[pid].inventory || [];
            if (pInv.length < 2) {
                const rankIdx = sortedByScore.findIndex(x => x.pid === pid);
                const normalizedRank = sortedByScore.length > 1 ? rankIdx / (sortedByScore.length - 1) : 0;
                pInv.push(getRandomItem(normalizedRank));
                updates[`games/${gameId}/players/${pid}/inventory`] = pInv;
            }
        });
        
        await db.ref().update(updates);
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });
      }catch(e){ console.error(e); }
    };

    const startNextRound = async ()=>{
      const gameSnap = await db.ref(`games/${gameId}`).get();
      const g = gameSnap.val();
      const currentIndex = g.meta.questionIndex || 0;
      const nextIndex = currentIndex + 1;
      
      if(g.meta.phase === 'results'){
        const isRoundEnd = (nextIndex % QUESTIONS_PER_ROUND) === 0;
        if (isRoundEnd) {
             const finishedRound = Math.floor(currentIndex / QUESTIONS_PER_ROUND) + 1;
             if (finishedRound >= TOTAL_ROUNDS) {
                // WICHTIG: HIER WAR DER FEHLER. JETZT STARTET FINALE!
                await prepareFinale(g);
                return;
             }
             const sorted = Object.entries(g.players||{}).sort(([,a],[,b]) => (a.score||0) - (b.score||0));
             const minScore = sorted[0]?.[1].score || 0;
             const losers = sorted.filter(([,p]) => (p.score||0) === minScore).map(([id]) => id);
             const pickedLoser = losers[Math.floor(Math.random() * losers.length)];

             await db.ref(`games/${gameId}/meta`).update({
               phase: 'roundSummary',
               round: finishedRound + 1,
               categoryChooserCandidate: pickedLoser
             });
        } else {
            await proceedToQuestion(nextIndex, g.meta.currentCategory);
        }
      }
      else if(g.meta.phase === 'roundSummary'){
         let cat = g.meta.nextCategory;
         if(!cat) {
            const used = g.meta.categoryState?.used || [];
            const avail = CATEGORY_LIST.filter(c => !used.includes(c));
            cat = avail[0] || CATEGORY_LIST[0];
         }
         const newBlock = getQuestionsForCategory(cat, QUESTIONS_PER_ROUND, (g.questions||[]).map(q=>q.question));
         await db.ref(`games/${gameId}/questions`).set([...(g.questions||[]), ...newBlock]);
         const used = [...(g.meta.categoryState?.used || []), cat];
         await db.ref(`games/${gameId}/meta/categoryState/used`).set(used);
         await db.ref(`games/${gameId}/meta/nextCategory`).remove();
         await db.ref(`games/${gameId}/meta/categoryChooserCandidate`).remove();
         await proceedToQuestion((g.questions||[]).length, cat);
      }
    };

    const proceedToQuestion = async (index, category) => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = null;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({
          questionIndex: index, phase: 'question', questionStartTime: Date.now(),
          currentCategory: category, round: Math.floor(index / QUESTIONS_PER_ROUND) + 1
      });
    };

    /******** FINALE LOGIK ********/
    const prepareFinale = async (g) => {
      const pArr = Object.entries(g.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      const top2 = pArr.slice(0, 2).map(p => p.pid);
      await db.ref(`games/${gameId}/finalQuestions`).set(shuffle(FINAL_QUESTION_POOL).slice(0, FINAL_QUESTIONS));
      
      const updates = {};
      Object.keys(g.players).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/isFinalist`] = top2.includes(pid);
        updates[`games/${gameId}/players/${pid}/finalAnswers`] = {};
        updates[`games/${gameId}/players/${pid}/finalistReady`] = false;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({ phase: 'finalIntro', finalists: top2 });
    };

    const startFinalQuestion = async () => db.ref(`games/${gameId}/meta`).update({ phase: 'finalQuestion', finalQuestionIndex: 0, finalQuestionStartTime: Date.now() });
    
    const nextFinalQuestion = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const cur = (snap.val()?.meta?.finalQuestionIndex || 0) + 1;
      if(cur >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finalReview', finalReviewIndex: 0 });
      else await db.ref(`games/${gameId}/meta`).update({ finalQuestionIndex: cur, finalQuestionStartTime: Date.now() });
    };
    
    const judgeFinalAnswer = async (pid, ok) => {
      const snap = await db.ref(`games/${gameId}`).get();
      const revIdx = snap.val()?.meta?.finalReviewIndex || 0;
      const p = snap.val()?.players?.[pid];
      const points = ok ? (FINAL_ROUND_POINTS[revIdx] || 2000) : 0;
      await db.ref(`games/${gameId}/players/${pid}`).update({ score: (p.score||0) + points });
      setJudged(prev => ({...prev, [pid]: ok}));
    };

    const nextFinalReview = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const revIdx = (snap.val()?.meta?.finalReviewIndex || 0) + 1;
      setJudged({});
      if(revIdx >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
      else await db.ref(`games/${gameId}/meta`).update({ finalReviewIndex: revIdx });
    };

    const startGame = async ()=>{
      const categoriesForGame = shuffle(CATEGORY_LIST);
      const firstCat = categoriesForGame[0];
      const block = getQuestionsForCategory(firstCat, QUESTIONS_PER_ROUND, []);
      await db.ref(`games/${gameId}/questions`).set(block);
      await db.ref(`games/${gameId}/meta/categoryState`).set({ used: [firstCat] });
      await db.ref(`games/${gameId}/meta`).set({ phase: 'question', questionIndex: 0, round: 1, questionStartTime: Date.now(), currentCategory: firstCat });
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/inventory`] = [];
      });
      await db.ref().update(updates);
    };

    if(!meta || !game) return <div className="text-white text-center mt-10">Lade Spiel...</div>;
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];

    // --- HOST RENDER ---
    if (meta.phase === 'lobby') {
        return (
            <div className="host-screen flex-col bg-black">
                <div className="flex-1 flex items-center justify-center border-b border-white/10 bg-neutral-900">
                    <div className="flex items-center gap-10 scale-110">
                        <div className="bg-white p-4"><img src={qrUrlForGame(gameId)} className="w-[300px] h-[300px]" /></div>
                        <div>
                            <RTLLogo size="lg" />
                            <div className="text-2xl text-gray-500 mt-4 uppercase tracking-widest">Join Code:</div>
                            <div className="text-9xl font-black text-white tracking-wider font-mono">{gameId}</div>
                        </div>
                    </div>
                </div>
                <div className="h-1/3 bg-neutral-950 p-6">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-3xl font-bold text-[var(--rtl-orange)]">LOBBY ({playersArr.length})</h2>
                        <button className="btn btn-host text-2xl px-8" onClick={startGame}>START ‚ñ∂</button>
                    </div>
                    <div className="flex flex-wrap gap-4 overflow-auto h-full pb-10">
                        {playersArr.map(p=>(<div key={p.pid} className="bg-white/10 px-6 py-3 border border-white/10 text-xl font-bold flex items-center gap-3">{p.name} <span className="text-[var(--rtl-orange)]">‚óè</span></div>))}
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="host-screen bg-neutral-900">
            <div className="host-main">
                {/* TOP BAR */}
                {meta.phase !== 'finished' && meta.phase !== 'finalIntro' && (
                    <div className="game-top-bar">
                         <div className="flex items-center gap-6">
                             {(meta.phase === 'question' || meta.phase === 'finalQuestion') && <div className={`countdown-badge ${timeLeft<=10?'danger':timeLeft<=30?'warning':''}`}>{timeLeft}</div>}
                             <div>
                                 <div className="text-gray-400 uppercase tracking-widest text-sm">
                                     {meta.phase.includes('final') ? 'DAS FINALE' : `Runde ${meta.round} | Frage ${(qIndex%QUESTIONS_PER_ROUND)+1}`}
                                 </div>
                                 <div className="text-3xl font-black text-[var(--rtl-orange)] uppercase">
                                     {meta.phase === 'roundSummary' ? 'ZWISCHENSTAND' : (meta.phase.includes('final') ? 'FINALE' : (meta.currentCategory || 'Frage'))}
                                 </div>
                             </div>
                         </div>
                         <div>
                            {meta.phase === 'question' && <button className="btn btn-host" onClick={showResultsNow}>L√∂sung ‚ñ∂</button>}
                            {(meta.phase === 'results' || meta.phase === 'roundSummary') && <button className="btn btn-host" onClick={startNextRound}>Weiter ‚ñ∂</button>}
                            
                            {/* Final Buttons */}
                            {meta.phase === 'finalQuestion' && <button className="btn btn-host" onClick={nextFinalQuestion}>N√§chste/Review ‚ñ∂</button>}
                            {meta.phase === 'finalReview' && Object.keys(judged).length === (meta.finalists||[]).length && <button className="btn btn-host" onClick={nextFinalReview}>Weiter ‚ñ∂</button>}
                         </div>
                    </div>
                )}
                
                <div className="host-main-inner relative">
                    {/* NORMAL QUESTION */}
                    {meta.phase === 'question' && question && (
                        <>
                            <div className="flex-grow flex items-center justify-center p-10">
                                <h2 className="question-text">{question.question}</h2>
                            </div>
                            <div className="answers-grid">
                                {question.answers.map((a,i)=>(
                                    <div key={i} className="answer-btn">
                                        <div className="font-black text-[var(--rtl-orange)] text-5xl">{String.fromCharCode(65+i)}</div>
                                        <div className="text-3xl">{a}</div>
                                    </div>
                                ))}
                            </div>
                            <div className="mt-auto pt-6 border-t border-white/10 w-full text-center">
                                <div className="flex flex-wrap justify-center gap-2">
                                    {playersArr.map(p => {
                                        const answered = p.currentAnswer !== undefined && p.currentAnswer !== null;
                                        return <div key={p.pid} className={`px-3 py-1 text-sm font-bold border ${answered?'bg-[var(--rtl-orange)] border-[var(--rtl-orange)] text-black':'bg-white/5 border-white/10 text-gray-500'}`}>{p.name}</div>
                                    })}
                                </div>
                            </div>
                        </>
                    )}

                    {/* NORMAL RESULTS */}
                    {meta.phase === 'results' && question && (
                        <div className="results-split-view">
                            <div className="results-col justify-center">
                                <div className="grid gap-4">
                                    {question.answers.map((a,i)=>{
                                        const correct = i === question.correct;
                                        const voters = playersArr.filter(p => p.currentAnswer === i);
                                        const show = correct && revealAnswer;
                                        return (
                                            <div key={i} style={{transition:'all 0.5s'}} className={`p-6 border ${show ? 'bg-white text-black border-white scale-105' : 'bg-white/5 border-white/10 text-gray-400'}`}>
                                                <div className="flex justify-between items-center">
                                                    <div className="text-2xl font-bold">{String.fromCharCode(65+i)}. {a}</div>
                                                    {show && <div className="text-3xl">‚úÖ</div>}
                                                </div>
                                                <div className="mt-2 text-lg opacity-70">{voters.length} Stimmen</div>
                                            </div>
                                        )
                                    })}
                                </div>
                            </div>
                            <div className="results-col bg-white/5 border border-white/10 p-4 overflow-hidden">
                                {revealAnswer && (
                                    <>
                                        <h3 className="text-[var(--rtl-orange)] font-black text-xl mb-4 uppercase">Aktionen & Punkte</h3>
                                        <div className="scroll-area flex-1 space-y-2">
                                            {(game.meta.actions?.[qIndex] || []).map((act, idx) => {
                                                const from = game.players[act.from]?.name;
                                                const to = game.players[act.to]?.name;
                                                const def = ITEM_DEFS[act.type];
                                                return (
                                                    <div key={'act'+idx} className="text-sm bg-white/10 p-2 border-l-2 border-[var(--rtl-purple)]">
                                                        {def?.icon} <b>{from}</b> nutzte {def?.name} {act.to ? `auf ${to}` : ''}
                                                    </div>
                                                );
                                            })}
                                            <div className="h-px bg-white/20 my-4"></div>
                                            {playersArr.sort((a,b)=>(b.lastPoints||0)-(a.lastPoints||0)).map(p => (
                                                <div key={p.pid} className="flex justify-between items-center p-2 hover:bg-white/5">
                                                    <span className="font-bold">{p.name}</span>
                                                    <span className={`font-black ${p.lastPoints>0?'text-[var(--rtl-orange)]':'text-gray-500'}`}>
                                                        {p.lastPoints > 0 ? '+' : ''}{p.lastPoints}
                                                    </span>
                                                </div>
                                            ))}
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>
                    )}

                    {/* ROUND SUMMARY */}
                    {meta.phase === 'roundSummary' && (
                        <div className="flex flex-col items-center h-full">
                            <h2 className="text-5xl font-black text-[var(--rtl-orange)] mb-8">BESTENLISTE</h2>
                            {meta.categoryChooserCandidate && (
                                <div className="mb-8 p-4 border border-[var(--rtl-orange)] bg-[var(--rtl-orange)]/10 text-center animate-pulse">
                                    <div className="text-sm uppercase tracking-widest">W√§hlt n√§chste Kategorie</div>
                                    <div className="text-2xl font-black">{game.players[meta.categoryChooserCandidate]?.name}</div>
                                </div>
                            )}
                            <div className="w-full max-w-4xl scroll-area space-y-2">
                                {playersArr.map((p, i) => (
                                    <div key={p.pid} className={`flex items-center p-4 ${i===0?'bg-yellow-500/20 border-l-4 border-yellow-500':i===1?'bg-gray-400/20 border-l-4 border-gray-400':i===2?'bg-orange-700/20 border-l-4 border-orange-700':'bg-white/5'}`}>
                                        <div className="w-12 text-2xl font-black text-gray-500">{i+1}.</div>
                                        <div className="flex-1 text-xl font-bold">{p.name}</div>
                                        <div className="flex gap-2 mr-8">{(p.inventory||[]).map((it,idx)=><span key={idx} title={it.name}>{it.icon}</span>)}</div>
                                        <div className="text-3xl font-black">{p.score}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* FINALE INTRO */}
                    {meta.phase === 'finalIntro' && (
                        <div className="text-center w-full h-full flex flex-col justify-center items-center">
                            <h2 className="text-8xl font-black text-[var(--rtl-orange)] mb-10 tracking-widest">FINALE</h2>
                            <div className="flex gap-20 mb-10">
                                {(meta.finalists||[]).map((pid, idx) => {
                                    const f = game.players[pid];
                                    return (
                                        <div key={pid} className={`p-10 border-4 ${f.finalistReady ? 'border-[var(--rtl-orange)] bg-[var(--rtl-orange)] text-black' : 'border-white/20 bg-white/5'} w-96`}>
                                            <div className="text-2xl mb-4 uppercase">{idx===0?'Erster':'Zweiter'}</div>
                                            <div className="text-5xl font-black mb-4">{f.name}</div>
                                            <div className="text-xl font-bold">{f.finalistReady ? 'BEREIT' : 'WARTEN...'}</div>
                                        </div>
                                    )
                                })}
                            </div>
                            {(meta.finalists||[]).every(pid => game.players[pid]?.finalistReady) && 
                                <button className="btn btn-host text-3xl px-10 py-6" onClick={startFinalQuestion}>STARTEN ‚ñ∂</button>
                            }
                        </div>
                    )}

                    {/* FINALE QUESTION */}
                    {meta.phase === 'finalQuestion' && (
                        <div className="text-center w-full h-full flex flex-col pt-20">
                             <h2 className="text-6xl font-black mb-20 px-20 leading-tight">{(game.finalQuestions||[])[meta.finalQuestionIndex]?.question}</h2>
                             <div className="flex gap-10 justify-center">
                                 {(meta.finalists||[]).map(pid => {
                                     const f = game.players[pid];
                                     const hasAns = f.finalAnswers && f.finalAnswers[meta.finalQuestionIndex];
                                     return (
                                         <div key={pid} className={`p-10 border-2 ${hasAns ? 'border-[var(--rtl-orange)] bg-[var(--rtl-orange)] text-black' : 'border-white/20' } w-80`}>
                                             <div className="text-3xl font-black mb-2">{f.name}</div>
                                             <div>{hasAns ? '‚úÖ EINGELOGGT' : 'Tippt...'}</div>
                                         </div>
                                     )
                                 })}
                             </div>
                        </div>
                    )}

                    {/* FINALE REVIEW */}
                    {meta.phase === 'finalReview' && (
                        <div className="results-split-view">
                             <div className="results-col justify-center p-10 bg-white/5">
                                 <div className="text-sm uppercase text-gray-500 mb-2">Die Frage war:</div>
                                 <div className="text-3xl font-black mb-10">{(game.finalQuestions||[])[meta.finalReviewIndex]?.question}</div>
                                 <div className="p-10 bg-white text-black">
                                     <div className="text-[var(--rtl-orange)] font-black uppercase mb-2">L√∂sung</div>
                                     <div className="text-5xl font-black">{(game.finalQuestions||[])[meta.finalReviewIndex]?.answer}</div>
                                 </div>
                             </div>
                             <div className="results-col justify-center p-10">
                                 {(meta.finalists||[]).map(pid => {
                                     const f = game.players[pid];
                                     const ans = f.finalAnswers?.[meta.finalReviewIndex] || '---';
                                     const isJudged = judged[pid] !== undefined;
                                     return (
                                         <div key={pid} className="mb-8 p-6 border border-white/20 bg-white/5">
                                             <div className="flex justify-between mb-4">
                                                 <span className="font-bold text-xl">{f.name}</span>
                                                 <span className="text-gray-400">{f.score} Pkt</span>
                                             </div>
                                             <div className="text-3xl font-mono bg-black/50 p-4 mb-4 border-l-4 border-white">"{ans}"</div>
                                             {!isJudged ? (
                                                 <div className="flex gap-4">
                                                     <button className="btn flex-1 bg-green-600 border-green-600 hover:bg-green-500" onClick={()=>judgeFinalAnswer(pid, true)}>Richtig</button>
                                                     <button className="btn flex-1 bg-red-600 border-red-600 hover:bg-red-500" onClick={()=>judgeFinalAnswer(pid, false)}>Falsch</button>
                                                 </div>
                                             ) : (
                                                 <div className={`text-center font-black text-xl ${judged[pid] ? 'text-green-500':'text-red-500'}`}>{judged[pid] ? 'PUNKTE ERHALTEN' : 'FALSCH'}</div>
                                             )}
                                         </div>
                                     )
                                 })}
                             </div>
                        </div>
                    )}

                    {/* SIEGEREHRUNG */}
                    {meta.phase === 'finished' && (
                        <div className="flex flex-col items-center justify-center h-full relative z-10">
                            <ConfettiRain />
                            <h1 className="text-8xl font-black text-[var(--rtl-orange)] mb-10">SIEGER</h1>
                            <div className="flex items-end gap-10">
                                {playersArr[1] && <div className="text-center"><div className="text-4xl mb-2">{playersArr[1].name}</div><div className="h-40 w-32 bg-gray-500 flex items-end justify-center pb-4 text-4xl font-black">2</div></div>}
                                {playersArr[0] && <div className="text-center scale-125 origin-bottom"><div className="text-6xl font-black mb-4 text-yellow-400">üëë {playersArr[0].name}</div><div className="h-60 w-40 bg-yellow-500 flex items-end justify-center pb-4 text-6xl font-black text-black shadow-[0_0_50px_gold]">1</div></div>}
                                {playersArr[2] && <div className="text-center"><div className="text-4xl mb-2">{playersArr[2].name}</div><div className="h-32 w-32 bg-orange-700 flex items-end justify-center pb-4 text-4xl font-black">3</div></div>}
                            </div>
                            <button className="btn mt-20 z-50" onClick={()=>window.location.reload()}>NEUES SPIEL</button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
  }

  /****************************************
   * PLAYER VIEW
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    
    // UI States
    const [targetModalItem, setTargetModalItem] = useState(null); 
    const [bonusCategoryModalOpen, setBonusCategoryModalOpen] = useState(false);
    const [usedItemIndex, setUsedItemIndex] = useState(-1); 
    const [playerReveal, setPlayerReveal] = useState(false); 
    const [finalAns, setFinalAns] = useState('');

    // Local Effects
    const [isFrozen, setIsFrozen] = useState(false);
    const [timeSnatchActive, setTimeSnatchActive] = useState(false);
    const [mirrorData, setMirrorData] = useState(null);

    useEffect(() => { if(playerId && gameId) { sessionStorage.setItem(`quiz_pid_${gameId}`, playerId); } }, [playerId, gameId]);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      gRef.on('value', snap => setGame(snap.val()));
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); pRef.off(); };
    },[gameId, playerId]);

    const meta = game?.meta;
    
    useEffect(() => {
        setUsedItemIndex(-1);
        setMirrorData(null);
    }, [meta?.questionIndex]);

    useEffect(() => {
        if (meta?.phase === 'roundSummary' && meta?.categoryChooserCandidate === playerId && !meta.nextCategory) {
            setBonusCategoryModalOpen(true);
        } else {
            setBonusCategoryModalOpen(false);
        }
    }, [meta?.phase, meta?.categoryChooserCandidate, meta?.nextCategory, playerId]);

    // Time Logic
    useEffect(()=>{
      if(!meta) return;
      const isFinal = meta.phase === 'finalQuestion';
      const start = isFinal ? meta.finalQuestionStartTime : meta.questionStartTime;
      const duration = isFinal ? FINAL_TIME : QUESTION_TIME;

      if((meta.phase === 'question' || isFinal) && start){
        const myEffects = player?.activeEffects || {};
        if (myEffects.FREEZE) {
             setIsFrozen(true);
             setTimeout(() => setIsFrozen(false), 10000);
        } else setIsFrozen(false);

        const isSnatched = !!myEffects.TIME_SNATCH;
        setTimeSnatchActive(isSnatched);
        
        const tick = ()=>{ 
            const elapsed = (Date.now() - start)/1000;
            const penalty = isSnatched ? 30 : 0;
            setTimeLeft(Math.max(0, Math.floor(duration - elapsed - penalty)));
        };
        const t = setInterval(tick, 250);
        return ()=> clearInterval(t);
      } else { 
          setTimeLeft(0); setIsFrozen(false); 
      }
    },[meta?.questionStartTime, meta?.finalQuestionStartTime, meta?.phase, player?.activeEffects]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setPlayerReveal(false);
            setTimeout(() => setPlayerReveal(true), 3000); 
        }
    }, [meta?.phase]);

    useEffect(() => {
        if (player?.activeEffects?.MIRROR && game?.players) {
            const interval = setInterval(() => {
                const counts = [0,0,0,0];
                Object.values(game.players).forEach(p => {
                    if (p.currentAnswer !== undefined && p.currentAnswer !== null && p.currentAnswer >= 0) counts[p.currentAnswer]++;
                });
                setMirrorData(counts);
            }, 1000);
            return () => clearInterval(interval);
        }
    }, [player?.activeEffects?.MIRROR, game?.players]);

    const useItem = async (item, slotIndex, targetPid = null) => {
        if (usedItemIndex !== -1) return alert("Nur 1 Item pro Runde!");
        setTargetModalItem(null);
        setUsedItemIndex(slotIndex);

        const newInv = [...(player.inventory || [])];
        newInv.splice(slotIndex, 1);
        
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/inventory`] = newInv;

        if (item.type === 'SELF') {
            updates[`games/${gameId}/players/${playerId}/activeEffects/${item.id}`] = true;
        } else if (item.type === 'TARGET' && targetPid) {
            if (item.id === 'POISON') {
                const targetP = game.players[targetPid];
                const currentPoison = targetP.activeEffects?.poisonedBy || [];
                updates[`games/${gameId}/players/${targetPid}/activeEffects/poisonedBy`] = [...currentPoison, playerId];
            } else {
                updates[`games/${gameId}/players/${targetPid}/activeEffects/${item.id}`] = true;
            }
        }
        
        const actions = game.meta.actions?.[meta.questionIndex] || [];
        actions.push({ type: item.id, from: playerId, to: targetPid });
        updates[`games/${gameId}/meta/actions/${meta.questionIndex}`] = actions;

        await db.ref().update(updates);
    };

    const handleSlotClick = (item, idx) => {
        if (!item || meta.phase !== 'question' || usedItemIndex !== -1) return;
        if (item.type === 'TARGET') setTargetModalItem({ item, idx });
        else if (confirm(`${item.name} einsetzen?`)) useItem(item, idx);
    };

    const pickCategory = async (cat) => {
        await db.ref(`games/${gameId}/meta`).update({ nextCategory: cat });
        setBonusCategoryModalOpen(false);
    };

    if(!game || !meta || !player) return <div className="flex h-screen items-center justify-center bg-black text-white">Loading...</div>;

    // FINAL PLAYER SCREENS
    if(meta.phase === 'finalIntro') {
        if(!player.isFinalist) return <div className="h-screen bg-black flex items-center justify-center text-white text-2xl">Du bist Zuschauer im Finale!</div>
        return (
            <div className="h-screen bg-black flex flex-col items-center justify-center p-6 text-center">
                <div className="text-[var(--rtl-orange)] text-4xl font-black mb-6">FINALE!</div>
                <div className="text-white mb-10">Bist du bereit f√ºr den Showdown?</div>
                {!player.finalistReady ? 
                    <button className="btn btn-host w-full py-6 text-2xl" onClick={()=>db.ref(`games/${gameId}/players/${playerId}/finalistReady`).set(true)}>ICH BIN BEREIT</button>
                : <div className="text-green-500 font-bold text-2xl">WARTEN AUF START...</div>}
            </div>
        )
    }

    if(meta.phase === 'finalQuestion') {
         if(!player.isFinalist) return <div className="h-screen bg-black flex items-center justify-center text-white">Finale l√§uft...</div>
         const hasAns = player.finalAnswers && player.finalAnswers[meta.finalQuestionIndex];
         return (
             <div className="h-screen bg-black p-6 flex flex-col">
                 <div className="flex justify-between text-white mb-6">
                     <span>Frage {meta.finalQuestionIndex+1}</span>
                     <span className="text-[var(--rtl-orange)] font-bold">{timeLeft}s</span>
                 </div>
                 <div className="text-2xl font-black text-white mb-6">{(game.finalQuestions||[])[meta.finalQuestionIndex]?.question}</div>
                 {!hasAns ? (
                     <div className="flex flex-col gap-4">
                         <input className="text-xl p-4 text-black" placeholder="Deine Antwort..." value={finalAns} onChange={e=>setFinalAns(e.target.value)} />
                         <button className="btn btn-host py-4" onClick={()=>{
                             db.ref(`games/${gameId}/players/${playerId}/finalAnswers/${meta.finalQuestionIndex}`).set(finalAns);
                             setFinalAns('');
                         }}>ABSENDEN</button>
                     </div>
                 ) : (
                     <div className="text-[var(--rtl-orange)] text-center text-2xl font-bold mt-10">ANTWORT GESENDET</div>
                 )}
             </div>
         )
    }

    // NORMAL GAME
    if(meta.phase === 'question'){
       const q = (game.questions||[])[meta.questionIndex||0];
       const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
       const inventory = player.inventory || [];
       let hiddenIndices = [];
       if (player.activeEffects?.HINT) {
            const wrongIndices = q.answers.map((_,i) => i).filter(i => i !== q.correct);
            const seed = q.question.length;
            hiddenIndices.push(wrongIndices[seed % wrongIndices.length]);
            if (wrongIndices.length > 1) hiddenIndices.push(wrongIndices[(seed + 1) % wrongIndices.length]);
       }

       return (
         <div className="min-h-screen p-4 flex flex-col bg-neutral-900 relative overflow-hidden">
           {isFrozen && <div className="effect-overlay effect-freeze">EISSCHOCK!</div>}
           {timeSnatchActive && <div className="absolute top-0 right-0 p-2 bg-red-600 text-white font-bold z-50 animate-pulse">ZEIT GESTOHLEN!</div>}

           <div className="card flex-1 flex flex-col">
             <div className="flex justify-between items-end border-b border-white/10 pb-4 mb-4">
                 <div className="text-sm text-gray-400 uppercase">Runde {meta.round}</div>
                 <div className="text-3xl font-black">{player.score} <span className="text-sm font-normal text-gray-500">Pkt</span></div>
             </div>
             
             <div className="flex justify-between items-center mb-6">
                <div className="font-bold text-gray-400 uppercase tracking-widest">{meta.currentCategory}</div>
                <div className={`text-4xl font-black ${timeLeft<10?'text-red-500':'text-[var(--rtl-orange)]'}`}>{timeLeft}</div>
             </div>

             <h3 className="text-xl font-bold leading-tight mb-6">{q?.question}</h3>
             
             {mirrorData && (
                 <div className="mb-4 h-24 flex items-end justify-around bg-black/20 p-2 border border-white/10">
                     {q.answers.map((_,i) => (
                         <div key={i} className="flex flex-col items-center w-full">
                             <div className="chart-bar" style={{height: `${(mirrorData[i]/Object.keys(game.players).length)*100}%`}}></div>
                             <div className="text-xs mt-1 font-bold">{String.fromCharCode(65+i)}</div>
                         </div>
                     ))}
                 </div>
             )}

             <div className="grid gap-3 flex-1 content-start">
               {q?.answers.map((a,i)=>{
                 if (hiddenIndices.includes(i)) return <button key={i} disabled className="p-4 bg-black/20 text-gray-600 border border-white/5 text-left flex items-center gap-3">‚õî [TIPP: Falsch]</button>;
                 const selected = player.currentAnswer===i;
                 return (
                 <button key={i} disabled={hasAnswered||timeLeft<=0||isFrozen} 
                    onClick={()=>db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i)} 
                    className={`p-4 text-left text-lg font-bold flex items-center gap-3 transition-all ${selected ? 'bg-[var(--rtl-orange)] text-black border-[var(--rtl-orange)]' : 'bg-white text-black border-white'}`}
                    style={{opacity: (hasAnswered && !selected) ? 0.5 : 1}}
                 >
                    <span className={`font-black ${selected?'text-black':'text-[var(--rtl-orange)]'}`}>{String.fromCharCode(65+i)}.</span>
                    {a}
                 </button>
               )})}
             </div>

             <div className="mt-6 pt-4 border-t border-white/10">
                 <div className="text-xs uppercase text-gray-500 font-bold mb-2">Dein Inventar (Tippen zum Nutzen)</div>
                 <div className="flex gap-4 justify-center">
                    {[0,1].map(idx => {
                        const item = inventory[idx];
                        if (!item) return <div key={idx} className="inventory-slot"><span className="opacity-20 text-2xl">+</span></div>;
                        const disabled = usedItemIndex !== -1;
                        return (
                            <div key={idx} onClick={()=>!disabled && handleSlotClick(item, idx)} className={`inventory-slot filled ${disabled?'opacity-30 grayscale':''} rarity-${item.rarity.toLowerCase()}`}>
                                <div className="item-icon">{item.icon}</div>
                                <div className={`absolute -top-3 -right-3 item-tag rarity-${item.rarity.toLowerCase()} bg-black scale-75`}>{item.name}</div>
                            </div>
                        )
                    })}
                 </div>
             </div>
           </div>

           {targetModalItem && (
               <div className="modal-backdrop">
                   <div className="modal-card">
                       <h3 className="text-xl font-black mb-4 text-[var(--rtl-orange)]">Ziel w√§hlen</h3>
                       <div className="grid grid-cols-2 gap-3 max-h-[50vh] overflow-auto">
                         {Object.entries(game.players).filter(([pid]) => pid !== playerId).map(([pid, p])=>(
                            <button key={pid} className="btn bg-white/10 hover:bg-white/20" onClick={()=>useItem(targetModalItem.item, targetModalItem.idx, pid)}>{p.name}</button>
                         ))}
                       </div>
                       <button className="btn mt-4 w-full bg-red-500" onClick={()=>setTargetModalItem(null)}>ABBRECHEN</button>
                   </div>
               </div>
           )}
         </div>
       );
    }

    if (meta.phase === 'results') {
        const isCorrect = player.currentAnswer === (game.questions[meta.questionIndex] || {}).correct;
        const pts = player.lastPoints || 0;
        if (!playerReveal) return <div className="min-h-screen flex flex-col items-center justify-center p-6 bg-black text-center"><h2 className="text-2xl font-bold text-[var(--rtl-orange)] animate-pulse">Antwort eingeloggt...</h2></div>;
        return (
            <div className="min-h-screen flex flex-col items-center justify-center p-6 bg-black text-center">
                <div className="text-8xl mb-6">{isCorrect ? 'üòé' : 'ü´†'}</div>
                <h1 className="text-5xl font-black text-white mb-2">{isCorrect ? 'RICHTIG!' : 'LEIDER FALSCH'}</h1>
                <div className={`text-6xl font-black my-6 ${pts > 0 ? 'text-[var(--rtl-orange)]' : 'text-gray-500'}`}>{pts > 0 ? '+' : ''}{pts}</div>
            </div>
        );
    }

    if (bonusCategoryModalOpen) {
        const used = game.meta.categoryState?.used || [];
        const available = CATEGORY_LIST.filter(c => !used.includes(c));
        return (
            <div className="modal-backdrop">
                <div className="modal-card text-center">
                    <h3 className="text-2xl font-black text-[var(--rtl-orange)] mb-6">DU DARFST W√ÑHLEN!</h3>
                    <div className="grid gap-3">
                        {(available.length?available:CATEGORY_LIST).map(c => (<button key={c} className="btn btn-host w-full" onClick={()=>pickCategory(c)}>{c}</button>))}
                    </div>
                </div>
            </div>
        );
    }

    return <div className="flex h-screen items-center justify-center bg-black text-white">Warte auf Host...</div>;
  }

  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');
    const handleJoin = async ()=>{
      if(!name) return;
      const snap = await db.ref(`games/${joinGameId}`).get();
      if(!snap.exists()) return alert('Code falsch');
      const pid = makePlayerId();
      await db.ref(`games/${joinGameId}/players/${pid}`).set({ name, score:0, inventory: [] });
      onJoined(joinGameId, pid, name);
    };
    return (
      <div className="min-h-screen flex flex-col items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div className="mb-10 text-center"><RTLLogo size="md" /><h1 className="mt-4 text-2xl font-black text-white tracking-widest">Quiz Mayhem</h1></div>
        <div className="card w-full max-w-md text-center">
          <h2 className="text-xl font-black text-[var(--rtl-orange)] mb-6 uppercase">Spieler Login</h2>
          <input value={name} onChange={e=>setName(e.target.value)} placeholder="Dein Name" className="w-full mb-4 text-center text-xl font-bold" maxLength={12} />
          <button className="btn btn-host w-full py-4 text-xl" onClick={handleJoin} disabled={!name}>BEITRETEN ‚ñ∂</button>
        </div>
      </div>
    );
  }

  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ 
        const savedPid = sessionStorage.getItem(`quiz_pid_${joinCode}`);
        if(savedPid) {
           db.ref(`games/${joinCode}/players/${savedPid}`).once('value', s => {
               if(s.exists()) { setGameId(joinCode); setPlayerId(savedPid); setMode('playerGame'); }
               else { setGameId(joinCode); setMode('playerJoin'); }
           });
        } else { setGameId(joinCode); setMode('playerJoin'); }
      }
    },[]);

    const handleCreate = async (name)=>{ const gid = randomGameID(); setGameId(gid); await db.ref(`games/${gid}/meta`).set({ phase: 'lobby' }); setMode('hostLobby'); };
    const handleJoin = async (name, code)=>{
        const snap = await db.ref(`games/${code}`).get();
        if(!snap.exists()) { alert('Spiel nicht gefunden!'); return; }
        const pid = makePlayerId();
        await db.ref(`games/${code}/players/${pid}`).set({ name, score: 0, inventory: [] });
        sessionStorage.setItem(`quiz_pid_${code}`, pid);
        setGameId(code); setPlayerId(pid); setMode('playerGame');
    };
    const handlePlayerJoined = (code,pid) => { sessionStorage.setItem(`quiz_pid_${code}`, pid); setGameId(code); setPlayerId(pid); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} />}
        {mode === 'playerGame' && <PlayerView gameId={gameId} playerId={playerId} />}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>
