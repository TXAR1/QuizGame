<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Multiplayer (Items + Bonus + Kategorien - Fixed)</title>

  <!-- React + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind utilities (optional) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    /* UI styles (kopiert aus deinem Original, leicht bereinigt) */
    :root{
      --rtl-orange:#FF6600;
      --rtl-red:#E31F23;
      --rtl-purple:#7B2CBF;
      --rtl-green:#22C55E;
      --bg:#0b0b0b;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
    }
    html,body,#root{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{ background:linear-gradient(180deg,var(--bg), #090909); color:var(--tile); }
    * { box-sizing:border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 10px; }
    .host-screen{ display:flex; gap:20px; padding:24px; height:100vh; align-items:stretch; }
    .host-main{ flex:2; padding:28px; display:flex; flex-direction:column; gap:18px; min-height:0; }
    .host-side{ flex:1; padding:18px; overflow:auto; }
    .card{ padding:16px; }
    .countdown-badge{ width:110px; height:110px; display:flex; align-items:center; justify-content:center; font-size:2.6rem; font-weight:800; color:var(--tile); border:3px solid rgba(255,255,255,0.06); }
    .question-text{ font-size:2.4rem; font-weight:800; color:var(--tile); line-height:1.08; margin-top:6px; }
    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:18px; margin-top:18px; }
    .answer-btn{ background: #ffffff; color:#0b0b0b; padding:20px; font-size:1.05rem; font-weight:700; min-height:110px; display:flex; gap:12px; }
    .player-card{ max-width:720px; margin:20px auto; padding:20px; }
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal-card{ width:95%; max-width:520px; padding:18px; color:var(--tile); }
    .modal-title{ font-size:18px; font-weight:900; margin-bottom:12px; color:var(--rtl-orange); text-align:center; }
    .bonus-grid{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:12px; }
    .bonus-choice{ padding:12px 16px; border:1px solid rgba(255,255,255,0.06); cursor:pointer; font-weight:900; min-width:120px; text-align:center; background:rgba(255,255,255,0.02); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 10;
  const QUESTION_TIME = 40;
  const BASE_POINTS = 100;

  // Firebase config - unver√§ndert (bitte beibehalten / eigene Keys einsetzen)
  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ CATEGORY SYSTEM ************/
  const CATEGORY_LIST = [
    "Fernsehen",
    "Musik",
    "Sport",
    "Politik",
    "Games",
    "Geografie"
  ];

  /************ Helpers ************/
  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }

  /************ Default Items ************/
  const DEFAULT_ITEMS = { boost: 5, poison: 5, shield: 3 };

  /************ QUESTION POOL (mit Kategorien) ************/
  // Option A: die vorhandenen Beispiel-Fragen wurden automatisch passenden Kategorien zugewiesen
  const QUESTION_POOL = [
    { question: "Was ist die Hauptstadt von √ñsterreich?", category: "Geografie", answers: ["Wien","Graz","Salzburg","Innsbruck"], correct: 0 },
    { question: "Welcher Planet ist der gr√∂√üte?", category: "Wissenschaft", answers: ["Mars","Saturn","Jupiter","Neptun"], correct: 2 },
    { question: "Wer malte die Mona Lisa?", category: "Kultur", answers: ["Picasso","Van Gogh","Da Vinci","Monet"], correct: 2 },
    { question: "In welchem Jahr fiel die Berliner Mauer?", category: "Politik", answers: ["1987","1989","1991","1993"], correct: 1 },
    { question: "Was ist die chemische Formel f√ºr Wasser?", category: "Wissenschaft", answers: ["CO2","H2O","O2","NaCl"], correct: 1 },
    { question: "Wie viele Kontinente gibt es?", category: "Geografie", answers: ["5","6","7","8"], correct: 2 },
    { question: "Welches ist das gr√∂√üte S√§ugetier?", category: "Wissenschaft", answers: ["Elefant","Blauwal","Giraffe","Nashorn"], correct: 1 },
    { question: "Wer schrieb 'Romeo und Julia'?", category: "Kultur", answers: ["Goethe","Shakespeare","Schiller","Moli√®re"], correct: 1 },
    { question: "Welches Land hat die meisten Einwohner?", category: "Geografie", answers: ["Indien","China","USA","Indonesien"], correct: 1 },
    { question: "Was ist die Hauptstadt von Frankreich?", category: "Geografie", answers: ["Lyon","Marseille","Paris","Nizza"], correct: 2 },

    // Extra-Beispiele, um Pool f√ºr Kategorien etwas zu strecken
    { question: "Welches ist ein bekannter Fernsehpreis (Beispiel)?", category: "Fernsehen", answers: ["Award A","Award B","Award C","Award D"], correct: 0 },
    { question: "Welcher S√§nger ist sehr popul√§r (Beispiel)?", category: "Musik", answers: ["S√§nger A","S√§nger B","S√§nger C","S√§nger D"], correct: 1 },
    { question: "Welche Sportart hat B√§lle und Tore?", category: "Sport", answers: ["Tennis","Basketball","Fu√üball","Golf"], correct: 2 },
    { question: "Welches Videospiel-Genre ist Jump'n'Run?", category: "Games", answers: ["Shooter","RPG","Jump'n'Run","Strategy"], correct: 2 },
    { question: "Welche Partei ist in Beispiel-Land stark?", category: "Politik", answers: ["Partei A","Partei B","Partei C","Partei D"], correct: 0 },
    { question: "Welcher Song war ein Hit (Beispiel)?", category: "Musik", answers: ["Song A","Song B","Song C","Song D"], correct: 2 },
  ];

  /************ Frage-Auswahl pro Kategorie ************/
  function getQuestionsForCategory(category, count, usedQuestions=[]) {
    // filter pool
    const pool = QUESTION_POOL.filter(q => q.category === category);
    let source = pool.length ? pool.slice() : QUESTION_POOL.slice();
    source = shuffle(source);

    const selected = [];
    let attempts = 0;
    while (selected.length < count && attempts < count * 20) {
      const cand = source[attempts % source.length];
      // avoid exact question duplicates within same block and against usedQuestions
      if (!selected.find(s => s.question === cand.question) && !usedQuestions.includes(cand.question)) {
        selected.push({...cand});
      }
      attempts++;
      if (attempts > 1000) break;
    }
    // if not enough, fill with fallback duplicates allowed
    while (selected.length < count) {
      selected.push({...source[(selected.length) % source.length]});
    }
    // assign stable-ish ids
    return selected.map((q,i) => ({ id: `${category}-${Date.now()}-${Math.random().toString(36).substr(2,5)}-${i}`, ...q }));
  }

  /************ RTL Logo (klein) ************/
  function RTLLogo({size='md'}){
    const sizeMap={sm:40,md:60,lg:100};
    const h = sizeMap[size]||60;
    const w = (h/300)*1520;
    return (
      <svg viewBox="0 0 1520 300" height={h} width={w} xmlns="http://www.w3.org/2000/svg">
        <rect x="0" y="0" width="490" height="300" fill="#FF6600"/>
        <text x="245" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">R</text>
        <rect x="515" y="0" width="490" height="300" fill="#E31F23"/>
        <text x="760" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">T</text>
        <rect x="1030" y="0" width="490" height="300" fill="#7B2CBF"/>
        <text x="1275" y="220" fontSize="200" fontWeight="900" fill="white" textAnchor="middle" fontFamily="Arial, sans-serif">L</text>
      </svg>
    );
  }

  /****************************************
   * START SCREEN
   ****************************************/
  function StartScreen({ onCreate, onJoin }){
    const [name,setName] = useState('');
    const [code,setCode] = useState('');
    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div className="player-card">
          <div style={{display:'flex', gap:12, alignItems:'center'}}>
            <RTLLogo size="md" />
            <div style={{fontWeight:900}}>AdAlliance Quiz</div>
          </div>
          <h1 style={{fontSize:24, fontWeight:900, color:'var(--rtl-orange)', marginTop:12}}>üéØ Quiz Master</h1>
          <p style={{color:'var(--muted)'}}>Host erstellen oder Code eingeben</p>
          <div style={{marginTop:12}}>
            <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} />
            <div style={{display:'flex', gap:8}}>
              <button className="btn btn-host" onClick={()=>onCreate(name)} disabled={!name}>üé¨ Host werden</button>
              <input placeholder="Code" value={code} onChange={e=>setCode(e.target.value.toUpperCase())} style={{marginLeft:8}} />
              <button className="btn btn-join" onClick={()=>onJoin(name,code)} disabled={!name || !code}>Beitreten</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /****************************************
   * HOST CONTROLLER
   ****************************************/
  function HostController({ gameId, meta, startNextRound, showResultsNow, startGame }){
    const [players,setPlayers] = useState({});
    useEffect(()=>{
      const ref = db.ref(`games/${gameId}/players`);
      ref.on('value', snap => setPlayers(snap.val() || {}));
      return ()=> ref.off();
    },[gameId]);

    if(!meta) return <div className="card">Lade...</div>;
    return (
      <div className="card">
        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
          <div>
            <div style={{color:'var(--muted)'}}>Phase: <strong style={{color:'var(--rtl-orange)'}}>{meta.phase}</strong></div>
            <div style={{color:'var(--muted)'}}>Runde: <strong style={{color:'var(--rtl-orange)'}}>{meta.round || 1}/{TOTAL_ROUNDS}</strong></div>
            <div style={{color:'var(--muted)'}}>Frage: <strong style={{color:'var(--rtl-orange)'}}>{(meta.questionIndex || 0) + 1}/{TOTAL_ROUNDS * QUESTIONS_PER_ROUND}</strong></div>
          </div>
          <div style={{textAlign:'right', color:'var(--muted)'}}>üë• Spieler: {Object.keys(players).length}</div>
        </div>

        <div style={{marginTop:10, display:'flex', gap:8}}>
          {(meta.phase === 'lobby' || !meta.phase) && <button className="btn btn-host" onClick={startGame}>Spiel starten</button>}
          {meta.phase === 'question' && <button className="btn btn-show-results" onClick={showResultsNow}>üìä Ergebnisse</button>}
          {(meta.phase === 'results' || meta.phase === 'roundSummary') && <button className="btn btn-host" onClick={startNextRound}>Weiter ‚Üí</button>}
          {meta.phase === 'finished' && <button className="btn btn-host" onClick={()=>window.location.reload()}>üîÑ Zur√ºck zur Lobby</button>}
        </div>

        {/* Kategorie-Status */}
        {meta && meta.categoryState && (
          <div style={{marginTop:12}}>
            <h4 style={{fontWeight:900}}>üîñ Kategorien</h4>
            <div style={{display:'flex', gap:8, flexWrap:'wrap', marginTop:8}}>
              {(meta.categoryState.used || []).map(c=>(
                <div key={c} style={{padding:'6px 10px', background:'rgba(255,255,255,0.02)'}}>{c} ‚úÖ</div>
              ))}
              {(meta.categoryState.remaining || []).map(c=>(
                <div key={c} style={{padding:'6px 10px', background:'rgba(255,255,255,0.01)'}}>{c}</div>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * HOST SCREEN (inkl. fixes)
   ****************************************/
  function HostScreen({ gameId, hostName }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      return ()=> { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    useEffect(()=>{
      if(!meta || meta.phase !== 'question' || !meta.questionStartTime){ setTimeLeft(0); return; }
      const tick = async ()=>{
        const elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000);
        const rem = Math.max(0, QUESTION_TIME - elapsed);
        setTimeLeft(rem);
        if(rem === 0) {
          await showResultsNow();
        }
      };
      tick();
      clearInterval(timerRef.current);
      timerRef.current = setInterval(tick, 500);
      return ()=> clearInterval(timerRef.current);
    },[meta?.phase, meta?.questionStartTime, gameId]);

    // Show results now: compute points, update scores, set lastPoints
    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g) return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if(!q) return;

        const playerObj = g.players || {};
        const updates = {};
        const actionLogRef = db.ref(`games/${gameId}/meta/actions/${qIndex}`);
        const actionsSnap = await actionLogRef.get();
        const actions = actionsSnap.exists() ? actionsSnap.val() : [];

        // For each player calculate points
        Object.entries(playerObj).forEach(([pid,p])=>{
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          let points = correct ? BASE_POINTS : 0;

          // Boost effect
          const boostActive = p.activeEffects && p.activeEffects.boost;
          if(correct && boostActive){
            points = Math.round(points * 1.5);
          }

          // Poisons
          const poisonArr = (p.activeEffects && p.activeEffects.poisonedBy) ? p.activeEffects.poisonedBy : [];
          const poisonCount = Array.isArray(poisonArr) ? poisonArr.length : 0;
          points -= (poisonCount * 20);
          if(points < 0) points = 0;

          const newScore = (p.score || 0) + points;
          updates[`games/${gameId}/players/${pid}/score`] = newScore;
          updates[`games/${gameId}/players/${pid}/lastPoints`] = points;
        });

        await db.ref().update(updates);

        // Standard: show results
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });

        // --- NEW: if this was the last question of a round -> show roundSummary instead ---
        const questionInRound = (qIndex + 1) % QUESTIONS_PER_ROUND;
        if (questionInRound === 0) {
          // set roundSummary (so players see summary and last-place can pick bonus)
          await db.ref(`games/${gameId}/meta`).update({ phase: 'roundSummary' });
        }
      }catch(e){ console.error(e); }
    };

    const startNextRound = async ()=>{
      if(!meta) return;

      // We'll base currentIndex on the stored meta.questionIndex
      const currentIndex = meta.questionIndex ?? 0;
      const totalQuestions = TOTAL_ROUNDS * QUESTIONS_PER_ROUND;

      // If we are currently on the roundSummary phase -> Host clicked "Weiter zur n√§chsten Runde"
      // We must advance to the first question of the next round and apply chosen category (if any).
      if (meta.phase === 'roundSummary') {
        // nextIndex is first question of next round = currentIndex + 1
        const nextIndex = currentIndex + 1;
        if (nextIndex >= totalQuestions) {
          await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
          return;
        }

        const nextRound = Math.floor(nextIndex / QUESTIONS_PER_ROUND) + 1;

        // Determine category to use for nextRound:
        const metaSnap = await db.ref(`games/${gameId}/meta`).get();
        const metaVal = metaSnap.val() || {};
        const catState = metaVal.categoryState || { used: [], remaining: [] };
        let nextCategory = metaVal.nextCategory || null;

        // If no nextCategory chosen -> take first remaining
        if (!nextCategory) {
          nextCategory = (catState.remaining || [])[0];
        }
        if (!nextCategory) {
          // fallback
          const fallback = CATEGORY_LIST.find(c => !(catState.used || []).includes(c));
          nextCategory = fallback || CATEGORY_LIST[0];
        }

        // update used/remaining
        const remaining = (catState.remaining || []).filter(c => c !== nextCategory);
        const used = [...(catState.used || []), nextCategory];
        await db.ref(`games/${gameId}/meta/categoryState`).set({ used, remaining });

        // Replace the block for that next round with questions of chosen category
        const start = (nextRound - 1) * QUESTIONS_PER_ROUND;
        const end = start + QUESTIONS_PER_ROUND;

        const qSnap = await db.ref(`games/${gameId}/questions`).get();
        const qArr = qSnap.exists() ? qSnap.val() : [];

        const usedQTexts = (qArr || []).map(q => q.question);
        const newBlock = getQuestionsForCategory(nextCategory, QUESTIONS_PER_ROUND, usedQTexts);

        const newQuestions = Array.isArray(qArr) ? qArr.slice() : [];
        for (let i = 0; i < newBlock.length; i++) {
          newQuestions[start + i] = newBlock[i];
        }
        await db.ref(`games/${gameId}/questions`).set(newQuestions);

        // Reset players' states
        const pSnap = await db.ref(`games/${gameId}/players`).get();
        const pObj = pSnap.val() || {};
        const updates = {};
        Object.keys(pObj).forEach(pid => {
          updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
          updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        });
        await db.ref().update(updates);

        // Finally set meta to start next question
        await db.ref(`games/${gameId}/meta`).update({
          questionIndex: nextIndex,
          phase: 'question',
          questionStartTime: Date.now(),
          round: nextRound,
          currentCategory: nextCategory,
          nextCategory: null
        });

        return;
      }

      // Normal flow from results -> next question within same round
      const qIndex = meta.questionIndex ?? 0;
      const nextIndex = qIndex + 1;
      if(nextIndex >= totalQuestions){
        await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
        return;
      }

      // check if entering a new round (shouldn't happen here if roundSummary flow used correctly)
      const currentRound = Math.floor(qIndex / QUESTIONS_PER_ROUND) + 1;
      const nextRound = Math.floor(nextIndex / QUESTIONS_PER_ROUND) + 1;
      if(nextRound > currentRound){
        // set roundSummary so host must press Continue to actually start the next round
        await db.ref(`games/${gameId}/meta`).update({ phase: 'roundSummary', round: nextRound });
        return;
      }

      // continue to next question in same round
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
      });
      await db.ref().update(updates);

      await db.ref(`games/${gameId}/meta`).update({
        questionIndex: nextIndex,
        phase: 'question',
        questionStartTime: Date.now(),
        round: nextRound
      });
    };

    const startGame = async ()=>{
      // choose 4 categories out of 6 for this game
      const categoriesForGame = shuffle(CATEGORY_LIST).slice(0, TOTAL_ROUNDS);
      let allQuestions = [];
      const usedQuestions = [];
      for (let r=0;r<categoriesForGame.length;r++){
        const cat = categoriesForGame[r];
        const block = getQuestionsForCategory(cat, QUESTIONS_PER_ROUND, usedQuestions);
        block.forEach(q => usedQuestions.push(q.question));
        allQuestions = allQuestions.concat(block);
      }

      // set questions and meta
      await db.ref(`games/${gameId}/questions`).set(allQuestions);

      const metaObj = { phase: 'question', questionIndex: 0, round: 1, questionStartTime: Date.now(), currentCategory: categoriesForGame[0] };
      await db.ref(`games/${gameId}/meta/categoryState`).set({ used: [], remaining: categoriesForGame });
      await db.ref(`games/${gameId}/meta`).set(metaObj);

      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        if(!(pObj[pid] && pObj[pid].items)){
          updates[`games/${gameId}/players/${pid}/items`] = DEFAULT_ITEMS;
        }
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
        updates[`games/${gameId}/players/${pid}/lastRoundBonus`] = null;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta/actions`).remove();
    };

    const backToLobby = async ()=>{
      await db.ref(`games/${gameId}/meta`).set({ phase: 'lobby' });
      await db.ref(`games/${gameId}/questions`).remove();
      await db.ref(`games/${gameId}/meta/categoryState`).remove();
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const updates = {};
      Object.keys(pObj).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/items`] = DEFAULT_ITEMS;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = { boost:false, shield:false, poisonedBy: [] };
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
        updates[`games/${gameId}/players/${pid}/lastRoundBonus`] = null;
      });
      await db.ref().update(updates);
    };

    if(!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const countdownClass = timeLeft <= 10 ? 'danger' : timeLeft <= 20 ? 'warning' : '';

    const showSidebar = meta.phase === 'lobby';

    return (
      <div className="min-h-screen host-screen">
        <div className={`host-main ${!showSidebar ? 'fullwidth' : ''}`}>
          {/* LOBBY */}
          {meta.phase === 'lobby' && (
            <div style={{display:'flex', flexDirection:'column', alignItems:'center', gap:12}}>
              <div style={{display:'flex', alignItems:'center', gap:12}}>
                <RTLLogo size="lg" />
                <div style={{fontWeight:900, fontSize:20}}>AdAlliance Quiz</div>
              </div>
              <h2 style={{fontSize:28, fontWeight:900}}>‚è≥ Warte auf Spieler</h2>
              <div style={{fontFamily:'monospace', background:'#fff', color:'#000', padding:'8px 12px', fontSize:20, fontWeight:900}}>{gameId}</div>
            </div>
          )}

          {/* QUESTION VIEW */}
          {meta.phase === 'question' && question && (
            <div>
              <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                <div style={{display:'flex', gap:12, alignItems:'center'}}>
                  <div className={`countdown-badge ${countdownClass}`}>{timeLeft}</div>
                  <div>
                    <div style={{fontSize:14, color:'var(--muted)'}}>Runde {meta.round}/{TOTAL_ROUNDS}</div>
                    <div style={{fontSize:14, color:'var(--muted)'}}>Frage {qIndex + 1}/{TOTAL_ROUNDS * QUESTIONS_PER_ROUND}</div>
                    <div style={{fontSize:12, color:'var(--muted)'}}>Kategorie: <strong style={{color:'var(--rtl-orange)'}}>{meta.currentCategory || question.category || '‚Äî'}</strong></div>
                  </div>
                </div>
                <div>
                  <button className="btn btn-show-results" onClick={showResultsNow}>üìä Ergebnisse</button>
                </div>
              </div>

              <div style={{marginTop:16}}>
                <div className="question-text">{question.question}</div>
                <div className="answers-grid" style={{marginTop:18}}>
                  {question.answers.map((a,i)=>((
                    <div key={i} className="answer-btn">
                      <div style={{fontWeight:900, marginRight:8}}>{String.fromCharCode(65+i)}.</div>
                      <div>{a}</div>
                    </div>
                  )))}
                </div>
              </div>
            </div>
          )}

          {/* RESULTS VIEW (Host) */}
          {meta.phase === 'results' && question && (
            <div>
              <h2 style={{fontSize:22, fontWeight:900, color:'var(--rtl-orange)'}}>üìä Ergebnisse</h2>
              <div style={{marginTop:8}}>‚úì Richtige Antwort: <strong>{question.answers[question.correct]}</strong></div>

              <div style={{marginTop:12}}>
                {question.answers.map((a,i)=>{
                  const voters = playersArr.filter(p => p.currentAnswer === i);
                  const isCorrect = i === question.correct;
                  return (
                    <div key={i} style={{padding:10, marginTop:8, background:isCorrect? '#fff' : 'rgba(255,255,255,0.02)', color:isCorrect? '#000' : 'var(--tile)'}}>
                      <div style={{fontWeight:900}}>{String.fromCharCode(65+i)}. {a}</div>
                      <div style={{opacity:0.8, marginTop:6}}>{voters.length > 0 ? voters.map(p => p.name).join(', ') : '(Niemand)'}</div>
                    </div>
                  );
                })}
              </div>

              <div style={{marginTop:16}}>
                <button className="btn btn-host" onClick={startNextRound}>N√§chste Frage / Weiter</button>
              </div>
            </div>
          )}

          {/* ROUND SUMMARY */}
          {meta.phase === 'roundSummary' && (
            <div>
              <h2 style={{fontSize:22, fontWeight:900, color:'var(--rtl-orange)'}}>üèÜ Zwischenstand nach Runde {meta.round - 1}</h2>
              <p style={{color:'var(--muted)'}}>Letzte Platzierte bekommen einen Bonus (Item + Kategorie-Auswahl).</p>

              <div style={{marginTop:12}}>
                {playersArr.map((p,i)=>(
                  <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:10, borderBottom:'1px solid rgba(255,255,255,0.03)'}}>
                    <div style={{fontWeight:900}}>{i<3? (i===0?'ü•á':i===1?'ü•à':'ü•â') : `#${i+1}`} {p.name}</div>
                    <div style={{fontWeight:900}}>{p.score || 0} pts</div>
                  </div>
                ))}
              </div>

              <div style={{marginTop:16}}>
                <button className="btn btn-host" onClick={startNextRound}>Weiter zur n√§chsten Runde ‚Üí</button>
              </div>
            </div>
          )}

          {/* FINISHED */}
          {meta.phase === 'finished' && (
            <div>
              <h2 style={{fontSize:28, fontWeight:900, color:'var(--rtl-orange)'}}>üéâ Spiel beendet!</h2>
              <div style={{marginTop:12}}>
                {playersArr.map((p,i)=>(
                  <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:8}}>
                    <div style={{fontWeight:700}}>{i+1}. {p.name}</div>
                    <div style={{fontWeight:900}}>{p.score || 0} pts</div>
                  </div>
                ))}
              </div>
              <div style={{marginTop:16}}>
                <button className="btn btn-host" onClick={backToLobby}>üîÑ Zur√ºck zur Lobby</button>
              </div>
            </div>
          )}

        </div>

        {/* Sidebar */}
        {showSidebar && (
          <div className="host-side">
            <HostController gameId={gameId} meta={meta} startNextRound={startNextRound} showResultsNow={showResultsNow} startGame={startGame} />
            <div style={{marginTop:12}}>
              <h4 style={{fontWeight:900}}>üèÖ Spieler & Punkte</h4>
              <div style={{marginTop:8}}>
                {playersArr.map((p,idx)=>(
                  <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:8, borderBottom:'1px solid rgba(255,255,255,0.03)'}}>
                    <div style={{fontWeight:700}}>{idx+1}. {p.name}</div>
                    <div style={{fontWeight:900}}>{p.score || 0} pts</div>
                  </div>
                ))}
              </div>
            </div>

            <div style={{marginTop:12}}>
              <h4 style={{fontWeight:900}}>‚ÑπÔ∏è Code & QR</h4>
              <div style={{marginTop:8}}>
                <div style={{fontFamily:'monospace', background:'#fff', color:'#000', padding:'6px'}}>{gameId}</div>
                <img src={qrUrlForGame(gameId)} alt="QR" style={{width:'100%', marginTop:8}} />
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * PLAYER VIEW (inkl. Poison Modal + Bonus Modal)
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);

    const [poisonModalOpen, setPoisonModalOpen] = useState(false);
    const [poisonTargets, setPoisonTargets] = useState([]);

    const [bonusModalOpen, setBonusModalOpen] = useState(false);
    const [selectedBonusItem, setSelectedBonusItem] = useState(null);
    const [selectedBonusCategory, setSelectedBonusCategory] = useState(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); mRef.off(); pRef.off(); };
    },[gameId, playerId]);

    useEffect(()=>{
      if(!meta || meta.phase !== 'question' || !meta.questionStartTime){ setTimeLeft(0); return; }
      const tick = ()=> {
        const elapsed = Math.floor((Date.now() - meta.questionStartTime)/1000);
        setTimeLeft(Math.max(0, QUESTION_TIME - elapsed));
      };
      tick();
      const t = setInterval(tick, 500);
      return ()=> clearInterval(t);
    },[meta?.questionStartTime, meta?.phase]);

    // Show bonus modal if last-placed and hasn't chosen for finished round
    useEffect(()=>{
      if(!game || !meta || !player) return;
      if(meta.phase !== 'roundSummary') {
        setBonusModalOpen(false);
        setSelectedBonusCategory(null);
        setSelectedBonusItem(null);
        return;
      }

      const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p}));
      if(playersArr.length === 0) return;
      const minScore = Math.min(...playersArr.map(p => p.score || 0));
      const lastPlayers = playersArr.filter(p => (p.score || 0) === minScore).map(p => p.pid);

      const finishedRoundNumber = (meta.round || 1) - 1;

      if(lastPlayers.includes(playerId) && (player.lastRoundBonus !== finishedRoundNumber)){
        setBonusModalOpen(true);
      } else {
        setBonusModalOpen(false);
      }
    },[game, meta, player]);

    if(!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];

    const openPoisonModal = ()=>{
      const entries = Object.entries(game.players || {}).filter(([pid]) => pid !== playerId).map(([pid,p]) => ({ pid, name: p.name }));
      setPoisonTargets(entries);
      setPoisonModalOpen(true);
    };

    const sendPoisonTo = async (targetPid) => {
      setPoisonModalOpen(false);
      if(!(player.items && player.items.poison > 0)) { alert('Kein Gift verf√ºgbar'); return; }
      const updates = {};
      updates[`games/${gameId}/players/${playerId}/items/poison`] = (player.items.poison - 1);

      const actionRef = db.ref(`games/${gameId}/meta/actions/${qIndex}`);
      const targetSnap = await db.ref(`games/${gameId}/players/${targetPid}`).get();
      if(!targetSnap.exists()){ await db.ref().update(updates); return; }
      const targetData = targetSnap.val();
      const targetShield = targetData.activeEffects && targetData.activeEffects.shield;
      const actionsSnap = await actionRef.get();
      const existingActions = actionsSnap.exists() ? actionsSnap.val() : [];

      if(targetShield){
        existingActions.push({ type:'poison', from: playerId, to: targetPid, blocked: true, ts: Date.now() });
        await actionRef.set(existingActions);
        await db.ref().update(updates);
        return;
      } else {
        const prev = (targetData.activeEffects && Array.isArray(targetData.activeEffects.poisonedBy)) ? targetData.activeEffects.poisonedBy : [];
        const next = [...prev, playerId];
        updates[`games/${gameId}/players/${targetPid}/activeEffects/poisonedBy`] = next;
        existingActions.push({ type:'poison', from: playerId, to: targetPid, blocked: false, ts: Date.now() });
        await actionRef.set(existingActions);
        await db.ref().update(updates);
        return;
      }
    };

    // QUESTION VIEW
    if(meta.phase === 'question' && question){
      const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
      const boostAvailable = (player.items && player.items.boost > 0);
      const poisonAvailable = (player.items && player.items.poison > 0);
      const shieldAvailable = (player.items && player.items.shield > 0);

      const answerClick = async (i)=>{
        if(hasAnswered || timeLeft <= 0) return;
        await db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i);
      };

      const activateBoost = async ()=>{
        if(!boostAvailable) return;
        if(player.currentAnswer !== null && player.currentAnswer !== undefined){ alert('Boost muss vor der Antwort aktiviert werden.'); return; }
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/items/boost`] = (player.items.boost - 1);
        updates[`games/${gameId}/players/${playerId}/activeEffects/boost`] = true;
        await db.ref().update(updates);
      };

      const activateShield = async ()=>{
        if(!shieldAvailable) return;
        const updates = {};
        updates[`games/${gameId}/players/${playerId}/items/shield`] = (player.items.shield - 1);
        updates[`games/${gameId}/players/${playerId}/activeEffects/shield`] = true;
        await db.ref().update(updates);
      };

      return (
        <div className="min-h-screen" style={{padding:20}}>
          <div className="player-card">
            <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
              <div style={{fontWeight:900}}>Runde {meta.round}/{TOTAL_ROUNDS}</div>
              <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)'}}>{timeLeft}s</div>
            </div>

            <h3 style={{fontSize:18,fontWeight:900, marginTop:12}}>{question.question}</h3>
            <div style={{fontSize:12, color:'var(--muted)', marginTop:6}}>Kategorie: <strong style={{color:'var(--rtl-orange)'}}>{meta.currentCategory || question.category}</strong></div>

            <div style={{marginTop:12}}>
              {question.answers.map((ans,i)=>{
                const disabled = hasAnswered || timeLeft <= 0;
                const isSelected = player.currentAnswer === i;
                const style = isSelected ? {background:'var(--rtl-purple)', color:'#fff'} : {};
                return <button key={i} disabled={disabled} onClick={()=>answerClick(i)} style={{display:'block', width:'100%', padding:12, marginTop:8, ...style}}>{String.fromCharCode(65+i)}. {ans}</button>;
              })}
            </div>

            <div style={{marginTop:12, display:'flex', justifyContent:'space-between', alignItems:'center'}}>
              <div style={{color:'var(--muted)'}}>{player.currentAnswer === null ? "Noch nicht geantwortet" : `Antwort: ${String.fromCharCode(65 + player.currentAnswer)}`}</div>
              <div style={{display:'flex', gap:8}}>
                <button className="bonus-choice" onClick={activateBoost} disabled={!boostAvailable || player.currentAnswer !== null}>üî• {player.items.boost}</button>
                <button className="bonus-choice" onClick={openPoisonModal} disabled={!poisonAvailable}>‚ò†Ô∏è {player.items.poison}</button>
                <button className="bonus-choice" onClick={activateShield} disabled={!shieldAvailable}>üõ° {player.items.shield}</button>
              </div>
            </div>

            <div style={{marginTop:10, color:'var(--muted)', fontSize:13}}>
              üî• Boost vor der Antwort; ‚ò†Ô∏è Gift per Modal; üõ° Schild wird sofort verbraucht.
            </div>
          </div>

          {/* Poison modal */}
          {poisonModalOpen && (
            <div className="modal-backdrop">
              <div className="modal-card">
                <div className="modal-title">Wen willst du vergiften?</div>
                <div style={{display:'flex', flexDirection:'column', gap:8}}>
                  {poisonTargets.length === 0 ? <div style={{color:'var(--muted)'}}>Keine anderen Spieler</div> : poisonTargets.map(t=>(
                    <button key={t.pid} className="btn btn-ghost" onClick={()=>sendPoisonTo(t.pid)} style={{display:'flex', justifyContent:'space-between'}}>{t.name}<span style={{color:'var(--muted)'}}>Vergiften</span></button>
                  ))}
                  <button className="btn btn-join" onClick={()=>setPoisonModalOpen(false)}>Abbrechen</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // RESULTS view
    if(meta.phase === 'results' && question){
      const wasCorrect = player.currentAnswer === question.correct;
      const poisonedBy = (player.activeEffects && player.activeEffects.poisonedBy) ? player.activeEffects.poisonedBy : [];
      const shieldActive = player.activeEffects && player.activeEffects.shield;
      const poisonMsg = poisonedBy.length === 0 ? (shieldActive ? 'Schild aktiv ‚Äî kein Gift' : 'Nicht vergiftet') : `Vergiftet von: ${poisonedBy.join(', ')}`;

      return (
        <div className="min-h-screen" style={{padding:20}}>
          <div className="player-card" style={{textAlign:'center'}}>
            <h3 style={{fontSize:22, fontWeight:900, color: wasCorrect ? 'var(--rtl-green)' : '#ff6b6b'}}>{wasCorrect ? 'Richtig! üéâ' : 'Falsch üòï'}</h3>
            <p>Richtige Antwort: <strong>{question.answers[question.correct]}</strong></p>
            <p>Punkte (diese Frage): <strong>{player.lastPoints || 0}</strong></p>
            <p>Punkte gesamt: <strong>{player.score || 0}</strong></p>
            <p style={{color:'var(--muted)'}}>Status: {poisonMsg}{shieldActive ? ' (Schild aktiv)' : ''}</p>
            <p style={{color:'var(--muted)'}}>Warte auf den Host...</p>
          </div>
        </div>
      );
    }

    // ROUND SUMMARY or FINISHED view (player)
    if(meta.phase === 'roundSummary' || meta.phase === 'finished'){
      const playersSorted = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      const title = meta.phase === 'finished' ? 'üéâ Spiel beendet!' : `üèÜ Zwischenstand nach Runde ${meta.round - 1}`;
      const finishedRound = (meta.round || 1) - 1;

      // Candidate categories (2) for bonus
      let candidateCats = [];
      if(meta.categoryState && Array.isArray(meta.categoryState.remaining)){
        candidateCats = shuffle(meta.categoryState.remaining).slice(0,2);
      } else {
        const used = (meta.categoryState && meta.categoryState.used) ? meta.categoryState.used : [];
        candidateCats = shuffle(CATEGORY_LIST.filter(c => !used.includes(c))).slice(0,2);
      }

      const commitBonus = async () => {
        if(!selectedBonusItem || !selectedBonusCategory){ alert('W√§hle Item und Kategorie'); return; }
        const updates = {};
        const curr = (player.items && player.items[selectedBonusItem]) ? player.items[selectedBonusItem] : 0;
        updates[`games/${gameId}/players/${playerId}/items/${selectedBonusItem}`] = curr + 1;
        updates[`games/${gameId}/players/${playerId}/lastRoundBonus`] = finishedRound;
        // set meta.nextCategory (Host uses this when starting next round)
        updates[`games/${gameId}/meta/nextCategory`] = selectedBonusCategory;
        await db.ref().update(updates);
        setBonusModalOpen(false);
        setSelectedBonusCategory(null);
        setSelectedBonusItem(null);
      };

      return (
        <div className="min-h-screen" style={{padding:20}}>
          <div className="player-card">
            <h3 style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)', textAlign:'center'}}>{title}</h3>
            <div style={{marginTop:12}}>
              {playersSorted.map((p,i)=>(
                <div key={p.pid} style={{display:'flex', justifyContent:'space-between', padding:8, borderBottom:'1px solid rgba(255,255,255,0.03)'}}>
                  <div style={{fontWeight:700}}>{i+1}. {p.name}</div>
                  <div style={{fontWeight:900}}>{p.score || 0} pts</div>
                </div>
              ))}
            </div>
            <p style={{color:'var(--muted)', marginTop:10}}>Warte auf den Host... oder w√§hle deinen Bonus, wenn du letzter bist.</p>
          </div>

          {/* BONUS MODAL (Item + Kategorie) */}
          {bonusModalOpen && (
            <div className="modal-backdrop">
              <div className="modal-card">
                <div className="modal-title">üéÅ Bonus: Item + Kategorie w√§hlen</div>
                <p style={{textAlign:'center', color:'var(--muted)'}}>W√§hle 1 Item (Vorrat +1) und 1 Kategorie (f√ºr n√§chste Runde).</p>

                <h4 style={{marginTop:12, fontWeight:900}}>Item</h4>
                <div className="bonus-grid">
                  <div className="bonus-choice" style={{background: selectedBonusItem === 'boost' ? '#fff3cc' : undefined}} onClick={()=>setSelectedBonusItem('boost')}>üî• Boost +1</div>
                  <div className="bonus-choice" style={{background: selectedBonusItem === 'poison' ? '#ffd6d6' : undefined}} onClick={()=>setSelectedBonusItem('poison')}>‚ò†Ô∏è Gift +1</div>
                  <div className="bonus-choice" style={{background: selectedBonusItem === 'shield' ? '#dbeeff' : undefined}} onClick={()=>setSelectedBonusItem('shield')}>üõ° Schild +1</div>
                </div>

                <h4 style={{marginTop:14, fontWeight:900}}>Kategorie (w√§hle 1 von 2)</h4>
                <div className="bonus-grid">
                  {candidateCats.length === 0 ? <div style={{color:'var(--muted)'}}>Keine Kategorien verf√ºgbar</div> : candidateCats.map(c=>(
                    <div key={c} className="bonus-choice" style={{background: selectedBonusCategory === c ? '#fff' : undefined, color: selectedBonusCategory === c ? '#000' : undefined}} onClick={()=>setSelectedBonusCategory(c)}>{c}</div>
                  ))}
                </div>

                <div style={{display:'flex', gap:8, justifyContent:'center', marginTop:12}}>
                  <button className="btn btn-host" onClick={commitBonus}>Best√§tigen</button>
                  <button className="btn btn-join" onClick={()=>{
                    setBonusModalOpen(false);
                    setSelectedBonusCategory(null);
                    setSelectedBonusItem(null);
                  }}>Sp√§ter</button>
                </div>
              </div>
            </div>
          )}

        </div>
      );
    }

    return <div>Warte...</div>;
  }

  /****************************************
   * PLAYER JOIN
   ****************************************/
  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');
    const [error,setError] = useState('');

    const handleJoin = async ()=>{
      setError('');
      try{
        const snap = await db.ref(`games/${joinGameId}`).get();
        if(!snap.exists()){ setError('Spiel nicht gefunden'); return; }
        const pid = makePlayerId();
        const playerObj = {
          name,
          score: 0,
          currentAnswer: null,
          joinedAt: Date.now(),
          items: DEFAULT_ITEMS,
          activeEffects: { boost:false, shield:false, poisonedBy: [] },
          lastPoints: 0,
          lastRoundBonus: null
        };
        await db.ref(`games/${joinGameId}/players/${pid}`).set(playerObj);
        localStorage.setItem(`quiz_player_${joinGameId}`, pid);
        localStorage.setItem(`quiz_name_${joinGameId}`, name);
        onJoined(joinGameId, pid, name);
      }catch(e){ console.error(e); setError('Fehler beim Beitreten'); }
    };

    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div className="player-card">
          <div style={{display:'flex', gap:12, alignItems:'center'}}>
            <RTLLogo size="sm" />
            <div style={{fontWeight:900}}>AdAlliance</div>
          </div>
          <h2 style={{fontSize:20, fontWeight:900, marginTop:8, color:'var(--rtl-orange)'}}>Spiel beitreten</h2>
          <p>Code: <span style={{fontFamily:'monospace'}}>{joinGameId}</span></p>
          <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} />
          <button className="btn btn-host w-full" onClick={handleJoin} disabled={!name}>Beitreten</button>
          {error && <div style={{color:'#ff6b6b', marginTop:8}}>{error}</div>}
        </div>
      </div>
    );
  }

  /****************************************
   * APP
   ****************************************/
  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');
    const [playerName,setPlayerName] = useState('');
    const [hostName,setHostName] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ setMode('playerJoin'); setGameId(joinCode); }
    },[]);

    const handleCreate = async (name)=>{
      setHostName(name);
      const gid = randomGameID();
      setGameId(gid);
      await db.ref(`games/${gid}/meta`).set({ phase: 'lobby' });
      setMode('hostLobby');
    };

    const handleJoin = async (name, code)=>{
      try{
        const snap = await db.ref(`games/${code}`).get();
        if(!snap.exists()){ alert('Spiel nicht gefunden'); return; }
        const pid = makePlayerId();
        const playerObj = {
          name,
          score: 0,
          currentAnswer: null,
          joinedAt: Date.now(),
          items: DEFAULT_ITEMS,
          activeEffects: { boost:false, shield:false, poisonedBy: [] },
          lastPoints: 0,
          lastRoundBonus: null
        };
        await db.ref(`games/${code}/players/${pid}`).set(playerObj);
        setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame');
      }catch(e){ console.error(e); alert('Fehler'); }
    };

    const handlePlayerJoined = (code,pid,name) => { setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} hostName={hostName} />}
        {mode === 'playerGame' && <PlayerView gameId={gameId} playerId={playerId} />}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }

  ReactDOM.render(<App />, document.getElementById('root'));

  /************ Utility ************/
  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=300`;
  }

  </script>
</body>
</html>










