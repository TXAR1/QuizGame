<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTL AdAlliance Quiz - Item System V9</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    /* RTL United Font */
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-Regular.woff') format('woff');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-RegularItalic.woff') format('woff');
      font-weight: 400;
      font-style: italic;
    }
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-Light.woff') format('woff');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-LightItalic.woff') format('woff');
      font-weight: 300;
      font-style: italic;
    }
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-Bold.woff') format('woff');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'RTL United';
      src: url('Font/RTLUnitedText-BoldItalic.woff') format('woff');
      font-weight: 700;
      font-style: italic;
    }
  </style>

  <style>
    :root{
      --rtl-orange:#FF6600;
      --rtl-purple:#7B2CBF;
      --bg:#0b0b0b;
      --tile:#ffffff;
      --muted:rgba(255,255,255,0.65);
    }
    
    * { border-radius: 0px !important; }
    button, div, span, input, img { border-radius: 0px !important; }

    html,body,#root{height:100%;margin:0;font-family:'RTL United', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden;}
    body{ background:var(--bg); color:var(--tile); }
    
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: var(--rtl-orange); }
    ::-webkit-scrollbar-thumb:hover { background: #ff8533; }

    input, textarea, select { background: white !important; color: #0b0b0b !important; border: 1px solid rgba(0,0,0,0.1); padding: 12px; font-weight: 600; }
    
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; font-weight:900; padding:14px 28px; cursor:pointer; border:none; background:rgba(255,255,255,0.1); color:var(--tile); font-size:18px; text-transform: uppercase; letter-spacing: 1px; border: 1px solid rgba(255,255,255,0.1); }
    .btn:hover { background:rgba(255,255,255,0.25); }

    .btn-host{ background:var(--rtl-orange); color:white; border: 1px solid var(--rtl-orange); }
    .btn-host:hover { background: #ff7b24; }
    
    .btn-join{ background:var(--rtl-purple); color:white; border: 1px solid var(--rtl-purple); }
    
    .btn-pause-gold {
      background: #FFD700;
      color: #000;
      border: 2px solid #fff;
      font-weight: 900;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 50;
    }
    .btn-pause-gold:hover { background: #ffeb3b; }

    .btn-show-results{
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: var(--tile);
    }
    .btn-show-results:hover { background: rgba(255,255,255,0.3); }

    .card{ padding:30px; background: #111; border:2px solid rgba(255,255,255,0.2); }
    
    .host-screen{ display:flex; width: 100%; height:100vh; overflow:hidden; position: relative; background: var(--bg); }
    .host-main{ flex:1; display:flex; flex-direction:column; height: 100%; position: relative; }
    
    .host-main-inner {
        padding: 40px;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #0a0a0a;
    }

    .game-top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 40px;
        background: #000;
        border-bottom: 2px solid rgba(255,255,255,0.08);
        height: 130px;
    }

    .countdown-badge{ width:90px; height:90px; display:flex; align-items:center; justify-content:center; font-size:2.8rem; font-weight:900; color:var(--tile); border:4px solid rgba(255,255,255,0.15); background:#000; }
    .countdown-badge.warning{ border-color:var(--rtl-orange); color:var(--rtl-orange); }
    .countdown-badge.danger{ border-color:var(--rtl-orange); color:var(--rtl-orange); background: rgba(255,102,0,0.1); }
    
    .question-area { 
        flex-grow: 1; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        padding: 20px 60px; 
        text-align: center;
    }
    .question-text {
        font-size: 6vh;
        font-weight: 900;
        line-height: 1.2;
    }

    .answers-grid{ display:grid; grid-template-columns:repeat(2, 1fr); gap:24px; height: 35vh; margin-top: auto; }
    .answer-btn{ background: #fff; color:#0b0b0b; padding:30px; font-size:1.8rem; font-weight:800; height: 100%; display:flex; align-items: center; gap:24px; border: none; }
    
    .results-split-view { display: grid; grid-template-columns: 4fr 3fr; gap: 40px; height: 100%; overflow: hidden; }
    .results-col { display: flex; flex-direction: column; gap: 16px; overflow: hidden; max-height: 100%; }
    .scroll-area { overflow-y: auto; padding-right: 8px; }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.95); display:flex; align-items:center; justify-content:center; z-index:9999; }
    .modal-card{ width:95%; max-width:600px; background:#000; border:3px solid var(--rtl-orange); padding:40px; color:var(--tile); }
    
    .toggle-switch { position: relative; display: inline-block; width: 60px; height: 32px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: .2s; }
    input:checked + .toggle-slider { background-color: var(--rtl-orange); }
    
    .action-log-item { padding: 12px; background: rgba(255,255,255,0.03); border-left: 5px solid rgba(255,255,255,0.1); margin-bottom: 8px; font-size: 15px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
    .action-log-item img { width: 20px; height: 20px; object-fit: contain; flex-shrink: 0; }
    .action-log-item.boost { border-left-color: var(--rtl-orange); }
    .action-log-item.poison { border-left-color: var(--rtl-orange); }
    .action-log-item.shield { border-left-color: var(--rtl-purple); }
    .action-log-item.trade { border-left-color: var(--rtl-orange); }
    .action-log-item.karma { border-left-color: #ffffff; background: rgba(255,255,255,0.1); }

    /* NEW: Item Slot Styling */
    .item-slot {
      width: 80px;
      height: 80px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      position: relative;
    }
    .item-slot:hover { background: rgba(255,255,255,0.1); }
    .item-slot.empty { opacity: 0.3; cursor: default; }
    .item-slot.active { border-color: var(--rtl-orange); }
    
    .rarity-common { border-color: rgba(255,255,255,0.3); }
    .rarity-uncommon { border-color: rgba(255,255,255,0.3); }
    .rarity-rare { border-color: rgba(255,255,255,0.3); }
    .rarity-legendary { border-color: rgba(255,255,255,0.3); }

    .lobby-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 15px;
        padding: 20px;
    }
    .lobby-player-chip {
        background: rgba(255,255,255,0.08);
        border: 2px solid rgba(255,255,255,0.2);
        padding: 15px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 20px;
        font-weight: 700;
    }

    .podium-container { display: flex; align-items: flex-end; justify-content: center; gap: 60px; margin-top: 80px; padding: 0 40px; }
    .podium-place { display: flex; flex-direction: column; align-items: center; text-align: center; position: relative; animation: podiumRise 0.8s ease-out; }

    @keyframes podiumRise {
      from { transform: translateY(100px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .podium-bar {
      width: 220px;
      background: linear-gradient(180deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 30px;
      font-size: 120px;
      font-weight: 900;
      border-radius: 8px 8px 0 0;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      position: relative;
    }

    .podium-1 .podium-bar {
      height: 400px;
      background: linear-gradient(180deg, #FFD700, #FFA500);
      color: rgba(0,0,0,0.3);
      border: 6px solid #FFD700;
      box-shadow: 0 0 60px rgba(255,215,0,0.6), 0 10px 40px rgba(0,0,0,0.5);
    }
    .podium-2 .podium-bar {
      height: 300px;
      background: linear-gradient(180deg, #E8E8E8, #A0A0A0);
      color: rgba(0,0,0,0.3);
      border: 5px solid #C0C0C0;
      box-shadow: 0 0 40px rgba(192,192,192,0.4), 0 10px 40px rgba(0,0,0,0.5);
    }
    .podium-3 .podium-bar {
      height: 220px;
      background: linear-gradient(180deg, #CD853F, #8B4513);
      color: rgba(0,0,0,0.3);
      border: 5px solid #CD7F32;
      box-shadow: 0 0 40px rgba(205,127,50,0.4), 0 10px 40px rgba(0,0,0,0.5);
    }

    .winner-name { font-size: 2.5rem; font-weight: 900; margin-bottom: 15px; text-shadow: 2px 2px 8px rgba(0,0,0,0.5); }
    .winner-score {
      font-size: 2rem;
      color: white;
      margin-bottom: 20px;
      padding: 8px 20px;
      background: rgba(0,0,0,0.4);
      border-radius: 20px;
      font-weight: 700;
    }

    .podium-1 .winner-name { color: #FFD700; font-size: 3rem; }
    .podium-2 .winner-name { color: #E8E8E8; }
    .podium-3 .winner-name { color: #CD853F; }

    .reveal-correct {
        background: #fff !important;
        color: #000 !important;
        border: 5px solid #000 !important;
    }

    .frozen-overlay {
      position: absolute;
      inset: 0;
      background: rgba(100, 150, 255, 0.8);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: 900;
      color: white;
      border: 4px solid #6496FF;
    }

    /* Item Box Simple Display */
    .item-roulette-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    .item-box-container {
      position: relative;
      width: 400px;
      height: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    .item-box-display {
      width: 200px;
      height: 200px;
      border: 6px solid var(--rtl-orange);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 100px;
      position: relative;
      overflow: hidden;
    }

    .item-roulette-strip {
      display: flex;
      flex-direction: column;
      position: absolute;
      animation: roulette-spin 0.1s linear infinite;
    }

    .item-roulette-strip.slowing {
      animation: roulette-slow 0.3s ease-out infinite;
    }

    .item-roulette-strip.stopping {
      animation: roulette-stop 0.5s ease-out forwards;
    }

    @keyframes roulette-spin {
      from { transform: translateY(0); }
      to { transform: translateY(-100px); }
    }

    @keyframes roulette-slow {
      from { transform: translateY(0); }
      to { transform: translateY(-100px); }
    }

    @keyframes roulette-stop {
      from { transform: translateY(0); }
      to { transform: translateY(-50px); }
    }

    .roulette-item {
      width: 200px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
      background: rgba(255,255,255,0.05);
      border-bottom: 2px solid rgba(255,255,255,0.2);
      flex-shrink: 0;
    }

    .roulette-item.mystery {
      font-size: 70px;
      color: var(--rtl-orange);
    }

    .item-revealed {
      animation: item-reveal 0.6s ease-out;
    }

    @keyframes item-reveal {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }

    .item-box-text {
      font-size: 28px;
      font-weight: 900;
      color: var(--rtl-orange);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .item-box-info {
      text-align: center;
      margin-top: 20px;
    }

    .item-box-info h3 {
      font-size: 32px;
      font-weight: 900;
      color: white;
      margin-bottom: 10px;
    }

    .item-box-info .rarity-badge {
      display: inline-block;
      padding: 8px 20px;
      font-size: 16px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 15px;
    }

    .item-box-info .rarity-badge.common { background: rgba(255,255,255,0.2); color: white; }
    .item-box-info .rarity-badge.uncommon { background: rgba(255,255,255,0.2); color: white; }
    .item-box-info .rarity-badge.rare { background: rgba(255,255,255,0.2); color: white; }
    .item-box-info .rarity-badge.legendary { background: rgba(255,255,255,0.2); color: white; }

    /* Round Start Overlay */
    .round-start-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .round-start-content {
      text-align: center;
      padding: 60px;
      background: #000;
      border: 4px solid var(--rtl-orange);
    }

    .round-start-content h2 {
      font-size: 72px;
      font-weight: 900;
      color: var(--rtl-orange);
      margin: 0 0 20px 0;
      text-transform: uppercase;
      letter-spacing: 4px;
    }

    .points-label {
      font-size: 18px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 10px;
    }

    .points-info {
      font-size: 56px;
      font-weight: 900;
      color: white;
    }

    /* Attack Notification */
    .attack-notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      background: var(--rtl-orange);
      color: white;
      padding: 20px 40px;
      border: 4px solid #000;
      text-align: center;
      min-width: 300px;
    }

    .attack-notification h3 {
      margin: 0 0 10px 0;
      font-size: 24px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .attack-notification p {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }

    /* Item Tooltip */
    .item-tooltip {
      position: fixed;
      background: #000;
      border: 3px solid var(--rtl-orange);
      padding: 20px;
      z-index: 9999;
      min-width: 250px;
      max-width: 300px;
      pointer-events: none;
    }

    .item-tooltip h4 {
      margin: 0 0 10px 0;
      font-size: 20px;
      font-weight: 900;
      color: white;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .item-tooltip p {
      margin: 10px 0 0 0;
      font-size: 14px;
      color: var(--muted);
      line-height: 1.4;
    }

    .rarity-mini {
      display: inline-block;
      padding: 4px 10px;
      font-size: 10px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 3px !important;
    }

    .rarity-mini.common { background: rgba(255,255,255,0.2); color: white; }
    .rarity-mini.uncommon { background: rgba(255,255,255,0.2); color: white; }
    .rarity-mini.rare { background: rgba(255,255,255,0.2); color: white; }
    .rarity-mini.legendary { background: rgba(255,255,255,0.2); color: white; }

    /* Items Info Modal */
    .items-info-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
    }

    .items-info-content {
      background: #000;
      border: 4px solid var(--rtl-orange);
      padding: 40px;
      max-width: 800px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .items-info-content h2 {
      margin: 0 0 30px 0;
      font-size: 36px;
      font-weight: 900;
      color: var(--rtl-orange);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .item-info-card {
      background: rgba(255, 255, 255, 0.03);
      border-left: 4px solid rgba(255, 255, 255, 0.2);
      padding: 20px;
      margin-bottom: 15px;
    }

    .item-info-card:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .item-info-card.common { border-left-color: rgba(255,255,255,0.3); }
    .item-info-card.uncommon { border-left-color: rgba(255,255,255,0.3); }
    .item-info-card.rare { border-left-color: rgba(255,255,255,0.3); }
    .item-info-card.legendary { border-left-color: rgba(255,255,255,0.3); }

    .item-info-card h4 {
      margin: 0 0 10px 0;
      font-size: 20px;
      font-weight: 900;
      color: white;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .item-info-card p {
      margin: 5px 0;
      font-size: 14px;
      color: var(--muted);
      line-height: 1.5;
    }

    /* Mobile Optimizations for Player View */
    @media (max-width: 768px) {
      html, body, #root {
        overflow-y: auto;
        overflow-x: hidden;
        height: auto;
        min-height: 100vh;
      }

      .card {
        padding: 12px !important;
        margin: 8px;
      }

      .min-h-screen {
        min-height: 100vh;
        height: auto;
        padding: 8px !important;
      }

      /* Question text on mobile */
      h3 {
        font-size: 18px !important;
        line-height: 1.35 !important;
      }

      /* Item slots on mobile */
      .item-slot {
        width: 60px !important;
        height: 60px !important;
        font-size: 32px !important;
      }

      /* Info button smaller on mobile */
      .btn {
        font-size: 14px !important;
        padding: 10px 16px !important;
      }

      /* Modal optimizations */
      .modal-card {
        width: 90% !important;
        padding: 20px !important;
        max-width: none !important;
      }

      .modal-card h3 {
        font-size: 20px !important;
      }

      /* Items info modal */
      .items-info-content {
        padding: 20px !important;
        max-height: 85vh !important;
      }

      .items-info-content h2 {
        font-size: 24px !important;
        margin-bottom: 20px !important;
      }

      .item-info-card {
        padding: 12px !important;
        margin-bottom: 10px !important;
      }

      .item-info-card h4 {
        font-size: 16px !important;
        gap: 8px !important;
      }

      .item-info-card p {
        font-size: 13px !important;
      }

      /* Roulette overlay mobile */
      .item-box-container {
        width: 90% !important;
        max-width: 350px !important;
      }

      .item-box-display {
        width: 150px !important;
        height: 150px !important;
      }

      .item-box-text {
        font-size: 20px !important;
      }

      .item-box-info h3 {
        font-size: 24px !important;
      }

      /* Attack notification smaller */
      .attack-notification {
        min-width: 250px !important;
        padding: 15px 20px !important;
      }

      .attack-notification h3 {
        font-size: 18px !important;
      }

      .attack-notification p {
        font-size: 14px !important;
      }

      /* Results view */
      div[style*="fontSize:80"] {
        font-size: 50px !important;
      }

      div[style*="fontSize:60"] {
        font-size: 40px !important;
      }

      div[style*="fontSize:32"] {
        font-size: 24px !important;
      }

      /* Frozen overlay text */
      .frozen-overlay {
        font-size: 32px !important;
      }

      /* Player join screen */
      input[style*="fontSize"] {
        font-size: 18px !important;
      }

      /* Pause/Finished screen optimizations */
      div[style*="fontSize:48"] {
        font-size: 28px !important;
      }
    }

    /* Extra small devices */
    @media (max-width: 480px) {
      .card {
        padding: 10px !important;
        margin: 4px;
      }

      h3 {
        font-size: 17px !important;
      }

      .item-slot {
        width: 55px !important;
        height: 55px !important;
      }

      .item-box-display {
        width: 120px !important;
        height: 120px !important;
      }

      .items-info-content h2 {
        font-size: 20px !important;
      }
    }

  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  /************ CONFIG ************/
  const TOTAL_ROUNDS = 4;
  const QUESTIONS_PER_ROUND = 10;
  const QUESTION_TIME = 60; // CHANGED: 60 seconds
  
  const ROUND_POINTS = { 1: 100, 2: 200, 3: 400, 4: 800 };
  
  const FINAL_QUESTIONS = 5;
  const FINAL_TIME = 60;
  const FINAL_ROUND_POINTS = [500, 750, 1000, 1500, 2000];

  /************ NEW: ITEM SYSTEM ************/
  const ITEM_SLOTS = 2; // Each player has 2 slots

  const ITEM_TYPES = {
    // DEFENSIVE (Common - für TOP Spieler)
    SCHILD: { id: 'schild', name: 'Schild', icon: 'icons/Schild.png', rarity: 'common', effect: 'shield', needsTarget: false, description: 'Schützt dich vor allen Angriffen und reflektiert Attacken mit 10% Schaden' },
    MAGNET: { id: 'magnet', name: 'Magnet', icon: 'icons/Punktemagnet.png', rarity: 'common', effect: 'magnet', needsTarget: false, description: 'Bonus wenn andere richtig: +15% pro Spieler' },
    FOKUS: { id: 'fokus', name: 'Fokus', icon: 'icons/Fragezeichen.png', rarity: 'common', effect: 'focus', needsTarget: false, description: 'Zeigt an ob deine Antwort richtig ist, bevor du bestätigst' },

    // STRATEGISCH (Uncommon - für MID Spieler)
    SPIEGELGLAS: { id: 'spiegelglas', name: 'Geistesblitz', icon: 'icons/Geistesblitz.png', rarity: 'uncommon', effect: 'mirror', needsTarget: false, description: 'Zeigt die meistgewählte Antwort' },
    ZAPFER: { id: 'zapfer', name: 'Frage-Zapfer', icon: 'icons/Fragezeichen.png', rarity: 'uncommon', effect: '5050', needsTarget: false, description: 'Eliminiert 2 falsche Antworten (50/50)' },
    SCANNER: { id: 'scanner', name: 'Antwort-Scanner', icon: 'icons/Antwort-Scanner.png', rarity: 'uncommon', effect: 'scanner', needsTarget: true, description: 'Zeigt dir die Antwort eines anderen Spielers' },

    // AGGRESSIV (Rare - für LOW Spieler zum Aufholen)
    GIFTPFEIL: { id: 'giftpfeil', name: 'Attacke', icon: 'icons/Attacke.png', rarity: 'rare', effect: 'poison', needsTarget: true, description: 'Reduziert die Punkte eines Gegners um 25%' },
    ZEITSCHNAPPER: { id: 'zeitschnapper', name: 'Zeitschnapper', icon: 'icons/Zeitschnapper.png', rarity: 'rare', effect: 'time_reduce', needsTarget: true, description: 'Reduziert die Zeit eines Gegners um 20 Sekunden (min. 10s bleiben)' },
    NEHMER: { id: 'nehmer', name: 'Nehmer', icon: 'icons/Fragezeichen.png', rarity: 'rare', effect: 'steal_item', needsTarget: true, description: 'Stiehlt ein zufälliges Item von einem Gegner (keine legendären)' },
    TURBO: { id: 'turbo', name: 'Turbo-Boost', icon: 'icons/Boost.png', rarity: 'rare', effect: 'boost', needsTarget: false, description: 'Erhöht deine Punkte bei richtiger Antwort um 30%' },
    FREEZE: { id: 'freeze', name: 'Stillmacher', icon: 'icons/Stillmacher.png', rarity: 'rare', effect: 'freeze', needsTarget: true, description: 'Friert einen Gegner für 8 Sekunden ein' },

    // CHAOS (Legendary)
    PLATZTAUSCHER: { id: 'platztauscher', name: 'Platztauscher', icon: 'icons/Punktetausch.png', rarity: 'legendary', effect: 'swap_points', needsTarget: false, description: 'Tauscht deine Punkte mit einem zufälligen Spieler' }
  };

  // Rarity weights for item distribution (catch-up mechanic)
  // Je schlechter die Platzierung, desto seltener die Items!
  const RARITY_WEIGHTS = {
    // TOP 1/3 - Hauptsächlich Common Items (Position verteidigen)
    top: { common: 70, uncommon: 25, rare: 5, legendary: 0 },

    // MIDDLE 1/3 - Mix mit mehr Uncommon
    mid: { common: 40, uncommon: 45, rare: 12, legendary: 3 },

    // LOW 1/3 - Viel Rare & Legendary! (Starke Aufholchance)
    low: { common: 15, uncommon: 30, rare: 40, legendary: 15 }
  };

  function getRandomItem(playerPosition) {
    const weights = RARITY_WEIGHTS[playerPosition] || RARITY_WEIGHTS.mid;
    const rarityRoll = Math.random() * 100;
    
    let rarity = 'common';
    let cumulative = 0;
    for (const [r, weight] of Object.entries(weights)) {
      cumulative += weight;
      if (rarityRoll <= cumulative) {
        rarity = r;
        break;
      }
    }
    
    const itemsOfRarity = Object.values(ITEM_TYPES).filter(item => item.rarity === rarity);
    return itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
  }

  function getPlayerPosition(playerScore, allScores) {
    const sorted = allScores.sort((a, b) => b - a);
    const third = Math.ceil(sorted.length / 3);
    const playerRank = sorted.indexOf(playerScore);
    
    if (playerRank < third) return 'top';
    if (playerRank < third * 2) return 'mid';
    return 'low';
  }

  /************ Firebase Setup ************/
  const firebaseConfig = {
    apiKey: "AIzaSyCsxAEsivsJVFVcnerdAWezFpruoCv7Z2I",
    authDomain: "qiuz-64055.firebaseapp.com",
    databaseURL: "https://qiuz-64055-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "qiuz-64055",
    storageBucket: "qiuz-64055.firebasedatabase.app",
    messagingSenderId: "605853616985",
    appId: "1:605853616985:web:95579b246a10d89ba51a48"
  };
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /************ Question Pool ************/
  // Load questions from JSON file
  let QUESTION_POOL = [];
  let FINAL_QUESTION_POOL = [];
  let CATEGORY_LIST = [];

  // Load questions from external JSON file
  fetch('questions.json')
    .then(response => response.json())
    .then(data => {
      QUESTION_POOL = data.questions || [];
      FINAL_QUESTION_POOL = data.finalQuestions || [];
      // Extract unique categories from questions
      CATEGORY_LIST = [...new Set(QUESTION_POOL.map(q => q.category))];
      console.log('Questions loaded:', QUESTION_POOL.length, 'Final questions:', FINAL_QUESTION_POOL.length);
    })
    .catch(error => {
      console.error('Error loading questions:', error);
      alert('Fehler beim Laden der Fragen. Bitte Seite neu laden.');
    });

  function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
  function randomGameID(){ return Math.random().toString(36).substr(2,6).toUpperCase(); }
  function makePlayerId(){ return Date.now().toString(36) + Math.random().toString(36).substr(2,4); }

  function getQuestionsForCategory(category, count, usedQuestions = []) {
    let pool = QUESTION_POOL.filter(q => q.category === category && !usedQuestions.includes(q.question));
    if (pool.length < count) {
      const fallbackPool = QUESTION_POOL.filter(q => !usedQuestions.includes(q.question));
      pool = fallbackPool.length > 0 ? fallbackPool : QUESTION_POOL.filter(q => q.category === category);
    }
    pool = shuffle(pool).slice(0, count);
    return pool.map((q, idx) => ({ 
      id: `${category}-${Date.now()}-${Math.random().toString(36).substr(2,5)}-${idx}`, 
      ...q 
    }));
  }

  function RTLLogo({ size = "md" }) {
    const sizeMap = { sm: 40, md: 60, lg: 80 };
    const height = sizeMap[size] || 60;
    return <img src="Logo.png" alt="Logo" style={{ height, width: "auto" }} />;
  }

  // Helper function to render item icons
  function ItemIcon({ icon, size = 36, style = {} }) {
    if (icon && icon.startsWith('icons/')) {
      return <img src={icon} alt="Item" style={{ width: size, height: size, objectFit: 'contain', ...style }} />;
    }
    return <span style={{ fontSize: size, ...style }}>{icon || '❓'}</span>;
  }

  function qrUrlForGame(gameId){
    const url = `${window.location.origin}${window.location.pathname}?join=${gameId}`;
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&size=500&margin=1&dark=000000&light=ffffff`;
  }

  // Translate rarity names to German
  function translateRarity(rarity) {
    const translations = {
      'common': 'Häufig',
      'uncommon': 'Ungewöhnlich',
      'rare': 'Selten',
      'legendary': 'Legendär'
    };
    return translations[rarity] || rarity;
  }

  // Confetti removed for simpler 2D design

  /****************************************
   * START SCREEN
   ****************************************/
  function StartScreen({ onCreate, onJoin }){
    const [name,setName] = useState('');
    const [code,setCode] = useState('');
    return (
      <div className="min-h-screen flex items-center justify-center p-6" style={{background:'var(--bg)'}}>
        <div style={{maxWidth:760, width:'100%'}} className="card">
          <div style={{display:'flex', alignItems:'center', gap:12}}>
            <RTLLogo size="md" />
            <div style={{fontWeight:900, fontSize:24}}>AdAlliance Quiz</div>
          </div>
          <h1 style={{fontSize:32, fontWeight:900, marginTop:20, color:'var(--rtl-orange)'}}>Quiz Master</h1>
          <div style={{marginTop:30}}>
            <input className="w-full p-3 mb-3" placeholder="Dein Name" value={name} onChange={e=>setName(e.target.value)} style={{fontSize:18}} />
            <div style={{display:'flex', gap:12}}>
              <button className="btn btn-host flex-1" onClick={()=>onCreate(name)} disabled={!name}>Host werden</button>
              <input className="p-2" placeholder="Code" value={code} onChange={e=>setCode(e.target.value.toUpperCase())} style={{width:'140px', textAlign:'center', fontSize:18, fontWeight:900}} />
              <button className="btn btn-join" onClick={()=>onJoin(name,code)} disabled={!name || !code}>Beitreten</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /****************************************
   * HOST SCREEN
   ****************************************/
  function HostScreen({ gameId, hostName }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [pauseModalOpen, setPauseModalOpen] = useState(false);
    const [finaleEnabled, setFinaleEnabled] = useState(true);
    const [revealAnswer, setRevealAnswer] = useState(false);
    const timerRef = useRef(null);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => {
        const val = snap.val();
        setMeta(val);
        if (val && val.finaleEnabled !== undefined) setFinaleEnabled(val.finaleEnabled);
      });
      return ()=> { gRef.off(); mRef.off(); clearInterval(timerRef.current); };
    },[gameId]);

    useEffect(()=>{
      if(!meta) { setTimeLeft(0); return; }
      if((meta.phase === 'question' && meta.questionStartTime) || (meta.phase === 'finalQuestion' && meta.finalQuestionStartTime)){
        const isFinal = meta.phase === 'finalQuestion';
        const start = isFinal ? meta.finalQuestionStartTime : meta.questionStartTime;
        const duration = isFinal ? FINAL_TIME : QUESTION_TIME;
        const tick = async ()=>{
          const elapsed = Math.floor((Date.now() - start)/1000);
          const rem = Math.max(0, duration - elapsed);
          setTimeLeft(rem);
          if(rem === 0) { isFinal ? await nextFinalQuestion() : await showResultsNow(); }
        };
        tick();
        clearInterval(timerRef.current);
        timerRef.current = setInterval(tick, 500);
        return ()=> clearInterval(timerRef.current);
      } else { setTimeLeft(0); }
    },[meta?.phase, meta?.questionStartTime, meta?.finalQuestionStartTime]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setRevealAnswer(false);
            const t = setTimeout(() => setRevealAnswer(true), 3000); 
            return () => clearTimeout(t);
        } else {
            setRevealAnswer(false);
        }
    }, [meta?.phase]);

    const handlePause = async () => {
      // Pause the game by saving current phase
      await db.ref(`games/${gameId}/meta/pausedPhase`).set(meta.phase);
      await db.ref(`games/${gameId}/meta/pausedAt`).set(Date.now());
      if(meta.phase === 'question' && meta.questionStartTime) {
        const elapsed = Math.floor((Date.now() - meta.questionStartTime) / 1000);
        await db.ref(`games/${gameId}/meta/pausedTimeRemaining`).set(QUESTION_TIME - elapsed);
      }
      await db.ref(`games/${gameId}/meta`).update({ phase: 'paused' });
      setPauseModalOpen(true);
    };

    const resumeGame = async () => {
      // Resume the game
      const pausedPhase = meta.pausedPhase || 'lobby';
      const timeRemaining = meta.pausedTimeRemaining || QUESTION_TIME;

      if(pausedPhase === 'question') {
        // Recalculate start time based on remaining time
        const newStartTime = Date.now() - ((QUESTION_TIME - timeRemaining) * 1000);
        await db.ref(`games/${gameId}/meta`).update({
          phase: 'question',
          questionStartTime: newStartTime,
          pausedPhase: null,
          pausedAt: null,
          pausedTimeRemaining: null
        });
      } else {
        await db.ref(`games/${gameId}/meta`).update({
          phase: pausedPhase,
          pausedPhase: null,
          pausedAt: null,
          pausedTimeRemaining: null
        });
      }
      setPauseModalOpen(false);
    };

    const backToLobby = async ()=>{
      await db.ref(`games/${gameId}/meta`).set({ phase: 'lobby', finaleEnabled: meta?.finaleEnabled ?? true });
      await db.ref(`games/${gameId}/questions`).remove();
      await db.ref(`games/${gameId}/finalQuestions`).remove();
      setPauseModalOpen(false);
    };

    const showResultsNow = async ()=>{
      try{
        const snap = await db.ref(`games/${gameId}`).get();
        const g = snap.val();
        if(!g || !g.meta || g.meta.phase === 'results') return;
        const qIndex = g.meta?.questionIndex || 0;
        const q = (g.questions || [])[qIndex];
        if(!q) return;

        const playerObj = g.players || {};
        const updates = {};
        const currentRound = g.meta.round || 1;
        const basePoints = ROUND_POINTS[currentRound] || 100;
        
        // Calculate who answered what
        const answerCounts = {};
        Object.entries(playerObj).forEach(([pid, p]) => {
          const ans = p.currentAnswer;
          if (typeof ans === 'number') {
            answerCounts[ans] = (answerCounts[ans] || 0) + 1;
          }
        });

        Object.entries(playerObj).forEach(([pid,p])=>{
          const ans = p.currentAnswer;
          const correct = typeof ans === 'number' && ans === q.correct;
          
          let points = correct ? basePoints : 0;
          let currentTotal = p.score || 0;
          let penalty = 0;
          
          // Apply active effects
          const effects = p.activeEffects || {};
          
          // Turbo Boost
          if(correct && effects.turbo) points = Math.round(points * 1.3);
          
          // Magnet - bonus if others also answered correctly (15% per other correct player)
          if(correct && effects.magnet) {
            const othersCorrect = Object.entries(playerObj).filter(([id, pl]) => 
              id !== pid && pl.currentAnswer === q.correct
            ).length;
            if(othersCorrect > 0) {
              points = Math.round(points * (1 + othersCorrect * 0.15));
            }
          }
          
          // Giftpfeil (Poison) - 25% reduction
          if(correct && effects.poisoned) {
            points = Math.round(points * 0.75);
          }

          // Reflected Attack - 10% reduction (weaker than direct poison)
          if(correct && effects.reflectedAttack) {
            points = Math.round(points * 0.90);
          }

          const finalPoints = points - penalty;
          
          updates[`games/${gameId}/players/${pid}/score`] = currentTotal + finalPoints;
          updates[`games/${gameId}/players/${pid}/lastPoints`] = finalPoints;

          // Give item box only after every second question, but stop after question 8
          const itemSlots = p.itemSlots || [];
          const isRoundEnd = (qIndex + 1) % 2 === 0;
          const questionNumber = (qIndex % QUESTIONS_PER_ROUND) + 1;

          if(itemSlots.length < ITEM_SLOTS && isRoundEnd && questionNumber <= 8) {
            const allScores = Object.values(playerObj).map(pl => pl.score || 0);
            const position = getPlayerPosition(p.score || 0, allScores);
            const newItem = getRandomItem(position);
            updates[`games/${gameId}/players/${pid}/itemSlots`] = [...itemSlots, newItem];
            updates[`games/${gameId}/players/${pid}/hasNewItem`] = true;
          }
        });
        
        await db.ref().update(updates);
        
        // Handle Platztauscher (point swaps) AFTER scores are updated
        const swapUpdates = {};
        Object.entries(playerObj).forEach(([pid, p]) => {
          if(p.activeEffects?.swapPointsWith) {
            const targetPid = p.activeEffects.swapPointsWith;
            const targetPlayer = playerObj[targetPid];
            
            if(targetPlayer) {
              // Get new scores after current updates
              const myNewScore = (p.score || 0) + (updates[`games/${gameId}/players/${pid}/lastPoints`] || 0);
              const targetNewScore = (targetPlayer.score || 0) + (updates[`games/${gameId}/players/${targetPid}/lastPoints`] || 0);
              
              // Swap scores
              swapUpdates[`games/${gameId}/players/${pid}/score`] = targetNewScore;
              swapUpdates[`games/${gameId}/players/${targetPid}/score`] = myNewScore;
              
              // Mark that swap happened
              swapUpdates[`games/${gameId}/players/${pid}/activeEffects/swappedWith`] = targetPid;
              swapUpdates[`games/${gameId}/players/${targetPid}/activeEffects/swappedWith`] = pid;
            }
          }
        });
        
        if(Object.keys(swapUpdates).length > 0) {
          await db.ref().update(swapUpdates);
        }
        
        await db.ref(`games/${gameId}/meta`).update({ phase: 'results' });
      }catch(e){ console.error(e); }
    };

    const startNextRound = async ()=>{
      if(!meta) return;
      const gameSnap = await db.ref(`games/${gameId}`).get();
      const g = gameSnap.val();
      if (!g) { alert("Datenfehler: Spiel nicht gefunden"); return; }
      
      const currentIndex = g.meta.questionIndex || 0;
      const currentQuestions = g.questions || [];
      const nextIndex = currentIndex + 1;
      
      if(meta.phase === 'results'){
        const isRoundEnd = (nextIndex % QUESTIONS_PER_ROUND) === 0;
        if (isRoundEnd) {
             const finishedRound = Math.floor(currentIndex / QUESTIONS_PER_ROUND) + 1;
             if (finishedRound >= TOTAL_ROUNDS) {
                if(meta.finaleEnabled === false) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
                else await prepareFinale();
                return;
             }
             const pObj = g.players || {};
             const sorted = Object.entries(pObj).sort(([,a],[,b]) => (a.score||0) - (b.score||0));
             const minScore = sorted[0]?.[1].score || 0;
             const losers = sorted.filter(([,p]) => (p.score||0) === minScore).map(([id]) => id);
             const pickedLoser = losers.length > 0 ? losers[Math.floor(Math.random() * losers.length)] : null;

             await db.ref(`games/${gameId}/meta`).update({
               phase: 'roundSummary',
               round: finishedRound + 1,
               categoryChooserCandidate: pickedLoser || null
             });
             return;

        } else {
            await proceedToQuestion(nextIndex, g.meta.currentCategory, g.meta.categoryChooserForRound || null);
        }
      }
      else if(meta.phase === 'roundSummary'){
         const chosenCat = meta.nextCategory || null;
         const chooser = meta.categoryChooserForRound || null;
         
         let finalCat = chosenCat;
         if(!finalCat) {
            const used = meta.categoryState?.used || [];
            const avail = CATEGORY_LIST.filter(c => !used.includes(c));
            finalCat = avail.length > 0 ? avail[0] : CATEGORY_LIST[0];
         }

         const newBlock = getQuestionsForCategory(finalCat, QUESTIONS_PER_ROUND, currentQuestions.map(q=>q.question));
         const newQuestions = [...currentQuestions, ...newBlock];
         
         await db.ref(`games/${gameId}/questions`).set(newQuestions);
         const used = [...(meta.categoryState?.used || []), finalCat];
         await db.ref(`games/${gameId}/meta/categoryState/used`).set(used);
         
         await db.ref(`games/${gameId}/meta/nextCategory`).remove();
         await db.ref(`games/${gameId}/meta/categoryChooserCandidate`).remove();

         const safeStartIndex = currentQuestions.length;
         await proceedToQuestion(safeStartIndex, finalCat, chooser, true); // Show round start after round summary
      }
    };

    const proceedToQuestion = async (index, category, chooser, showRoundStart = false) => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid => {
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/activeEffects`] = {};
        updates[`games/${gameId}/players/${pid}/hasNewItem`] = false;
        updates[`games/${gameId}/players/${pid}/usedItemThisQuestion`] = false;
        updates[`games/${gameId}/players/${pid}/readyForNext`] = false;
      });
      await db.ref().update(updates);

      const currentRound = Math.floor(index / QUESTIONS_PER_ROUND) + 1;

      // FIX: Only show round start at beginning of complete new round (after roundSummary)
      if(showRoundStart) {
        // Show round start screen first
        await db.ref(`games/${gameId}/meta`).update({
            questionIndex: index,
            phase: 'roundStart',
            currentCategory: category,
            categoryChooserForRound: chooser || null,
            round: currentRound
        });
      } else {
        // Go directly to question
        await db.ref(`games/${gameId}/meta`).update({
            questionIndex: index,
            phase: 'question',
            questionStartTime: Date.now(),
            currentCategory: category,
            categoryChooserForRound: chooser || null,
            round: currentRound
        });
      }
    };

    const startQuestionFromRoundStart = async () => {
      await db.ref(`games/${gameId}/meta`).update({
          phase: 'question',
          questionStartTime: Date.now()
      });
    };

    const prepareFinale = async () => {
      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const pObj = pSnap.val() || {};
      const playersArr = Object.entries(pObj).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
      if(playersArr.length < 2){ await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' }); return; }
      const top2 = playersArr.slice(0, 2).map(p => p.pid);
      await db.ref(`games/${gameId}/finalQuestions`).set(shuffle(FINAL_QUESTION_POOL).slice(0, FINAL_QUESTIONS));
      const updates = {};
      Object.keys(pObj).forEach(pid => {
        const isFinalist = top2.includes(pid);
        const baseScore = isFinalist ? Math.floor((pObj[pid].score || 0) * 0.5) : 0; // 50% Base Score
        updates[`games/${gameId}/players/${pid}/isFinalist`] = isFinalist;
        updates[`games/${gameId}/players/${pid}/finalAnswers`] = {};
        updates[`games/${gameId}/players/${pid}/finalistReady`] = false;
        updates[`games/${gameId}/players/${pid}/finalBaseScore`] = baseScore;
        updates[`games/${gameId}/players/${pid}/finalCurrentScore`] = baseScore; // Start with base score
        updates[`games/${gameId}/players/${pid}/finalWagers`] = {};
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta`).update({ phase: 'finalIntro', finalists: top2 });
    };

    const startFinalQuestion = async () => db.ref(`games/${gameId}/meta`).update({ phase: 'finalQuestion', finalQuestionIndex: 0, finalQuestionStartTime: Date.now() });
    const nextFinalQuestion = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const currentIndex = (snap.val()?.meta?.finalQuestionIndex || 0) + 1;
      if(currentIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finalReview', finalReviewIndex: 0 });
      else await db.ref(`games/${gameId}/meta`).update({ finalQuestionIndex: currentIndex, finalQuestionStartTime: Date.now() });
    };
    const judgeFinalAnswer = async (playerId, correct) => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = snap.val()?.meta?.finalReviewIndex || 0;
      const player = snap.val()?.players?.[playerId];
      if(!player) return;

      const wager = player.finalWagers?.[reviewIndex] || 0;
      const currentScore = player.finalCurrentScore || 0;
      const pointChange = correct ? wager : -wager;
      const newScore = Math.max(0, currentScore + pointChange); // Can't go below 0

      await db.ref(`games/${gameId}/players/${playerId}`).update({
        finalCurrentScore: newScore,
        [`finalScores/${reviewIndex}`]: pointChange
      });
    };
    const nextFinalReview = async () => {
      const snap = await db.ref(`games/${gameId}`).get();
      const reviewIndex = (snap.val()?.meta?.finalReviewIndex || 0) + 1;
      if(reviewIndex >= FINAL_QUESTIONS) await db.ref(`games/${gameId}/meta`).update({ phase: 'finished' });
      else await db.ref(`games/${gameId}/meta`).update({ finalReviewIndex: reviewIndex });
    };

    const startGame = async ()=>{
      const categoriesForGame = shuffle(CATEGORY_LIST).slice(0, TOTAL_ROUNDS);
      const firstCat = categoriesForGame[0];
      const block = getQuestionsForCategory(firstCat, QUESTIONS_PER_ROUND, []);

      await db.ref(`games/${gameId}/questions`).set(block);
      await db.ref(`games/${gameId}/meta/categoryState`).set({ used: [firstCat], remaining: categoriesForGame.slice(1) });

      // FIX: Show round start screen for round 1 as well
      await db.ref(`games/${gameId}/meta`).set({
        phase: 'roundStart',
        questionIndex: 0,
        round: 1,
        currentCategory: firstCat,
        categoryChooserForRound: null,
        finaleEnabled: finaleEnabled
      });

      const pSnap = await db.ref(`games/${gameId}/players`).get();
      const updates = {};
      Object.keys(pSnap.val() || {}).forEach(pid=>{
        updates[`games/${gameId}/players/${pid}/score`] = 0;
        updates[`games/${gameId}/players/${pid}/currentAnswer`] = null;
        updates[`games/${gameId}/players/${pid}/itemSlots`] = [];
        updates[`games/${gameId}/players/${pid}/activeEffects`] = {};
        updates[`games/${gameId}/players/${pid}/lastPoints`] = 0;
      });
      await db.ref().update(updates);
      await db.ref(`games/${gameId}/meta/actions`).remove();
    };

    const toggleFinale = async () => {
      const newValue = !finaleEnabled;
      setFinaleEnabled(newValue);
      await db.ref(`games/${gameId}/meta/finaleEnabled`).set(newValue);
    };

    if(!meta || !game) return <div className="min-h-screen flex items-center justify-center">Lade Spiel...</div>;

    const isLobby = meta.phase === 'lobby';
    const playersArr = Object.entries(game.players || {}).map(([pid,p])=>({pid,...p})).sort((a,b)=>(b.score||0)-(a.score||0));
    const qIndex = meta.questionIndex || 0;
    const question = (game.questions || [])[qIndex];
    const countdownClass = timeLeft <= 10 ? 'danger' : timeLeft <= 20 ? 'warning' : '';

    const isFinalPhase = meta.phase.startsWith('final');
    const displayCategory = isFinalPhase ? "FINALE" : (meta.currentCategory || question?.category || 'Allgemein');
    const displayCategoryColor = isFinalPhase ? 'var(--rtl-orange)' : 'var(--rtl-orange)';

    const resultsRanking = [...playersArr].sort((a,b) => (b.lastPoints||0) - (a.lastPoints||0));

    return (
      <div className="host-screen">
        {isLobby ? (
          <div style={{display:'flex', width:'100%', height:'100vh', background:'#000', position:'relative', overflow:'hidden'}}>

             {/* Left side - QR Code & Game Info */}
             <div style={{flex:'0 0 45%', display:'flex', flexDirection:'column', padding:'60px', background:'#0a0a0a', borderRight:'2px solid rgba(255,255,255,0.1)'}}>
                <div style={{marginBottom:60}}>
                    <RTLLogo size="lg" />
                    <div style={{fontSize:'2.5rem', fontWeight:900, color:'var(--rtl-orange)', marginTop:20, letterSpacing:2}}>AdAlliance Quiz</div>
                </div>

                <div style={{display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center', flex:1, gap:40}}>
                    <div style={{padding:30, background:'white', border:'3px solid var(--rtl-orange)'}}>
                        <img src={qrUrlForGame(gameId)} alt="QR" style={{width:'35vh', height:'35vh', display:'block'}} />
                    </div>

                    <div style={{textAlign:'center'}}>
                        <div style={{fontSize:'1.5rem', color:'var(--muted)', letterSpacing:2, marginBottom:15, textTransform:'uppercase'}}>Spiel-Code</div>
                        <div style={{fontSize:'7rem', fontWeight:900, lineHeight:1, color:'white', letterSpacing:15}}>{gameId}</div>
                    </div>
                </div>

                <div style={{textAlign:'center', padding:'20px', background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)', marginTop:30}}>
                    <div style={{fontSize:'1.2rem', color:'var(--muted)'}}>📱 Scanne den QR-Code oder gehe zu</div>
                    <div style={{fontSize:'2rem', fontWeight:700, color:'var(--rtl-orange)', marginTop:5}}>rtl-quiz.web.app</div>
                </div>
             </div>

             {/* Right side - Players & Controls */}
             <div style={{flex:1, display:'flex', flexDirection:'column'}}>
                {/* Header Bar */}
                <div style={{padding:'30px 50px', background:'#111', borderBottom:'2px solid rgba(255,255,255,0.1)'}}>
                    <div style={{display:'flex', alignItems:'center', justifyContent:'space-between'}}>
                        <div>
                            <div style={{fontSize:'1rem', color:'var(--muted)', letterSpacing:2, marginBottom:5}}>MULTIPLAYER LOBBY</div>
                            <div style={{fontSize:'2.5rem', fontWeight:900, color:'white', letterSpacing:1}}>
                                <span style={{color:'var(--rtl-orange)'}}>{playersArr.length}</span> Spieler bereit
                            </div>
                        </div>

                        <div style={{display:'flex', alignItems:'center', gap:25}}>
                            <div style={{padding:'15px 25px', background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                                <div style={{fontSize:'0.9rem', color:'var(--muted)', marginBottom:5}}>Finale Aktivieren</div>
                                <label className="toggle-switch" style={{transform:'scale(1.1)'}}>
                                  <input type="checkbox" checked={finaleEnabled} onChange={toggleFinale} />
                                  <span className="toggle-slider"></span>
                                </label>
                            </div>
                            <button className="btn btn-host" onClick={startGame} style={{fontSize:24, padding:'20px 50px', fontWeight:900, textTransform:'uppercase', letterSpacing:2}}>
                                ▶ START
                            </button>
                        </div>
                    </div>
                </div>

                {/* Players Grid */}
                <div className="scroll-area" style={{flex:1, padding:'40px 50px'}}>
                    {playersArr.length === 0 ? (
                        <div style={{display:'flex', alignItems:'center', justifyContent:'center', height:'100%', flexDirection:'column', gap:20}}>
                            <div style={{fontSize:'4rem', opacity:0.3}}>👥</div>
                            <div style={{fontSize:'2rem', color:'var(--muted)', fontWeight:700}}>Warte auf Spieler...</div>
                            <div style={{fontSize:'1.2rem', color:'var(--muted)'}}>Spieler können über QR-Code oder Game-Code beitreten</div>
                        </div>
                    ) : (
                        <div style={{display:'grid', gridTemplateColumns:'repeat(auto-fill, minmax(280px, 1fr))', gap:20}}>
                           {playersArr.map((p, idx) => (
                               <div key={p.pid} style={{
                                   background:'rgba(255,255,255,0.05)',
                                   border:'2px solid rgba(255,255,255,0.2)',
                                   padding:'20px 25px',
                                   display:'flex',
                                   alignItems:'center',
                                   gap:15,
                                   fontSize:22,
                                   fontWeight:700
                               }}>
                                   <div style={{
                                       width:12,
                                       height:12,
                                       background:'var(--rtl-orange)',
                                       flexShrink:0
                                   }} />
                                   <span style={{flex:1, color:'white'}}>{p.name}</span>
                                   <span style={{fontSize:12, padding:'4px 10px', background:'rgba(255,255,255,0.1)', border:'1px solid rgba(255,255,255,0.2)', color:'var(--muted)', fontWeight:900}}>
                                       #{idx+1}
                                   </span>
                               </div>
                           ))}
                        </div>
                    )}
                </div>
             </div>
          </div>
        ) : (
          <div className="host-main">
            {meta.phase !== 'finalIntro' && meta.phase !== 'finished' && meta.phase !== 'roundStart' && (
                <div className="game-top-bar">
                     {meta.phase === 'roundSummary' ? (
                        <div style={{display:'flex', alignItems:'center', justifyContent:'center', width:'100%', gap:20}}>
                            <div style={{fontSize:'3rem', fontWeight:900, color:'white', letterSpacing:2}}>ZWISCHENSTAND</div>
                        </div>
                     ) : (
                        <>
                          <div style={{display:'flex', alignItems:'center', gap:20}}>
                            <div className={`countdown-badge ${countdownClass}`}>{timeLeft}</div>
                            <div>
                              <div style={{color:'var(--muted)', fontSize:'1rem', textTransform:'uppercase'}}>
                                  {isFinalPhase ? 'Das Finale' : `Runde ${meta.round || 1} | Frage ${(qIndex%QUESTIONS_PER_ROUND)+1}`}
                              </div>
                              <div style={{fontWeight:900, fontSize:'1.8rem', color: displayCategoryColor}}>{displayCategory}</div>
                            </div>
                          </div>

                          <div style={{position:'absolute', left:'50%', transform:'translateX(-50%)'}}>
                            <RTLLogo size="sm" />
                          </div>
                        </>
                     )}

                     <div style={{display:'flex', alignItems:'center', gap:20}}>
                        {meta.phase === 'question' && <button className="btn btn-show-results" onClick={showResultsNow}>Lösung anzeigen ▶</button>}
                        {meta.phase === 'results' && <button className="btn btn-host" onClick={startNextRound}>Weiter ▶</button>}
                        {meta.phase === 'roundSummary' && <button className="btn btn-host" onClick={startNextRound}>Nächste Runde ▶</button>}
                        <button className="btn-pause-gold" onClick={handlePause} title="Spiel pausieren">II</button>
                     </div>
                </div>
            )}

            <div className="host-main-inner">
                {/* NEW: Round Start Screen for Host - 16:9 TV optimized */}
                {meta.phase === 'roundStart' && (
                  <div style={{display:'flex', alignItems:'center', justifyContent:'center', height:'100%', padding:'60px'}}>

                    {/* Left Side: Logo + Round Number */}
                    <div style={{flex:'0 0 35%', display:'flex', flexDirection:'column', alignItems:'center', gap:40}}>
                      <RTLLogo size="lg" />
                      <div style={{fontSize:'8rem', fontWeight:900, color:'white', textTransform:'uppercase', letterSpacing:12, lineHeight:1}}>
                        RUNDE<br/>{meta.round}
                      </div>
                    </div>

                    {/* Right Side: Category + Info */}
                    <div style={{flex:'0 0 50%', display:'flex', flexDirection:'column', gap:50, marginLeft:60}}>

                      {/* Category Box */}
                      <div style={{padding:'50px 60px', border:'4px solid var(--rtl-orange)', textAlign:'center'}}>
                        <div style={{fontSize:'1.3rem', color:'var(--muted)', textTransform:'uppercase', letterSpacing:3, fontWeight:700, marginBottom:20}}>
                          Kategorie
                        </div>
                        <div style={{fontSize:'4rem', fontWeight:900, color:'var(--rtl-orange)', letterSpacing:3}}>
                          {meta.currentCategory || 'Allgemein'}
                        </div>
                      </div>

                      {/* Points and Questions - Horizontal */}
                      <div style={{display:'flex', gap:30}}>
                        <div style={{flex:1, textAlign:'center', padding:'35px 30px', background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.2)'}}>
                          <div style={{fontSize:'1rem', color:'var(--muted)', textTransform:'uppercase', letterSpacing:2, marginBottom:15}}>
                            Punkte pro Antwort
                          </div>
                          <div style={{fontSize:'4.5rem', fontWeight:900, color:'white', lineHeight:1}}>
                            {ROUND_POINTS[meta.round || 1]}
                          </div>
                        </div>
                        <div style={{flex:1, textAlign:'center', padding:'35px 30px', background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.2)'}}>
                          <div style={{fontSize:'1rem', color:'var(--muted)', textTransform:'uppercase', letterSpacing:2, marginBottom:15}}>
                            Fragen
                          </div>
                          <div style={{fontSize:'4.5rem', fontWeight:900, color:'white', lineHeight:1}}>
                            {QUESTIONS_PER_ROUND}
                          </div>
                        </div>
                      </div>

                      {/* Start Button */}
                      <button className="btn btn-host" onClick={startQuestionFromRoundStart} style={{fontSize:28, padding:'22px 60px', width:'100%'}}>
                        FRAGE STARTEN ▶
                      </button>
                    </div>

                  </div>
                )}

                {meta.phase === 'question' && question && (
                  <>
                    <div className="question-area">
                        <h2 className="question-text">{question.question}</h2>
                    </div>
                    <div className="answers-grid">
                      {question.answers.map((a,i)=>(
                        <div key={i} className="answer-btn">
                          <div style={{fontWeight:900, color:'var(--rtl-orange)', fontSize:'3rem'}}>{String.fromCharCode(65+i)}</div>
                          <div style={{fontSize:'2.2rem'}}>{a}</div>
                        </div>
                      ))}
                    </div>
                    <div style={{marginTop: 'auto', paddingTop: 30, borderTop:'1px solid rgba(255,255,255,0.1)', width:'100%'}}>
                        <div style={{fontSize:16, color:'var(--muted)', marginBottom:15, textAlign:'center', textTransform:'uppercase', letterSpacing:1, fontWeight:700}}>
                            Spieler Status ({playersArr.filter(p => p.currentAnswer !== undefined && p.currentAnswer !== null).length} / {playersArr.length})
                        </div>
                        <div style={{display:'flex', flexWrap:'wrap', gap:10, justifyContent:'center'}}>
                            {playersArr.map(p => {
                                const hasAnswered = p.currentAnswer !== null && p.currentAnswer !== undefined;
                                return (
                                    <div key={p.pid} style={{
                                        padding: '8px 16px',
                                        background: hasAnswered ? 'var(--rtl-orange)' : 'rgba(255,255,255,0.1)',
                                        color: hasAnswered ? '#000' : 'rgba(255,255,255,0.5)',
                                        fontWeight: 900,
                                        fontSize: 14,
                                        border: hasAnswered ? '1px solid var(--rtl-orange)' : '1px solid rgba(255,255,255,0.1)',
                                        display:'flex', alignItems:'center', gap:6
                                    }}>
                                        {p.name}
                                        {hasAnswered && <span>●</span>}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                  </>
                )}

                {meta.phase === 'results' && question && (
                   <div className="results-split-view">
                      <div className="results-col">
                         <div style={{display:'grid', gap:12, flex:1, overflow:'auto', alignContent:'center', height:'100%'}}>
                            {question.answers.map((a,i)=>{
                              const isCorrect = i === question.correct;
                              const voters = playersArr.filter(p => p.currentAnswer === i);
                              const showHighlight = isCorrect && revealAnswer;

                              return (
                                <div key={i} className={showHighlight ? 'reveal-correct' : ''} style={{
                                    padding:30, 
                                    border: showHighlight ? '5px solid white' : '1px solid rgba(255,255,255,0.1)', 
                                    background: showHighlight ? 'rgba(255,255,255,1)' : 'rgba(255,255,255,0.02)',
                                    color: showHighlight ? '#000' : '#fff',
                                    transition: 'all 0.5s ease'
                                }}>
                                  <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                    <div style={{fontWeight:900, fontSize:28}}>{String.fromCharCode(65+i)}. {a}</div>
                                  </div>
                                  <div style={{marginTop:12, fontSize:20, color: showHighlight ? '#000' : 'var(--muted)'}}>
                                    {voters.length} Stimmen {voters.length>0 && `(${voters.map(p=>p.name).join(', ')})`}
                                  </div>
                                </div>
                              )
                            })}
                         </div>
                      </div>
                      <div className="results-col">
                         {revealAnswer && (
                            <>
                                <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                                   <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Aktionen</h3>
                                   <div className="scroll-area" style={{flex:1}}>
                                     {(() => {
                                        const actions = (game.meta?.actions?.[qIndex] || []);
                                        if(actions.length === 0) return <div style={{color:'var(--muted)', fontStyle:'italic'}}>Keine Aktionen.</div>;
                                        return actions.map((act, idx) => {
                                           const from = game.players[act.from]?.name || '???';
                                           const to = game.players[act.to]?.name || '???';
                                           const itemInfo = ITEM_TYPES[act.itemId];
                                           return <div key={idx} className={`action-log-item ${act.type}`}><img src={itemInfo?.icon} alt="" /> <b>{from}</b> → {to}: {itemInfo?.name}</div>;
                                        });
                                     })()}
                                   </div>
                                </div>
                                <div style={{flex:1, display:'flex', flexDirection:'column', background:'rgba(255,255,255,0.02)', padding:20, border:'1px solid rgba(255,255,255,0.05)'}}>
                                    <h3 style={{color:'var(--rtl-orange)', fontWeight:900, marginBottom:15, fontSize:22}}>Score & Status</h3>
                                    <div className="scroll-area" style={{flex:1}}>
                                      {resultsRanking.map((p,i)=>{
                                        const isReady = p.readyForNext === true;
                                        return (
                                          <div key={p.pid} style={{display:'flex', justifyContent:'space-between', alignItems:'center', padding:'12px', background:i<3?'rgba(255,255,255,0.05)':'transparent', marginBottom:4}}>
                                            <div style={{display:'flex', gap:10, alignItems:'center'}}>
                                              <span style={{fontWeight:700, fontSize:18}}>{p.name}</span>
                                              {isReady && (
                                                <div style={{background:'var(--rtl-orange)', color:'#000', padding:'4px 10px', fontSize:12, fontWeight:900, letterSpacing:0.5}}>
                                                  BEREIT
                                                </div>
                                              )}
                                            </div>
                                            <div style={{fontWeight:900, color: p.lastPoints>0 ? 'var(--rtl-orange)' : (p.lastPoints<0 ? 'var(--rtl-orange)' : 'var(--muted)'), fontSize:18}}>
                                              {p.lastPoints > 0 ? '+' : ''}{p.lastPoints}
                                            </div>
                                          </div>
                                        );
                                      })}
                                    </div>
                                </div>
                            </>
                         )}
                      </div>
                   </div>
                )}

                {meta.phase === 'roundSummary' && (
                   <div style={{width:'100%', height:'100%', display:'flex', flexDirection:'column'}}>
                      <div style={{display:'flex', flexDirection:'column', alignItems:'center', gap:15, marginBottom:20}}>
                        <RTLLogo size="sm" />
                        <h2 style={{textAlign:'center', fontSize:48, fontWeight:900, color:'var(--rtl-orange)', margin:0}}>Stand nach Runde {meta.round - 1}</h2>
                      </div>
                      <div style={{textAlign:'center', color:'var(--muted)', marginBottom:30, fontSize:20, display:'flex', flexDirection:'column', gap:10, alignItems:'center'}}>
                         <div>Der Spieler auf dem letzten Platz wählt die nächste Kategorie.</div>
                         {meta.categoryChooserCandidate && (
                            <div style={{background:'rgba(255,255,255,0.1)', padding:'10px 20px', border:'1px solid rgba(255,255,255,0.2)', display:'flex', gap:15, alignItems:'center'}}>
                                <span style={{fontWeight:700}}>WÄHLER: {game.players[meta.categoryChooserCandidate]?.name}</span>
                                {game.meta?.nextCategory ? (
                                    <span style={{color:'var(--rtl-orange)', fontWeight:900}}>HAT GEWÄHLT: {game.meta.nextCategory}</span>
                                ) : (
                                    <span style={{color:'var(--rtl-orange)', fontWeight:900}}>WÄHLT...</span>
                                )}
                            </div>
                         )}
                      </div>
                      <div className="scroll-area" style={{flex:1, background:'rgba(255,255,255,0.02)', padding:40, border:'1px solid rgba(255,255,255,0.05)'}}>
                         {playersArr.map((p,i)=>(
                            <div key={p.pid} style={{
                               display:'flex', alignItems:'center', justifyContent:'space-between',
                               padding:25, marginBottom:10,
                               background: i===0 ? 'linear-gradient(90deg, rgba(255,215,0,0.2), rgba(0,0,0,0))' : 
                                           i===1 ? 'linear-gradient(90deg, rgba(192,192,192,0.2), rgba(0,0,0,0))' : 
                                           i===2 ? 'linear-gradient(90deg, rgba(205,127,50,0.2), rgba(0,0,0,0))' : 'rgba(255,255,255,0.02)',
                               borderLeft: i===0 ? '6px solid gold' : i===1 ? '6px solid silver' : i===2 ? '6px solid #cd7f32' : '6px solid transparent'
                            }}>
                               <div style={{display:'flex', alignItems:'center', gap:30}}>
                                  <div style={{fontSize:36, fontWeight:900, width:60}}>{i+1}.</div>
                                  <div style={{fontSize:28, fontWeight:700}}>{p.name}</div>
                                  {meta.categoryChooserCandidate === p.pid && <div style={{background:'var(--rtl-orange)', color: '#000', padding:'6px 12px', fontWeight:900, fontSize:16}}>DARF WÄHLEN!</div>}
                               </div>
                               <div style={{display:'flex', alignItems:'center', gap:40}}>
                                  <div style={{fontSize:20, color:'var(--muted)', display:'flex', gap:10}}>
                                    {(p.itemSlots || []).map((item, idx) => (
                                      <img key={idx} src={item.icon} alt={item.name} style={{width: 32, height: 32}} />
                                    ))}
                                  </div>
                                  <div style={{fontSize:36, fontWeight:900, color:'var(--tile)'}}>{p.score}</div>
                               </div>
                            </div>
                         ))}
                      </div>
                   </div>
                )}

                {['finalIntro', 'finalQuestion', 'finalReview', 'finished'].includes(meta.phase) && (
                    <div style={{flex:1, display:'flex', justifyContent:'center', alignItems:'center', flexDirection:'column'}}>
                        {meta.phase === 'finalIntro' && <FinalIntroHostView game={game} meta={meta} onStart={startFinalQuestion} />}
                        {meta.phase === 'finalQuestion' && <FinalQuestionHostView game={game} meta={meta} timeLeft={timeLeft} onNext={nextFinalQuestion} />}
                        {meta.phase === 'finalReview' && <FinalReviewHostView game={game} meta={meta} onJudge={judgeFinalAnswer} onNext={nextFinalReview} />}
                        {meta.phase === 'finished' && (
                           <div style={{width:'100%', height:'100%', position:'relative', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'space-between', padding:'60px 40px'}}>
                              <div style={{zIndex:10, textAlign:'center'}}>
                                  <RTLLogo size="xl" style={{marginBottom:50}} />
                                  <h1 style={{fontSize:'6rem', fontWeight:900, margin:0, color:'var(--rtl-orange)', textTransform:'uppercase', letterSpacing:8, textShadow:'0 0 40px rgba(255,119,0,0.5)'}}>SIEGEREHRUNG</h1>
                              </div>
                              <div className="podium-container" style={{zIndex:10}}>
                                  {playersArr[1] && (
                                      <div className="podium-place podium-2" style={{animationDelay:'0.2s'}}>
                                          <div className="winner-name">{playersArr[1].name}</div>
                                          <div className="winner-score">{playersArr[1].score} Punkte</div>
                                          <div className="podium-bar">2</div>
                                      </div>
                                  )}
                                  {playersArr[0] && (
                                      <div className="podium-place podium-1" style={{animationDelay:'0s'}}>
                                          <div style={{fontSize:'5rem', marginBottom:20}}>👑</div>
                                          <div className="winner-name">{playersArr[0].name}</div>
                                          <div className="winner-score">{playersArr[0].score} Punkte</div>
                                          <div className="podium-bar">1</div>
                                      </div>
                                  )}
                                  {playersArr[2] && (
                                      <div className="podium-place podium-3" style={{animationDelay:'0.4s'}}>
                                          <div className="winner-name">{playersArr[2].name}</div>
                                          <div className="winner-score">{playersArr[2].score} Punkte</div>
                                          <div className="podium-bar">3</div>
                                      </div>
                                  )}
                              </div>
                              <button className="btn btn-host" style={{zIndex:10, fontSize:'1.8rem', padding:'25px 60px', background:'var(--rtl-orange)', color:'#000', fontWeight:900}} onClick={backToLobby}>ZURÜCK ZUR LOBBY</button>
                           </div>
                        )}
                    </div>
                )}
            </div>
          </div>
        )}

        {pauseModalOpen && (
          <div className="modal-backdrop">
            <div className="modal-card" style={{textAlign:'center'}}>
              <h3 style={{fontWeight:900, fontSize:32, marginBottom:10, color:'var(--rtl-orange)'}}>PAUSE</h3>
              
              <div style={{marginBottom: 30, padding: 20, background: 'rgba(255,255,255,0.1)', border: '1px solid rgba(255,255,255,0.2)'}}>
                  <div style={{fontSize: 16, color: 'var(--muted)', textTransform: 'uppercase', letterSpacing: 2, marginBottom: 5}}>Spiel-Code</div>
                  <div style={{fontSize: 60, fontWeight: 900, color: 'white', letterSpacing: 8, fontFamily: 'monospace'}}>{gameId}</div>
              </div>

              <div style={{display:'flex', flexDirection:'column', gap:20}}>
                <button className="btn btn-host" onClick={resumeGame} style={{fontSize:20, padding:'20px'}}>▶ WEITER</button>
                <button className="btn" onClick={backToLobby} style={{fontSize:20, padding:'20px', background:'rgba(255,255,255,0.1)'}}>↩ LOBBY / RESET</button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  /****************************************
   * FINAL COMPONENTS
   ****************************************/
  function FinalIntroHostView({ game, meta, onStart }){
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allReady = finalists.every(f => f.finalistReady === true);
    return (
      <div style={{textAlign:'center', width:'100%'}}>
        <RTLLogo size="lg" style={{marginBottom:40}} />
        <h2 style={{fontSize:60, fontWeight:900, color:'var(--rtl-orange)', marginBottom:50}}>FINALE</h2>
        <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:60, width:'100%', maxWidth:1200, margin:'0 auto'}}>
          {finalists.map((f, idx) => (
            <div key={f.pid} style={{padding:50, background:'rgba(255,255,255,0.05)', 
                 border: f.finalistReady ? '6px solid var(--rtl-orange)' : '6px solid var(--rtl-orange)'
            }}>
              <div style={{fontSize:100}}>{idx === 0 ? '1.' : '2.'}</div>
              <div style={{fontSize:50, fontWeight:900}}>{f.name}</div>
              <div style={{fontSize:40, color:'var(--muted)'}}>{f.score} Pkt</div>
              <div style={{marginTop:40, padding:20, 
                  background: f.finalistReady ? 'var(--rtl-orange)' : 'rgba(255,255,255,0.1)', 
                  color: f.finalistReady ? '#000' : '#fff',
                  fontWeight:700, fontSize:24}}>
                {f.finalistReady ? 'BEREIT' : 'WARTEN...'}
              </div>
            </div>
          ))}
        </div>
        {allReady && <button className="btn btn-host" onClick={onStart} style={{marginTop:60, fontSize:32, padding:'30px 60px'}}>START ▶</button>}
      </div>
    );
  }

  function FinalQuestionHostView({ game, meta, timeLeft, onNext }){
    const finalQIndex = meta.finalQuestionIndex || 0;
    const question = (game.finalQuestions || [])[finalQIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const allAnswered = finalists.every(f => f.finalAnswers?.[finalQIndex]);

    const buttonText = finalQIndex + 1 >= FINAL_QUESTIONS ? 'ZUR AUSWERTUNG' : 'NÄCHSTE FRAGE';

    return (
      <div style={{textAlign:'center', width:'100%', maxWidth:1400}}>
        <h2 style={{fontSize:'4.5rem', fontWeight:900, lineHeight:1.3, marginBottom:80}}>{question?.question}</h2>
        <div style={{display:'flex', gap:40}}>
          {finalists.map(f => (
             <div key={f.pid} style={{flex:1, padding:40, background:'rgba(255,255,255,0.05)',
                 border: f.finalAnswers?.[finalQIndex] ? '5px solid var(--rtl-orange)' : '2px solid rgba(255,255,255,0.1)'
             }}>
                <div style={{fontWeight:900, fontSize:36}}>{f.name}</div>
                <div style={{marginTop:20, fontSize:24,
                    color: f.finalAnswers?.[finalQIndex] ? 'var(--rtl-orange)' : 'var(--muted)'}}>
                   {f.finalAnswers?.[finalQIndex] ? 'ANTWORT DA' : 'Tippt...'}
                </div>
             </div>
          ))}
        </div>
        {(timeLeft === 0 || allAnswered) && <button className="btn btn-host" onClick={onNext} style={{marginTop:60, fontSize:28, padding:'20px 40px'}}>{buttonText}</button>}
      </div>
    );
  }

  function FinalReviewHostView({ game, meta, onJudge, onNext }){
    const reviewIndex = meta.finalReviewIndex || 0;
    const question = (game.finalQuestions || [])[reviewIndex];
    const finalists = (meta.finalists || []).map(pid => ({ pid, ...(game.players?.[pid] || {}) }));
    const [judged, setJudged] = useState({});
    const [showAnswers, setShowAnswers] = useState(false);
    const handleJudge = async (pid, ok) => { await onJudge(pid, ok); setJudged(prev => ({...prev, [pid]: ok})); };

    return (
      <div className="results-split-view" style={{width:'100%'}}>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           <h3 style={{color:'var(--muted)', textTransform:'uppercase', fontWeight:900, fontSize:24, marginBottom:30}}>Frage {reviewIndex+1}</h3>
           <div style={{fontSize:'3.5rem', fontWeight:900, marginBottom:50, lineHeight:1.2}}>{question?.question}</div>
           <div style={{padding:40, background:'#fff', color:'#000'}}>
              <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)'}}>LÖSUNG</div>
              <div style={{fontSize:36, fontWeight:900}}>{question?.answer}</div>
           </div>
        </div>
        <div className="results-col" style={{justifyContent:'center', padding:40}}>
           {!showAnswers ? (
              <>
                <h3 style={{fontSize:28, fontWeight:900, marginBottom:30, color:'var(--rtl-orange)', textAlign:'center'}}>GESETZTE PUNKTE</h3>
                {finalists.map(f => {
                  const wager = f.finalWagers?.[reviewIndex] || 0;
                  const currentScore = f.finalCurrentScore || 0;
                  return (
                    <div key={f.pid} style={{padding:30, background:'rgba(155, 89, 182, 0.1)', border:'2px solid #9b59b6', marginBottom:20}}>
                       <div style={{display:'flex', justifyContent:'space-between', marginBottom:15}}>
                          <span style={{fontWeight:900, fontSize:24}}>{f.name}</span>
                          <span style={{color:'var(--muted)', fontSize:16}}>Score: {currentScore}</span>
                       </div>
                       <div style={{textAlign:'center', padding:30, background:'rgba(0,0,0,0.5)'}}>
                          <div style={{fontSize:16, color:'var(--muted)', marginBottom:10}}>Einsatz</div>
                          <div style={{fontSize:64, fontWeight:900, color:'#9b59b6'}}>{wager}</div>
                          <div style={{fontSize:16, color:'var(--muted)', marginTop:10}}>Punkte</div>
                       </div>
                    </div>
                  );
                })}
                <button className="btn btn-host" onClick={()=>setShowAnswers(true)} style={{width:'100%', fontSize:24, padding:'20px 40px', marginTop:20}}>ANTWORTEN ANZEIGEN ▶</button>
              </>
           ) : (
              <>
                <h3 style={{fontSize:28, fontWeight:900, marginBottom:30, textAlign:'center'}}>ANTWORTEN BEWERTEN</h3>
                {finalists.map(f => {
                  const wager = f.finalWagers?.[reviewIndex] || 0;
                  return (
                    <div key={f.pid} style={{padding:30, background:'rgba(255,255,255,0.05)', marginBottom:20}}>
                       <div style={{display:'flex', justifyContent:'space-between', marginBottom:15}}>
                          <span style={{fontWeight:900, fontSize:24}}>{f.name}</span>
                          <span style={{color:'#9b59b6', fontSize:20, fontWeight:900}}>{wager} Pkt gesetzt</span>
                       </div>
                       <div style={{fontSize:28, padding:20, background:'rgba(0,0,0,0.5)', marginBottom:20, fontStyle:'italic'}}>"{f.finalAnswers?.[reviewIndex] || '---'}"</div>
                       {judged[f.pid] === undefined ? (
                          <div style={{display:'flex', gap:20}}>
                             <button className="btn" style={{flex:1, background:'white', color:'black', border:'2px solid white', fontSize:20}} onClick={()=>handleJudge(f.pid, true)}>✓ KORREKT</button>
                             <button className="btn" style={{flex:1, background:'transparent', border:'2px solid rgba(255,255,255,0.2)', color:'white'}} onClick={()=>handleJudge(f.pid, false)}>✗ FALSCH</button>
                          </div>
                       ) : (
                          <div style={{textAlign:'center', fontWeight:900, color:'var(--rtl-orange)', fontSize:20}}>
                            {judged[f.pid] ? `✓ RICHTIG (+${wager} Punkte)` : `✗ FALSCH (-${wager} Punkte)`}
                          </div>
                       )}
                    </div>
                  );
                })}
                {Object.keys(judged).length === finalists.length && <button className="btn btn-host" onClick={()=>{ setJudged({}); setShowAnswers(false); onNext(); }} style={{marginTop:30, fontSize:24, padding:'20px 40px'}}>WEITER ▶</button>}
              </>
           )}
        </div>
      </div>
    );
  }

  /****************************************
   * PLAYER VIEW
   ****************************************/
  function PlayerView({ gameId, playerId }){
    const [game,setGame] = useState(null);
    const [meta,setMeta] = useState(null);
    const [player,setPlayer] = useState(null);
    const [timeLeft,setTimeLeft] = useState(0);
    const [itemModalOpen, setItemModalOpen] = useState(false);
    const [selectedItem, setSelectedItem] = useState(null);
    const [targetModalOpen, setTargetModalOpen] = useState(false);
    const [bonusCategoryModalOpen, setBonusCategoryModalOpen] = useState(false);
    const [finalAnswer, setFinalAnswer] = useState('');
    const [playerReveal, setPlayerReveal] = useState(false);
    const [eliminated5050, setEliminated5050] = useState([]);
    const [scannedAnswers, setScannedAnswers] = useState({});
    const [isFrozen, setIsFrozen] = useState(false);
    const [freezeTimeLeft, setFreezeTimeLeft] = useState(0);

    // NEW: Item Box Roulette States
    const [showItemRoulette, setShowItemRoulette] = useState(false);
    const [rouletteItems, setRouletteItems] = useState([]);
    const [finalRouletteItem, setFinalRouletteItem] = useState(null);
    const [roulettePhase, setRoulettePhase] = useState('spinning'); // spinning, slowing, stopping, revealed
    const [pendingNewItem, setPendingNewItem] = useState(null);

    // NEW: Item Tooltip States
    const [showItemTooltip, setShowItemTooltip] = useState(false);
    const [tooltipItem, setTooltipItem] = useState(null);
    const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
    const longPressTimer = useRef(null);

    // NEW: Attack Notification
    const [attackNotification, setAttackNotification] = useState(null);

    // NEW: Items Info Modal
    const [showItemsInfo, setShowItemsInfo] = useState(false);

    // NEW: Time reduction tracking
    const [timeReductionApplied, setTimeReductionApplied] = useState(false);

    // FIX: Missing state variables
    const [isActivatingItem, setIsActivatingItem] = useState(false);

    // NEW: Mirror effect state
    const [mirrorAnswer, setMirrorAnswer] = useState(null);

    // NEW: Focus test state - tracks which answer was tested
    const [focusTestedAnswer, setFocusTestedAnswer] = useState(null);

    // NEW: Finale wager state
    const [wagerAmount, setWagerAmount] = useState(0);

    useEffect(() => { if(playerId && gameId) { sessionStorage.setItem(`quiz_pid_${gameId}`, playerId); } }, [playerId, gameId]);

    useEffect(()=>{
      const gRef = db.ref(`games/${gameId}`);
      gRef.on('value', snap => setGame(snap.val()));
      const mRef = db.ref(`games/${gameId}/meta`);
      mRef.on('value', snap => setMeta(snap.val()));
      const pRef = db.ref(`games/${gameId}/players/${playerId}`);
      pRef.on('value', snap => setPlayer(snap.val()));
      return ()=> { gRef.off(); mRef.off(); pRef.off(); };
    },[gameId, playerId]);

    useEffect(() => {
        setEliminated5050([]);
        setScannedAnswers({});
        setTimeReductionApplied(false);
        setIsActivatingItem(false);
        setMirrorAnswer(null);
        setFocusTestedAnswer(null); // Reset focus test
    }, [meta?.questionIndex]);

    // FIX: Removed automatic round start screen - now using separate phase

    // FIX: Time reduction tracking - store actual start time
    const effectiveStartTimeRef = useRef(null);

    useEffect(()=>{
      if(!meta){ setTimeLeft(0); return; }
      if(meta.phase === 'question' && meta.questionStartTime){
        // Reset effective start time when question changes
        if(!effectiveStartTimeRef.current || effectiveStartTimeRef.current !== meta.questionStartTime) {
          effectiveStartTimeRef.current = meta.questionStartTime;
          setTimeReductionApplied(false);
        }

        const tick = ()=>{
          const currentTime = Date.now();
          let elapsedNormal = Math.floor((currentTime - meta.questionStartTime) / 1000);

          // Check if time was reduced
          if(player?.activeEffects?.timeReducedAt) {
            const reductionTime = player.activeEffects.timeReducedAt;

            // Show notification once
            if(!timeReductionApplied) {
              setTimeReductionApplied(true);
              setAttackNotification({
                icon: '',
                title: 'ZEIT REDUZIERT',
                message: 'Ein Gegner hat 20 Sekunden von deiner Zeit gestohlen'
              });
              setTimeout(() => setAttackNotification(null), 3000);
            }

            // NEW: Fixed 20 second reduction with minimum 10s remaining
            const TIME_REDUCTION = 20; // Fixed 20 seconds penalty
            const MIN_TIME_REMAINING = 10; // Always leave at least 10 seconds

            const elapsedBeforeReduction = Math.floor((reductionTime - meta.questionStartTime) / 1000);
            const elapsedAfterReduction = Math.floor((currentTime - reductionTime) / 1000);

            // Add fixed penalty
            elapsedNormal = elapsedBeforeReduction + elapsedAfterReduction + TIME_REDUCTION;

            // Guarantee minimum time remains
            if(QUESTION_TIME - elapsedNormal < MIN_TIME_REMAINING) {
              elapsedNormal = QUESTION_TIME - MIN_TIME_REMAINING;
            }
          }

          setTimeLeft(Math.max(0, QUESTION_TIME - elapsedNormal));
        };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else if(meta.phase === 'finalQuestion' && meta.finalQuestionStartTime){
        const tick = ()=>{ const elapsed = Math.floor((Date.now() - meta.finalQuestionStartTime)/1000); setTimeLeft(Math.max(0, FINAL_TIME - elapsed)); };
        tick(); const t = setInterval(tick, 500); return ()=> clearInterval(t);
      } else { setTimeLeft(0); }
    },[meta?.questionStartTime, meta?.finalQuestionStartTime, meta?.phase, player?.activeEffects?.timeReducedAt, timeReductionApplied]);

    useEffect(() => {
        if (meta?.phase === 'results') {
            setPlayerReveal(false);
            const t = setTimeout(() => {
              setPlayerReveal(true);
              // Mark player as ready if they don't have a new item
              if(!player?.hasNewItem) {
                db.ref(`games/${gameId}/players/${playerId}/readyForNext`).set(true);
              }
            }, 3000);
            return () => clearTimeout(t);
        } else {
            setPlayerReveal(false);
        }
    }, [meta?.phase, meta?.questionIndex]);

    // NEW: Detect when new item is received and trigger roulette
    useEffect(() => {
      if(player?.hasNewItem && meta?.phase === 'results' && playerReveal) {
        const currentSlots = player.itemSlots || [];
        const lastItem = currentSlots[currentSlots.length - 1];
        if(lastItem && !pendingNewItem) {
          setPendingNewItem(lastItem);
          
          // Wait 1.5 seconds after reveal, then start roulette
          setTimeout(() => {
            startItemRoulette(lastItem);
          }, 1500);
        }
      }
    }, [player?.hasNewItem, meta?.phase, playerReveal]);

    const startItemRoulette = (finalItem) => {
      // Generate roulette items - all mystery boxes until reveal
      const randomItems = [];

      // Add 20 mystery boxes - all items appear as mystery until revealed
      for(let i = 0; i < 20; i++) {
        randomItems.push({ icon: 'icons/Fragezeichen.png', key: `mystery-${i}`, isMystery: true });
      }
      
      setRouletteItems(randomItems);
      setFinalRouletteItem(finalItem);
      setRoulettePhase('spinning');
      setShowItemRoulette(true);
      
      // Timing sequence
      setTimeout(() => setRoulettePhase('slowing'), 2000);
      setTimeout(() => setRoulettePhase('stopping'), 3000);
      setTimeout(() => setRoulettePhase('revealed'), 3800);
    };

    const closeItemRoulette = async () => {
      setShowItemRoulette(false);
      setPendingNewItem(null);
      await db.ref(`games/${gameId}/players/${playerId}/hasNewItem`).set(false);
      // Mark player as ready for next question
      await db.ref(`games/${gameId}/players/${playerId}/readyForNext`).set(true);
    };

    // Item Tooltip handlers removed - no longer needed

    // Check for freeze effect
    useEffect(() => {
      if(player?.activeEffects?.frozen && player?.activeEffects?.frozenUntil) {
        const checkFreeze = () => {
          const now = Date.now();
          if(now < player.activeEffects.frozenUntil) {
            setIsFrozen(true);
            setFreezeTimeLeft(Math.ceil((player.activeEffects.frozenUntil - now) / 1000));
          } else {
            setIsFrozen(false);
            setFreezeTimeLeft(0);
          }
        };
        checkFreeze();
        const interval = setInterval(checkFreeze, 100);
        return () => clearInterval(interval);
      } else {
        setIsFrozen(false);
        setFreezeTimeLeft(0);
      }
    }, [player?.activeEffects]);

    // Check for attack notifications
    useEffect(() => {
      if(player?.activeEffects?.poisoned && meta?.phase === 'question') {
        setAttackNotification({
          icon: '',
          title: 'ATTACKE',
          message: 'Du erhältst 25% weniger Punkte'
        });
        setTimeout(() => setAttackNotification(null), 3000);
      }

      if(player?.activeEffects?.frozen && meta?.phase === 'question') {
        setAttackNotification({
          icon: '',
          title: 'ATTACKE',
          message: 'Du bist für 8 Sekunden blockiert'
        });
        setTimeout(() => setAttackNotification(null), 3000);
      }
      
      if(player?.activeEffects?.swappedWith && meta?.phase === 'results') {
        // FIX: Add null check for game object
        const swappedPlayer = game?.players?.[player.activeEffects.swappedWith];
        if(swappedPlayer) {
          setAttackNotification({
            icon: '🔄',
            title: 'PLATZTAUSCHER',
            message: `Punkte getauscht mit ${swappedPlayer.name || 'einem Spieler'}`
          });
          setTimeout(() => setAttackNotification(null), 4000);
        }
      }
    }, [player?.activeEffects?.poisoned, player?.activeEffects?.frozen, player?.activeEffects?.swappedWith, meta?.questionIndex, meta?.phase]);

    const useItem = (item, slotIndex) => {
      // FIX: Prevent race conditions with double-click protection
      if(isFrozen || isActivatingItem) {
        console.log('Item activation blocked: frozen or already activating');
        return;
      }

      // FIX: Only allow one item per question
      if(player?.usedItemThisQuestion) {
        alert('Du kannst nur ein Item pro Frage verwenden!');
        return;
      }

      setIsActivatingItem(true);

      if(item.needsTarget) {
        setSelectedItem({...item, slotIndex});
        setTargetModalOpen(true);
      } else {
        activateItem(item, slotIndex, null);
      }
    };

    const activateItem = async (item, slotIndex, targetId) => {
      try {
        setItemModalOpen(false);
        setTargetModalOpen(false);

        const updates = {};
        const currentSlots = player.itemSlots || [];
        const newSlots = currentSlots.filter((_, idx) => idx !== slotIndex);
        updates[`games/${gameId}/players/${playerId}/itemSlots`] = newSlots;

      // Apply item effects
      if(item.id === 'schild') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/shield`] = true;
      } else if(item.id === 'turbo') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/turbo`] = true;
      } else if(item.id === 'magnet') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/magnet`] = true;
      } else if(item.id === 'spiegelglas') {
        updates[`games/${gameId}/players/${playerId}/activeEffects/mirror`] = true;

        // FIX: Calculate most chosen answer
        const currentQuestion = meta.questionIndex || 0;
        const allPlayers = game.players || {};
        const answerCounts = {};

        Object.values(allPlayers).forEach(p => {
          if(p.currentAnswer !== null && p.currentAnswer !== undefined) {
            answerCounts[p.currentAnswer] = (answerCounts[p.currentAnswer] || 0) + 1;
          }
        });

        // Find most common answer
        let mostCommon = null;
        let maxCount = 0;
        Object.entries(answerCounts).forEach(([ans, count]) => {
          if(count > maxCount) {
            maxCount = count;
            mostCommon = parseInt(ans);
          }
        });

        if(mostCommon !== null) {
          setMirrorAnswer(mostCommon);
        }
      } else if(item.id === 'giftpfeil' && targetId) {
        // FIX: Add null checks for target player
        const targetPlayer = game?.players?.[targetId];
        if(targetPlayer) {
          if(targetPlayer.activeEffects?.shield) {
            // Reflected back with reduced damage (10% instead of 25%)
            updates[`games/${gameId}/players/${playerId}/activeEffects/reflectedAttack`] = true;
            // Show reflection notification
            setAttackNotification({
              icon: '',
              title: 'REFLEKTIERT',
              message: 'Deine Attacke wurde reflektiert! Du bekommst 10% weniger Punkte'
            });
            setTimeout(() => setAttackNotification(null), 3000);
          } else {
            updates[`games/${gameId}/players/${targetId}/activeEffects/poisoned`] = true;
          }
        }
      } else if(item.id === 'freeze' && targetId) {
        // FIX: Add null checks for target player
        const targetPlayer = game?.players?.[targetId];
        if(targetPlayer) {
          if(targetPlayer.activeEffects?.shield) {
            // Reflected - freeze yourself
            const frozenUntil = Date.now() + 8000;
            updates[`games/${gameId}/players/${playerId}/activeEffects/frozen`] = true;
            updates[`games/${gameId}/players/${playerId}/activeEffects/frozenUntil`] = frozenUntil;
            // Show reflection notification
            setAttackNotification({
              icon: '',
              title: 'REFLEKTIERT',
              message: 'Deine Attacke wurde reflektiert! Du bist jetzt blockiert'
            });
            setTimeout(() => setAttackNotification(null), 3000);
          } else {
            const frozenUntil = Date.now() + 8000;
            updates[`games/${gameId}/players/${targetId}/activeEffects/frozen`] = true;
            updates[`games/${gameId}/players/${targetId}/activeEffects/frozenUntil`] = frozenUntil;
          }
        }
      } else if(item.id === 'zeitschnapper' && targetId) {
        // FIX: Add null checks for target player
        const targetPlayer = game?.players?.[targetId];
        if(targetPlayer) {
          const currentTime = Date.now();
          if(targetPlayer.activeEffects?.shield) {
            // Reflected - reduce own time
            updates[`games/${gameId}/players/${playerId}/activeEffects/timeReducedAt`] = currentTime;
            // Show reflection notification
            setAttackNotification({
              icon: '',
              title: 'REFLEKTIERT',
              message: 'Deine Attacke wurde reflektiert! Deine Zeit wurde halbiert'
            });
            setTimeout(() => setAttackNotification(null), 3000);
          } else {
            updates[`games/${gameId}/players/${targetId}/activeEffects/timeReducedAt`] = currentTime;
          }
        }
      } else if(item.id === 'zapfer') {
        const q = (game.questions || [])[meta.questionIndex || 0];
        if(q) {
          // Check if player is top player
          const playersArr = Object.entries(game.players || {}).map(([pid, p]) => ({pid, score: p.score || 0}));
          playersArr.sort((a, b) => b.score - a.score);
          const isTopPlayer = playersArr.length > 0 && playersArr[0].pid === playerId;

          const wrong = q.answers.map((_, i) => i).filter(i => i !== q.correct);
          const eliminateCount = isTopPlayer ? 1 : 2; // Top-Spieler: nur 1 falsche, andere: 2 falsche
          const toEliminate = shuffle(wrong).slice(0, eliminateCount);
          setEliminated5050(toEliminate);
        }
      } else if(item.id === 'fokus') {
        // NEW: Fokus - Shows if your answer is correct
        updates[`games/${gameId}/players/${playerId}/activeEffects/focus`] = true;
      } else if(item.id === 'scanner' && targetId) {
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer && targetPlayer.currentAnswer !== null && targetPlayer.currentAnswer !== undefined) {
          setScannedAnswers(prev => ({...prev, [targetId]: targetPlayer.currentAnswer}));
        }
      } else if(item.id === 'nehmer' && targetId) {
        const targetPlayer = game.players?.[targetId];
        if(targetPlayer) {
          const targetSlots = targetPlayer.itemSlots || [];
          // Filter out legendary items
          const stealableItems = targetSlots.filter(itm => itm.rarity !== 'legendary');

          if(stealableItems.length > 0) {
            // Pick random item to steal
            const stolenItem = stealableItems[Math.floor(Math.random() * stealableItems.length)];
            const stolenIndex = targetSlots.findIndex(itm => itm.id === stolenItem.id);

            // Remove from target
            const newTargetSlots = targetSlots.filter((_, idx) => idx !== stolenIndex);
            updates[`games/${gameId}/players/${targetId}/itemSlots`] = newTargetSlots;

            // Add to own slots (if space available)
            const mySlots = player.itemSlots || [];
            if(mySlots.length < ITEM_SLOTS) {
              updates[`games/${gameId}/players/${playerId}/itemSlots`] = [...mySlots, stolenItem];
            }
          }
        }
      } else if(item.id === 'platztauscher') {
        // NEW: Neighbor-based swap logic
        if(game?.players) {
          // Sort players by score to find ranking
          const playersArr = Object.entries(game.players).sort((a, b) => (b[1].score || 0) - (a[1].score || 0));
          const myIndex = playersArr.findIndex(([pid]) => pid === playerId);

          if(myIndex !== -1) {
            let targetIndex;

            // If first place: can only swap with second
            if(myIndex === 0) {
              targetIndex = 1;
            }
            // If last place: can only swap with second-to-last
            else if(myIndex === playersArr.length - 1) {
              targetIndex = myIndex - 1;
            }
            // Otherwise: 50/50 chance to swap with neighbor above or below
            else {
              targetIndex = Math.random() > 0.5 ? myIndex - 1 : myIndex + 1;
            }

            const [randomTarget] = playersArr[targetIndex];
            const targetPlayer = game.players[randomTarget];

            // Check if target has shield
            if(targetPlayer?.activeEffects?.shield) {
              setAttackNotification({
                icon: '',
                title: 'BLOCKIERT',
                message: 'Dein Platztauscher wurde von einem Schild blockiert'
              });
              setTimeout(() => setAttackNotification(null), 3000);
            } else {
              // Perform the swap at results phase
              updates[`games/${gameId}/players/${playerId}/activeEffects/swapPointsWith`] = randomTarget;
              updates[`games/${gameId}/players/${randomTarget}/activeEffects/swappedWith`] = playerId;
            }
          }
        }
      }

      // FIX: Log ALL items in actions panel
      await db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).once('value', s => {
         const arr = s.val() || [];
         arr.push({ type: item.effect, from: playerId, to: targetId || playerId, itemId: item.id.toUpperCase() });
         db.ref(`games/${gameId}/meta/actions/${meta.questionIndex||0}`).set(arr);
      });

        // FIX: Mark that player has used an item this question
        updates[`games/${gameId}/players/${playerId}/usedItemThisQuestion`] = true;

        await db.ref().update(updates);

        // Reset activation lock after a short delay
        setTimeout(() => setIsActivatingItem(false), 500);
      } catch(error) {
        console.error('Error activating item:', error);
        setIsActivatingItem(false);
        alert('Fehler beim Aktivieren des Items');
      }
    };

    const pickCategory = async (cat) => {
        try {
          await db.ref(`games/${gameId}/meta`).update({
              nextCategory: cat,
              categoryChooserForRound: playerId
          });
          setBonusCategoryModalOpen(false);
        } catch(error) {
          console.error('Error picking category:', error);
          alert('Fehler beim Wählen der Kategorie');
        }
    };

    if(!game || !meta || !player) return <div className="min-h-screen flex items-center justify-center">Warte auf Spiel...</div>;

    // NEW: Pause Screen for Players
    if(meta.phase === 'paused') {
        return (
            <div className="min-h-screen flex items-center justify-center p-4">
                <div className="card" style={{textAlign:'center'}}>
                    <h2 style={{fontSize:48, fontWeight:900, color:'var(--rtl-orange)', marginBottom:20}}>PAUSE</h2>
                    <p style={{fontSize:20, color:'var(--muted)'}}>Das Spiel ist pausiert.</p>
                    <p style={{fontSize:18, color:'var(--muted)', marginTop:10}}>Warte auf den Host...</p>
                </div>
            </div>
        );
    }

    // NEW: Round Start Screen for Players
    if(meta.phase === 'roundStart') {
        return (
            <div className="min-h-screen p-4" style={{display:'flex', alignItems:'center', justifyContent:'center'}}>
              <div className="card" style={{width:'97%', maxWidth:'100%', textAlign:'center', padding:'20px'}}>
                <img src="Logo.png" alt="Logo" style={{height:32, width:'auto', margin:'0 auto 20px'}} />

                <h2 style={{fontSize:36, fontWeight:900, color:'var(--rtl-orange)', margin:'0 0 25px 0', textTransform:'uppercase', letterSpacing:3}}>
                  RUNDE {meta.round}
                </h2>

                <div style={{padding:'20px 25px', border:'3px solid var(--rtl-orange)', marginBottom:20, textAlign:'center'}}>
                  <div style={{fontSize:14, color:'var(--muted)', textTransform:'uppercase', letterSpacing:1, fontWeight:700, marginBottom:8}}>
                    Kategorie
                  </div>
                  <div style={{fontSize:26, fontWeight:900, color:'var(--rtl-orange)', letterSpacing:2, lineHeight:1.2}}>
                    {meta.currentCategory || 'Allgemein'}
                  </div>
                </div>

                <div style={{marginBottom:15, textAlign:'center', padding:'18px', background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.2)'}}>
                  <div style={{fontSize:13, color:'var(--muted)', textTransform:'uppercase', letterSpacing:1, marginBottom:8}}>
                    Punkte pro Antwort
                  </div>
                  <div style={{fontSize:32, fontWeight:900, color:'white', lineHeight:1}}>{ROUND_POINTS[meta.round || 1]}</div>
                </div>

                <div style={{marginBottom:20, textAlign:'center', padding:'18px', background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.2)'}}>
                  <div style={{fontSize:13, color:'var(--muted)', textTransform:'uppercase', letterSpacing:1, marginBottom:8}}>
                    Fragen
                  </div>
                  <div style={{fontSize:32, fontWeight:900, color:'white', lineHeight:1}}>{QUESTIONS_PER_ROUND}</div>
                </div>

                <div style={{fontSize:14, color:'var(--muted)', marginTop:25, padding:'12px', background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                  Warte auf den Host...
                </div>

                <button
                  className="btn"
                  onClick={() => {
                    if(document.documentElement.requestFullscreen) {
                      document.documentElement.requestFullscreen();
                    }
                  }}
                  style={{marginTop:15, fontSize:13, padding:'10px 18px', background:'rgba(255,255,255,0.1)'}}
                >
                  📱 Vollbild
                </button>
              </div>
            </div>
        );
    }

    if(meta.phase === 'finalIntro') {
        if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale</h2><p>Du bist Zuschauer.</p></div></div>;
        return (
            <div className="min-h-screen p-4 flex items-center justify-center">
                <div className="card" style={{textAlign:'center', width:'100%', maxWidth:'600px', display:'flex', flexDirection:'column', justifyContent:'center', padding:'40px 30px'}}>
                    <RTLLogo size="md" style={{marginBottom:30}} />
                    <h2 style={{fontSize:'3rem', marginBottom:30, fontWeight:900, letterSpacing:4, color:'var(--rtl-orange)'}}>FINALE</h2>

                    {/* Regel-Infobox */}
                    <div style={{
                      background:'rgba(155, 89, 182, 0.1)',
                      border:'2px solid #9b59b6',
                      padding:'25px',
                      marginBottom:30,
                      textAlign:'left'
                    }}>
                      <h3 style={{fontSize:18, fontWeight:900, color:'#9b59b6', marginBottom:15, textTransform:'uppercase', letterSpacing:1}}>
                        📋 Regeln
                      </h3>
                      <ul style={{margin:0, padding:'0 0 0 20px', color:'var(--muted)', fontSize:14, lineHeight:1.8}}>
                        <li><strong style={{color:'white'}}>Startscore:</strong> 50% deiner aktuellen Punkte</li>
                        <li><strong style={{color:'white'}}>Fragen:</strong> {FINAL_QUESTIONS} offene Fragen</li>
                        <li><strong style={{color:'white'}}>Wager:</strong> Setze pro Frage Punkte ein (0 - aktueller Score)</li>
                        <li><strong style={{color:'white'}}>Richtig:</strong> +Einsatz | <strong style={{color:'white'}}>Falsch:</strong> -Einsatz</li>
                        <li><strong style={{color:'white'}}>Sieg:</strong> Höchster Endscore gewinnt</li>
                      </ul>
                    </div>

                    <div style={{marginBottom:30, fontSize:16, color:'var(--muted)'}}>
                      Dein Startscore: <strong style={{color:'var(--rtl-orange)', fontSize:20}}>{Math.floor((player.score || 0) * 0.5)}</strong> Punkte
                    </div>

                    {!player.finalistReady ? (
                        <button className="btn btn-host w-full" style={{padding:'20px 30px', fontSize:'1.5rem', fontWeight:900}} onClick={()=>db.ref(`games/${gameId}/players/${playerId}/finalistReady`).set(true)}>
                          ICH BIN BEREIT ▶
                        </button>
                    ) : (
                        <div style={{color:'var(--rtl-orange)', fontSize:'1.5rem', fontWeight:900, padding:'20px 0', background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.1)'}}>
                          ✓ BEREIT - WARTE AUF GEGNER...
                        </div>
                    )}
                </div>
            </div>
        );
    }
    if(meta.phase === 'finalQuestion'){
       const question = (game.finalQuestions||[])[meta.finalQuestionIndex||0];
       if(!player.isFinalist) return <div className="min-h-screen flex items-center justify-center p-4"><div className="card"><h2>Finale läuft...</h2></div></div>;

       const qIndex = meta.finalQuestionIndex || 0;
       const hasAnswered = player.finalAnswers && player.finalAnswers[qIndex];
       const hasWagered = player.finalWagers && player.finalWagers[qIndex] !== undefined;
       const currentScore = player.finalCurrentScore || 0;

       // Initialize wager if not set
       React.useEffect(() => {
         if(hasWagered && wagerAmount === 0) {
           setWagerAmount(player.finalWagers[qIndex]);
         }
       }, [hasWagered]);

       const submitWagerAndAnswer = async () => {
         if(!finalAnswer.trim()) return;
         await db.ref(`games/${gameId}/players/${playerId}`).update({
           [`finalWagers/${qIndex}`]: wagerAmount,
           [`finalAnswers/${qIndex}`]: finalAnswer
         });
         setFinalAnswer('');
       };

       return (
          <div className="min-h-screen p-4" style={{display:'flex', alignItems:'center', justifyContent:'center'}}>
            <div className="card" style={{maxWidth:600, width:'100%'}}>
              <RTLLogo size="sm" style={{marginBottom:20}} />

              <div style={{marginBottom:30}}>
                <div style={{fontSize:14, color:'var(--muted)', marginBottom:5}}>FINALE - FRAGE {qIndex+1} VON {FINAL_QUESTIONS}</div>
                <div style={{fontSize:16, fontWeight:900, color:'var(--rtl-orange)'}}>Aktueller Score: {currentScore} Punkte</div>
              </div>

              <h2 style={{fontSize:24, fontWeight:900, marginBottom:30}}>{question?.question}</h2>

              {!hasAnswered ? (
                <>
                  {/* Wager Slider */}
                  <div style={{marginBottom:30}}>
                    <label style={{display:'block', marginBottom:15, fontSize:16, fontWeight:700, color:'var(--muted)'}}>
                      Wie viele Punkte setzt du ein?
                    </label>
                    <div style={{marginBottom:15}}>
                      <div style={{fontSize:36, fontWeight:900, color:'#9b59b6', textAlign:'center', marginBottom:10}}>
                        {wagerAmount} Punkte
                      </div>
                      <input
                        type="range"
                        min="0"
                        max={currentScore}
                        value={wagerAmount}
                        onChange={e => setWagerAmount(parseInt(e.target.value))}
                        style={{
                          width: '100%',
                          height: 20,
                          WebkitAppearance: 'none',
                          background: `linear-gradient(to right, #9b59b6 0%, #9b59b6 ${(wagerAmount/currentScore)*100}%, rgba(255,255,255,0.1) ${(wagerAmount/currentScore)*100}%, rgba(255,255,255,0.1) 100%)`,
                          outline: 'none',
                          borderRadius: 0,
                          border: '2px solid #9b59b6'
                        }}
                      />
                      <div style={{display:'flex', justifyContent:'space-between', marginTop:8, fontSize:12, color:'var(--muted)'}}>
                        <span>0</span>
                        <span>{currentScore}</span>
                      </div>
                    </div>
                    <div style={{fontSize:13, color:'var(--muted)', textAlign:'center', fontStyle:'italic'}}>
                      ✓ Richtig → +{wagerAmount} Punkte | ✗ Falsch → -{wagerAmount} Punkte
                    </div>
                  </div>

                  {/* Answer Input */}
                  <div style={{marginBottom:20}}>
                    <label style={{display:'block', marginBottom:10, fontSize:14, fontWeight:700, color:'var(--muted)'}}>
                      Deine Antwort
                    </label>
                    <input
                      className="w-full p-3"
                      value={finalAnswer}
                      onChange={e => setFinalAnswer(e.target.value)}
                      placeholder="Antwort eingeben..."
                      style={{fontSize:18}}
                    />
                  </div>

                  <button
                    className="btn btn-host w-full"
                    onClick={submitWagerAndAnswer}
                    disabled={!finalAnswer.trim()}
                    style={{fontSize:20, padding:'18px', opacity: finalAnswer.trim() ? 1 : 0.5}}
                  >
                    ANTWORT SENDEN ▶
                  </button>
                </>
              ) : (
                <div style={{textAlign:'center', padding:40, background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.1)'}}>
                  <div style={{fontSize:18, fontWeight:900, color:'var(--rtl-orange)', marginBottom:10}}>✓ ANTWORT GESENDET</div>
                  <div style={{fontSize:14, color:'var(--muted)'}}>Eingesetzt: {player.finalWagers[qIndex]} Punkte</div>
                </div>
              )}
            </div>
          </div>
       );
    }

    if(meta.phase === 'question'){
       const question = (game.questions||[])[meta.questionIndex||0];
       const hasAnswered = player.currentAnswer !== null && player.currentAnswer !== undefined;
       const itemSlots = player.itemSlots || [];
       
       return (
         <div className="min-h-screen p-4" style={{display:'flex', alignItems:'center', justifyContent:'center', position:'relative'}}>
           {isFrozen && (
              <div className="frozen-overlay">
                EINGEFROREN {freezeTimeLeft}s
              </div>
           )}

           {/* Attack Notification */}
           {attackNotification && (
             <div className="attack-notification">
               <h3>{attackNotification.icon} {attackNotification.title}</h3>
               <p>{attackNotification.message}</p>
             </div>
           )}

           <div className="card" style={{display:'flex', flexDirection:'column', width:'97%', height:'92vh', maxWidth:'100%', boxSizing:'border-box'}}>
             {/* Header */}
             <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:20, flexShrink:0}}>
                 <div style={{display:'flex', alignItems:'center', gap:8}}>
                   <img src="Logo.png" alt="Logo" style={{height:28, width:'auto'}} />
                   <div style={{display:'flex', flexDirection:'column', gap:2}}>
                     <span style={{fontWeight:900, fontSize:11, color:'var(--muted)', letterSpacing:1}}>RUNDE {meta.round}</span>
                     <span style={{fontWeight:900, fontSize:16, color:'var(--tile)'}}>Score: {player.score}</span>
                   </div>
                 </div>
                 <div style={{textAlign:'right'}}>
                   <div style={{fontSize:12, color:'var(--muted)', marginBottom:4}}>Zeit</div>
                   <div style={{fontWeight:900, color:'var(--rtl-orange)', fontSize:24}}>{timeLeft}s</div>
                 </div>
             </div>

             {player.hasNewItem && (
                <div style={{background:'var(--rtl-orange)', color:'#000', padding:12, marginBottom:20, fontWeight:900, textAlign:'center', fontSize:14, flexShrink:0}}>
                  📦 NEUES ITEM ERHALTEN!
                </div>
             )}

             {/* Question */}
             <div style={{marginBottom:20, flexShrink:0}}>
               <h3 style={{fontSize:28, fontWeight:900, lineHeight:1.4, margin:0}}>{question?.question}</h3>
             </div>

             {/* Item Slots */}
             <div style={{display:'flex', gap:10, marginBottom:20, alignItems:'center', justifyContent:'space-between', flexShrink:0}}>
               <div style={{display:'flex', gap:10}}>
                 {[0, 1].map(slotIdx => {
                    const item = itemSlots[slotIdx];
                    const isDisabled = isFrozen || isActivatingItem || player?.usedItemThisQuestion;
                    return (
                      <div
                        key={slotIdx}
                        className={`item-slot ${item ? `rarity-${item.rarity}` : 'empty'}`}
                        onClick={() => item && !isDisabled && useItem(item, slotIdx)}
                        title={item ? (player?.usedItemThisQuestion ? item.name + ' (Bereits ein Item verwendet)' : item.name) : 'Leer'}
                        style={{
                          width: 65,
                          height: 65,
                          cursor: item && !isDisabled ? 'pointer' : 'default',
                          opacity: item && player?.usedItemThisQuestion ? 0.4 : 1,
                          filter: item && player?.usedItemThisQuestion ? 'grayscale(100%)' : 'none'
                        }}
                      >
                        {item ? <img src={item.icon} alt={item.name} style={{width: '100%', height: '100%', objectFit: 'contain'}} /> : <img src="icons/Fragezeichen.png" alt="Leer" style={{width: '70%', height: '70%', objectFit: 'contain', opacity: 0.3}} />}
                      </div>
                    );
                 })}
               </div>

               {/* Items Info Button */}
               <button
                 className="btn"
                 onClick={() => setShowItemsInfo(true)}
                 style={{
                   padding:'8px 14px',
                   fontSize:13,
                   background:'rgba(255,255,255,0.1)',
                   border:'1px solid rgba(255,255,255,0.2)'
                 }}
                 title="Alle Items anzeigen"
               >
                 ℹ️
               </button>
             </div>

             {/* Answer Buttons */}
             <div style={{display:'flex', flexDirection:'column', gap:12, flex:1, minHeight:0}}>
               {question?.answers.map((a,i)=>{
                 const is5050Eliminated = eliminated5050.includes(i);
                 const isScanned = Object.values(scannedAnswers).includes(i);
                 const isMirrorAnswer = mirrorAnswer === i;
                 const hasFocus = player?.activeEffects?.focus;
                 const isMyAnswer = player.currentAnswer === i;
                 const isCorrectAnswer = i === question.correct;
                 const isTested = focusTestedAnswer === i;
                 const showFocusIndicator = hasFocus && isTested; // Nur bei getesteter Antwort

                 // NEW: Click handler with Focus test mode
                 const handleAnswerClick = () => {
                   if(isFrozen) return;

                   // If Focus is active and this answer is not yet locked
                   if(hasFocus && !isMyAnswer) {
                     setFocusTestedAnswer(i); // Test this answer (shows ✓/✗)
                   } else {
                     // Lock the answer
                     db.ref(`games/${gameId}/players/${playerId}/currentAnswer`).set(i);
                     setFocusTestedAnswer(null); // Clear test after locking
                   }
                 };

                 return (
                   <button
                      key={i}
                      disabled={hasAnswered||timeLeft<=0||isFrozen||is5050Eliminated}
                      onClick={handleAnswerClick}
                      style={{
                          padding:'18px 16px',
                          background:player.currentAnswer===i?'var(--rtl-orange)':(is5050Eliminated ? '#333' : 'white'),
                          color:player.currentAnswer===i?'white':(is5050Eliminated ? '#666' : '#0b0b0b'),
                          border: player.currentAnswer===i ? '3px solid var(--rtl-orange)' : (isMirrorAnswer ? '3px solid var(--rtl-purple)' : (isScanned ? '3px solid var(--rtl-orange)' : 'none')),
                          textAlign:'left',
                          fontSize:22,
                          fontWeight:700,
                          display:'flex',
                          alignItems:'center',
                          gap: '10px',
                          transition: 'all 0.2s',
                          opacity: is5050Eliminated ? 0.3 : 1,
                          position: 'relative',
                          lineHeight:1.4,
                          flex: '1 1 0',
                          minHeight: 60
                      }}>
                      <span style={{fontWeight:900, color: player.currentAnswer===i?'white':(is5050Eliminated ? '#666' : 'var(--rtl-orange)'), fontSize:24, flexShrink:0}}>{String.fromCharCode(65+i)}</span>
                      <span style={{flex:1}}>{a}</span>
                      {isScanned && <span style={{color:'var(--rtl-orange)', fontSize:20, flexShrink:0}}>👁️</span>}
                      {isMirrorAnswer && <span style={{color:'var(--rtl-purple)', fontSize:22, flexShrink:0}}>🔮</span>}
                      {showFocusIndicator && (
                        <span style={{
                          color: isCorrectAnswer ? '#00ff00' : '#ff0000',
                          fontSize: 24,
                          flexShrink: 0,
                          fontWeight: 900
                        }}>
                          {isCorrectAnswer ? '✓' : '✗'}
                        </span>
                      )}
                   </button>
                 )
               })}
             </div>
           </div>
           
           {/* Item Tooltip */}
           {showItemTooltip && tooltipItem && (
             <div 
               className="item-tooltip" 
               style={{
                 left: tooltipPosition.x,
                 top: tooltipPosition.y,
                 transform: 'translate(-50%, -100%)'
               }}
             >
               <h4>
                 <img src={tooltipItem.icon} alt={tooltipItem.name} style={{width: 28, height: 28, objectFit: 'contain'}} />
                 {tooltipItem.name}
               </h4>
               <div className={`rarity-mini ${tooltipItem.rarity}`}>
                 {translateRarity(tooltipItem.rarity)}
               </div>
               <p>{tooltipItem.description}</p>
               <div style={{fontSize: 11, color: 'var(--rtl-orange)', marginTop: 10, fontWeight: 700}}>
                 {tooltipItem.needsTarget ? '🎯 Benötigt Ziel' : '✨ Auf dich selbst'}
               </div>
             </div>
           )}
           
           {targetModalOpen && selectedItem && (
               <div className="modal-backdrop">
                   <div className="modal-card">
                       <h3>{selectedItem.name} - Ziel wählen</h3>
                       <div style={{display:'flex',flexDirection:'column',gap:10, marginTop:20}}>
                         {Object.entries(game.players || {})
                           .filter(([pid]) => pid !== playerId)
                           .map(([pid, p]) => (
                            <button key={pid} className="btn btn-host" onClick={()=>activateItem(selectedItem, selectedItem.slotIndex, pid)}>
                              {p.name}
                            </button>
                         ))}
                         <button className="btn" style={{background:'rgba(255,255,255,0.1)'}} onClick={()=>{setTargetModalOpen(false); setSelectedItem(null); setIsActivatingItem(false);}}>Abbrechen</button>
                       </div>
                   </div>
               </div>
           )}

           {/* NEW: Items Info Modal */}
           {showItemsInfo && <ItemsInfoModal onClose={() => setShowItemsInfo(false)} />}
         </div>
       );
    }
    
    if(meta.phase === 'roundSummary') {
        // Check if this player is the category chooser
        if(meta.categoryChooserCandidate === playerId && !meta.nextCategory) {
            const used = meta.categoryState?.used || [];
            const available = CATEGORY_LIST.filter(c => !used.includes(c));
            const displayCats = available.length > 0 ? available : CATEGORY_LIST;

            // FIX: Ensure we have categories to display
            if(!displayCats || displayCats.length === 0) {
              return (
                <div className="min-h-screen flex items-center justify-center p-4">
                  <div className="card" style={{textAlign:'center'}}>
                    <h2>Fehler</h2>
                    <p>Keine Kategorien verfügbar</p>
                  </div>
                </div>
              );
            }

            return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="card" style={{width:'100%'}}>
                        <div style={{display:'flex', justifyContent:'center', marginBottom:25}}>
                          <img src="Logo.png" alt="Logo" style={{height:40, width:'auto'}} />
                        </div>
                        <h3 style={{textAlign:'center', marginBottom:15, fontSize:22, fontWeight:900, color:'var(--rtl-orange)', letterSpacing:1}}>DU WÄHLST DIE KATEGORIE</h3>
                        <p style={{textAlign:'center', marginBottom:25, color:'var(--muted)', fontSize:15}}>Als Letztplatzierter darfst du die nächste Kategorie bestimmen.</p>
                        <div style={{display:'flex', flexDirection:'column', gap:10}}>
                            {displayCats.slice(0, 3).map(c => (<button key={c} className="btn btn-host" style={{padding:16, fontSize:18}} onClick={()=>pickCategory(c)}>{c}</button>))}
                            <button className="btn" style={{padding:16, fontSize:18}} onClick={()=>pickCategory(displayCats[0])}>🎲 ZUFALL</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        // Not the chooser - show waiting screen
        return (
            <div className="min-h-screen flex items-center justify-center p-4">
                <div className="card" style={{textAlign:'center'}}>
                    <img src="Logo.png" alt="Logo" style={{height:40, width:'auto', margin:'0 auto 25px'}} />
                    <h2 style={{fontSize:26, fontWeight:900, color:'var(--rtl-orange)', marginBottom:15, letterSpacing:1}}>ZWISCHENSTAND</h2>
                    <p style={{fontSize:16, color:'var(--muted)', marginBottom:25}}>Warte auf Kategoriewahl...</p>
                    <div style={{marginTop:20, padding:20, background:'rgba(255,255,255,0.05)', border:'1px solid rgba(255,255,255,0.1)'}}>
                        <div style={{fontSize:14, color:'var(--muted)', marginBottom:8, textTransform:'uppercase', letterSpacing:1}}>Dein Score</div>
                        <div style={{fontSize:44, fontWeight:900}}>{player.score}</div>
                    </div>
                </div>
            </div>
        );
    }

    if(meta.phase === 'finished') {
      const finalScore = player.isFinalist ? (player.finalCurrentScore || 0) : (player.score || 0);
      return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="card" style={{textAlign:'center'}}>
            <img src="Logo.png" alt="Logo" style={{height:50, width:'auto', margin:'0 auto 30px'}} />
            <h2 style={{fontSize:28, fontWeight:900, color:'var(--rtl-orange)', marginBottom:15, letterSpacing:1}}>🏁 SPIEL BEENDET</h2>
            <p style={{fontSize:16, color:'var(--muted)', marginBottom:25}}>Danke fürs Spielen!</p>
            <div style={{marginTop:20, padding:25, background:'rgba(255,255,255,0.05)', border:'2px solid rgba(255,255,255,0.1)'}}>
                <div style={{fontSize:14, color:'var(--muted)', marginBottom:10, textTransform:'uppercase', letterSpacing:1}}>Dein Endergebnis</div>
                <div style={{fontSize:48, fontWeight:900, color:'var(--rtl-orange)'}}>{finalScore}</div>
                <div style={{fontSize:14, color:'var(--muted)', marginTop:5}}>Punkte</div>
            </div>
          </div>
        </div>
      );
    }

    if(meta.phase === 'results') {
        const pointsEarned = player.lastPoints || 0;
        const isCorrect = player.currentAnswer===((game.questions||[])[meta.questionIndex||0]).correct;
        
        if (!playerReveal) {
             return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="card" style={{textAlign:'center', width:'100%'}}>
                        <h2 style={{fontSize:32, fontWeight:900, color: 'var(--rtl-orange)', marginBottom:20}}>ANTWORT ERFASST</h2>
                        <div style={{fontSize:20, color:'var(--muted)'}}>Warte auf die offizielle Auflösung durch den Host...</div>
                    </div>
                </div>
            );
        }

        return (
            <>
              <div className="min-h-screen flex items-center justify-center p-4" style={{background:'var(--bg)'}}>
                  <div className="card" style={{textAlign:'center', width:'100%'}}>
                      {/* Compact Header */}
                      <div style={{display:'flex', alignItems:'center', justifyContent:'center', gap:12, marginBottom:30}}>
                           <img src="Logo.png" alt="Logo" style={{height:32, width:'auto'}} />
                           <span style={{fontWeight:900, color:'var(--tile)', fontSize:18}}>Score: {player.score}</span>
                      </div>

                      <h2 style={{fontSize:48, fontWeight:900, color: isCorrect ? 'var(--rtl-orange)' : 'white', marginBottom:25, marginTop:0}}>
                          {isCorrect ? 'RICHTIG' : 'FALSCH'}
                      </h2>
                      <div style={{background:'rgba(255,255,255,0.05)', padding:25, border:'1px solid rgba(255,255,255,0.1)'}}>
                          <div style={{fontSize:14, color:'var(--muted)', textTransform:'uppercase', fontWeight:700, letterSpacing:1}}>Punkte diese Runde</div>
                          <div style={{fontSize:52, fontWeight:900, color:'white', lineHeight:1, marginTop:10}}>
                              {pointsEarned > 0 ? '+' : ''}{pointsEarned}
                          </div>
                      </div>
                      <div style={{marginTop:25, fontSize:14, color:'var(--muted)'}}>Warte auf nächste Frage...</div>

                      {/* Items Info Button */}
                      <button
                        className="btn"
                        onClick={() => setShowItemsInfo(true)}
                        style={{
                          marginTop:20,
                          fontSize:14,
                          padding:'10px 20px',
                          background:'rgba(255,255,255,0.1)',
                          border:'1px solid rgba(255,255,255,0.2)'
                        }}
                      >
                        ℹ️ Items Info
                      </button>
                  </div>
              </div>

              {/* Items Info Modal */}
              {showItemsInfo && <ItemsInfoModal onClose={() => setShowItemsInfo(false)} />}

              {/* Item Box Roulette Animation */}
              {showItemRoulette && (
                <div className="item-roulette-overlay">
                  <div className="item-box-container">
                    <div className="item-box-text">
                      {roulettePhase === 'revealed' ? 'NEUES ITEM' : 'ITEM BOX'}
                    </div>
                    
                    <div className="item-box-display">
                      {roulettePhase === 'revealed' ? (
                        <div className="item-revealed">
                          <img src={finalRouletteItem?.icon} alt={finalRouletteItem?.name} style={{width: 100, height: 100, objectFit: 'contain'}} />
                        </div>
                      ) : (
                        <div className={`item-roulette-strip ${roulettePhase}`}>
                          {rouletteItems.map((item, idx) => (
                            <div key={item.key || idx} className={`roulette-item ${item.isMystery ? 'mystery' : ''}`}>
                              <img src={item.icon} alt={item.isMystery ? 'Mystery' : item.name} style={{width: 60, height: 60, objectFit: 'contain'}} />
                            </div>
                          ))}
                        </div>
                      )}
                    </div>

                    {roulettePhase === 'revealed' && (
                      <div className="item-box-info">
                        <h3>{finalRouletteItem?.name}</h3>
                        <div className={`rarity-badge ${finalRouletteItem?.rarity}`}>
                          {translateRarity(finalRouletteItem?.rarity)}
                        </div>
                        <p style={{marginBottom: 20}}>{finalRouletteItem?.description}</p>
                        <button 
                          className="btn btn-host" 
                          onClick={closeItemRoulette}
                          style={{fontSize: 18, padding: '15px 40px'}}
                        >
                          VERSTANDEN
                        </button>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </>
        );
    }

    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="card" style={{textAlign:'center'}}>
          <div style={{color:'var(--muted)', marginBottom:20}}>Warte auf Host...</div>
          <button
            className="btn"
            onClick={() => {
              if(document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
              }
            }}
            style={{fontSize:14, padding:'10px 20px', background:'rgba(255,255,255,0.1)'}}
          >
            📱 Vollbild
          </button>
        </div>
      </div>
    );
  }

  // Items Info Modal Component
  function ItemsInfoModal({ onClose }) {
    const categories = {
      'Defensive': ['SCHILD', 'MAGNET', 'FOKUS'],
      'Strategisch': ['SPIEGELGLAS', 'ZAPFER', 'SCANNER'],
      'Aggressiv': ['GIFTPFEIL', 'ZEITSCHNAPPER', 'NEHMER', 'TURBO', 'FREEZE'],
      'Chaos': ['PLATZTAUSCHER']
    };

    return (
      <div className="items-info-modal" onClick={onClose}>
        <div style={{
          background:'#000',
          border:'2px solid rgba(255,255,255,0.2)',
          padding:'20px',
          maxWidth:'400px',
          width:'90%',
          maxHeight:'80vh',
          overflowY:'auto'
        }} onClick={(e) => e.stopPropagation()}>
          <h2 style={{margin:'0 0 20px 0', fontSize:22, fontWeight:900, color:'white', textAlign:'center'}}>Alle Items</h2>

          {Object.entries(categories).map(([category, itemIds]) => (
            <div key={category} style={{marginBottom:20}}>
              <h3 style={{fontSize:16, fontWeight:900, color:'var(--rtl-orange)', marginBottom:10, textTransform:'uppercase'}}>
                {category}
              </h3>
              {itemIds.map(itemId => {
                const item = ITEM_TYPES[itemId];
                return (
                  <div key={item.id} style={{
                    background:'rgba(255,255,255,0.03)',
                    borderLeft:'3px solid rgba(255,255,255,0.2)',
                    padding:'12px',
                    marginBottom:'8px'
                  }}>
                    <div style={{display:'flex', alignItems:'center', gap:10, marginBottom:6}}>
                      <img src={item.icon} alt={item.name} style={{width:24, height:24, objectFit:'contain'}} />
                      <span style={{fontSize:15, fontWeight:900, color:'white'}}>{item.name}</span>
                    </div>
                    <p style={{margin:0, fontSize:13, color:'var(--muted)', lineHeight:1.4}}>{item.description}</p>
                  </div>
                );
              })}
            </div>
          ))}

          <button
            className="btn btn-host w-full"
            onClick={onClose}
            style={{marginTop:15, fontSize:16, padding:'12px'}}
          >
            SCHLIESSEN
          </button>
        </div>
      </div>
    );
  }

  function PlayerJoin({ joinGameId, onJoined }){
    const [name,setName] = useState('');

    const handleJoin = async ()=>{
      if(!name) return;
      const snap = await db.ref(`games/${joinGameId}`).get();
      if(!snap.exists()) return alert('Code falsch');
      const pid = makePlayerId();
      await db.ref(`games/${joinGameId}/players/${pid}`).set({ name, score:0, itemSlots:[] });
      onJoined(joinGameId, pid, name);
    };

    return (
      <div style={{
        minHeight:'100vh',
        display:'flex',
        flexDirection:'column',
        alignItems:'center',
        padding:'40px 20px',
        background:'#000'
      }}>
        {/* Header - weiter oben positioniert */}
        <div style={{marginBottom:40, textAlign:'center'}}>
            <RTLLogo size="lg" />
            <div style={{fontSize:'2rem', fontWeight:900, color:'var(--rtl-orange)', marginTop:15, letterSpacing:2}}>AdAlliance Quiz</div>
        </div>

        {/* Login Card - kompakter */}
        <div style={{
          width:'100%',
          maxWidth:500,
          padding:30,
          background:'#111',
          border:'2px solid rgba(255,255,255,0.2)'
        }}>
          <h2 style={{
            fontSize:24,
            fontWeight:900,
            color:'var(--rtl-orange)',
            marginBottom:30,
            textTransform:'uppercase',
            letterSpacing:2,
            textAlign:'center'
          }}>
            Spieler Login
          </h2>

          <div style={{marginBottom:25}}>
             <label style={{
               display:'block',
               marginBottom:10,
               fontSize:14,
               color:'var(--muted)',
               fontWeight:700,
               textTransform:'uppercase',
               letterSpacing:1
             }}>
               Dein Name
             </label>
             <input
                value={name}
                onChange={e=>setName(e.target.value)}
                onKeyPress={e => e.key === 'Enter' && name && handleJoin()}
                placeholder="Name eingeben..."
                maxLength={12}
                autoFocus
                style={{
                  width:'100%',
                  padding:'18px 20px',
                  fontSize:20,
                  fontWeight:700,
                  border:'2px solid rgba(255,255,255,0.2)',
                  background:'rgba(255,255,255,0.05)',
                  color:'white',
                  textAlign:'center'
                }}
             />
          </div>

          <button
            className="btn btn-host"
            onClick={handleJoin}
            disabled={!name}
            style={{
              width:'100%',
              fontSize:22,
              padding:'18px 24px',
              fontWeight:900,
              letterSpacing:2,
              opacity: name ? 1 : 0.5
            }}
          >
            BEITRETEN ▶
          </button>
        </div>

        {/* Info Text unten */}
        <div style={{
          marginTop:30,
          padding:20,
          textAlign:'center',
          color:'var(--muted)',
          fontSize:14,
          maxWidth:500
        }}>
          Gib deinen Namen ein und trete dem Spiel bei
        </div>
      </div>
    );
  }

  /****************************************
   * MAIN APP
   ****************************************/
  function App(){
    const [mode,setMode] = useState('start');
    const [gameId,setGameId] = useState('');
    const [playerId,setPlayerId] = useState('');
    const [playerName,setPlayerName] = useState('');

    useEffect(()=>{
      const params = new URLSearchParams(window.location.search);
      const joinCode = params.get('join');
      if(joinCode){ 
        const savedPid = sessionStorage.getItem(`quiz_pid_${joinCode}`);
        if(savedPid) {
          db.ref(`games/${joinCode}/players/${savedPid}`).once('value', snap => {
            if(snap.exists()) { setGameId(joinCode); setPlayerId(savedPid); setPlayerName(snap.val().name); setMode('playerGame'); }
            else { setMode('playerJoin'); setGameId(joinCode); }
          });
        } else { setMode('playerJoin'); setGameId(joinCode); }
      }
    },[]);

    const handleCreate = async (name)=>{ const gid = randomGameID(); setGameId(gid); await db.ref(`games/${gid}/meta`).set({ phase: 'lobby', finaleEnabled: true }); setMode('hostLobby'); };
    
    const handleJoin = async (name, code)=>{
        try {
            if(!name || !code) {
              alert('Bitte Name und Code eingeben');
              return;
            }
            const snap = await db.ref(`games/${code}`).get();
            if(!snap.exists()) { alert('Spiel nicht gefunden!'); return; }
            const pid = makePlayerId();
            await db.ref(`games/${code}/players/${pid}`).set({ name, score: 0, itemSlots: [] });
            sessionStorage.setItem(`quiz_pid_${code}`, pid);
            setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame');
        } catch(e) { console.error('Error joining game:', e); alert('Fehler beim Beitreten'); }
    };
    
    const handlePlayerJoined = (code,pid,name) => { sessionStorage.setItem(`quiz_pid_${code}`, pid); setGameId(code); setPlayerId(pid); setPlayerName(name); setMode('playerGame'); };

    return (
      <>
        {mode === 'start' && <StartScreen onCreate={handleCreate} onJoin={handleJoin} />}
        {mode === 'hostLobby' && <HostScreen gameId={gameId} hostName={playerName} />}
        {mode === 'playerGame' && (
          <>
            <PlayerView gameId={gameId} playerId={playerId} />
            {/* Items Info Modal - accessible from any player view */}
          </>
        )}
        {mode === 'playerJoin' && <PlayerJoin joinGameId={gameId} onJoined={handlePlayerJoined} />}
      </>
    );
  }
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>


